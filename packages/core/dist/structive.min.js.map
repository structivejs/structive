{"version":3,"file":"structive.min.js","sources":["../src/WebComponents/getGlobalConfig.ts","../src/utils.ts","../src/Filter/errorMessages.ts","../src/Filter/builtinFilters.ts","../src/GlobalId/generateId.ts","../src/StateClass/registerStateClass.ts","../src/StyleSheet/registerStyleSheet.ts","../src/StyleSheet/regsiterCss.ts","../src/BindingBuilder/resolveNodeFromPath.ts","../src/BindingBuilder/createFilters.ts","../src/DataBinding/BindingNode/BindingNode.ts","../src/DataBinding/BindingNode/BindingNodeAttribute.ts","../src/constants.ts","../src/StateProperty/getStructuredPathInfo.ts","../src/PathTree/PathNode.ts","../src/StateClass/symbols.ts","../src/StateProperty/getResolvedPathInfo.ts","../src/StatePropertyRef/StatepropertyRef.ts","../src/StateClass/methods/getContextListIndex.ts","../src/StateClass/methods/getListIndex.ts","../src/StateClass/traps/indexByIndexName.ts","../src/ListIndex/ListIndex.ts","../src/StateClass/methods/getByRef.ts","../src/StateClass/methods/checkDependency.ts","../src/StateClass/methods/createListIndexes.ts","../src/StateClass/methods/setByRef.ts","../src/StateClass/apis/resolve.ts","../src/StateClass/traps/get.ts","../src/StateClass/apis/getAll.ts","../src/StateClass/apis/trackDependency.ts","../src/Router/Router.ts","../src/StateClass/methods/getListIndexesByRef.ts","../src/StateClass/apis/connectedCallback.ts","../src/StateClass/apis/disconnectedCallback.ts","../src/StateClass/apis/updatedCallback.ts","../src/StateClass/createReadonlyStateProxy.ts","../src/StateClass/useWritableStateProxy.ts","../src/StateClass/traps/set.ts","../src/StateClass/methods/setLoopContext.ts","../src/Updater/Renderer.ts","../src/Updater/Updater.ts","../src/DataBinding/BindingNode/BindingNodeCheckbox.ts","../src/DataBinding/BindingNode/BindingNodeClassList.ts","../src/DataBinding/BindingNode/BindingNodeClassName.ts","../src/DataBinding/BindingNode/BindingNodeEvent.ts","../src/DataBinding/BindingNode/BindingNodeBlock.ts","../src/DataBinding/BindingNode/BindingNodeIf.ts","../src/DataBinding/BindingNode/BindingNodeFor.ts","../src/DataBinding/BindingNode/BindingNodeProperty.ts","../src/DataBinding/BindingNode/BindingNodeRadio.ts","../src/DataBinding/BindingNode/BindingNodeStyle.ts","../src/ComponentStateInput/symbols.ts","../src/WebComponents/findStructiveParent.ts","../src/WebComponents/getCustomTagName.ts","../src/DataBinding/BindingNode/BindingNodeComponent.ts","../src/BindingBuilder/getBindingNodeCreator.ts","../src/DataBinding/BindingState/BindingState.ts","../src/DataBinding/BindingState/BindingStateIndex.ts","../src/BindingBuilder/getBindingStateCreator.ts","../src/BindingBuilder/getNodeType.ts","../src/BindingBuilder/parseBindText.ts","../src/BindingBuilder/removeDataBindAttribute.ts","../src/BindingBuilder/replaceTextNodeFromComment.ts","../src/BindingBuilder/createDataBindAttributes.ts","../src/BindingBuilder/getDataBindText.ts","../src/BindingBuilder/getAbsoluteNodePath.ts","../src/BindingBuilder/getNodesHavingDataBind.ts","../src/BindingBuilder/registerDataBindAttributes.ts","../src/Template/registerTemplate.ts","../src/Template/removeEmptyTextNodes.ts","../src/DataBinding/Binding.ts","../src/LoopContext/createLoopContext.ts","../src/DataBinding/BindContent.ts","../src/WebComponents/loadFromImportMap.ts","../src/ComponentEngine/attachShadow.ts","../src/ComponentEngine/canHaveShadowRoot.ts","../src/ComponentStateBinding/createComponentStateBinding.ts","../src/ComponentStateInput/createComponentStateInput.ts","../src/ComponentStateOutput/createComponentStateOutput.ts","../src/ComponentEngine/ComponentEngine.ts","../src/Template/replaceMustacheWithTemplateTag.ts","../src/Template/replaceTemplateTagWithComment.ts","../src/Template/registerHtml.ts","../src/StateProperty/createAccessorFunctions.ts","../src/PathManager/PathManager.ts","../src/WebComponents/createComponentClass.ts","../src/WebComponents/getComponentConfig.ts","../src/WebComponents/getBaseClass.ts","../src/WebComponents/createSingleFileComponent.ts","../src/WebComponents/loadSingleFileComponent.ts","../src/WebComponents/registerComponentClass.ts","../src/WebComponents/loadImportmap.ts","../src/MainWrapper/MainWrapper.ts","../src/exports.ts","../src/WebComponents/registerSingleFIleComponents.ts","../src/bootstrap.ts"],"sourcesContent":["/**\r\n * getGlobalConfig.ts\r\n *\r\n * Structive全体で利用するグローバル設定（IConfig）を定義・取得するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - globalConfig: デフォルトのグローバル設定値（debug, locale, shadowDomMode等）を定義\r\n * - getGlobalConfig: グローバル設定オブジェクトを返す関数\r\n * - config: getGlobalConfig()のエイリアスとして即時取得用にエクスポート\r\n *\r\n * 設計ポイント:\r\n * - コンポーネント全体で共通利用する設定値を一元管理\r\n * - デフォルト値を明示し、拡張やカスタマイズにも対応しやすい設計\r\n */\r\nimport { IConfig } from \"./types\";\r\n\r\nconst globalConfig: IConfig = {\r\n  \"debug\"                : false,\r\n  \"locale\"               : \"en-US\", // The locale of the component, ex. \"en-US\", default is \"en-US\"\r\n  \"shadowDomMode\"        : \"auto\", // Shadow DOM mode: \"auto\" (default) | \"none\" | \"force\"\r\n  \"enableMainWrapper\"    : true, // Whether to use the main wrapper or not\r\n  \"enableRouter\"         : true, // Whether to use the router or not\r\n  \"autoInsertMainWrapper\": false, // Whether to automatically insert the main wrapper or not\r\n  \"autoInit\"             : true, // Whether to automatically initialize the component or not\r\n  \"mainTagName\"          : \"app-main\", // The tag name of the main wrapper, default is \"app-main\"\r\n  \"routerTagName\"        : \"view-router\", // The tag name of the router, default is \"view-router\"\r\n  \"layoutPath\"           : \"\", // The path to the layout file, default is \"\"\r\n  \"autoLoadFromImportMap\": false, // Whether to automatically load the component from the import map or not\r\n};\r\n\r\n\r\nexport function getGlobalConfig():IConfig {\r\n  return globalConfig;\r\n}\r\n\r\nexport const config = getGlobalConfig();\r\n","/**\r\n * エラー生成ユーティリティ\r\n *\r\n * 目的:\r\n * - 例外を構造化メタ情報付きで投げる（コード、コンテキスト、ヒント、ドキュメントURL、重大度、原因）\r\n * - 既存の Error を踏襲しつつ、プロパティに追加情報を付与してデバッグ性を高める\r\n *\r\n * 使用例:\r\n * raiseError({\r\n *   code: 'UPD-001',\r\n *   message: 'Engine not initialized',\r\n *   context: { where: 'Renderer.render' },\r\n *   docsUrl: './docs/error-codes.md#upd'\r\n * });\r\n */\r\nexport type StructiveErrorPayload = {\r\n  code: string;\r\n  message: string;\r\n  context?: Record<string, unknown>;\r\n  hint?: string;\r\n  docsUrl?: string;\r\n  severity?: \"error\" | \"warn\";\r\n  cause?: unknown;\r\n};\r\n\r\nexport function raiseError(message: string): never;\r\nexport function raiseError(payload: StructiveErrorPayload): never;\r\nexport function raiseError(messageOrPayload: string | StructiveErrorPayload): never {\r\n  if (typeof messageOrPayload === \"string\") {\r\n    throw new Error(messageOrPayload);\r\n  }\r\n  const { message, code, context, hint, docsUrl, severity, cause } = messageOrPayload;\r\n  const err = new Error(message);\r\n  // 追加情報はプロパティとして付与（メッセージは既存互換のまま）\r\n  (err as any).code = code;\r\n  if (context) (err as any).context = context;\r\n  if (hint) (err as any).hint = hint;\r\n  if (docsUrl) (err as any).docsUrl = docsUrl;\r\n  if (severity) (err as any).severity = severity;\r\n  if (cause) (err as any).cause = cause;\r\n  throw err;\r\n}\r\n","/**\r\n * errorMessages.ts\r\n *\r\n * フィルタ関数などで利用するエラーメッセージ生成ユーティリティです。\r\n *\r\n * 主な役割:\r\n * - フィルタのオプションや値の型チェックで条件を満たさない場合に、分かりやすいエラーメッセージを投げる\r\n * - 関数名を引数に取り、どのフィルタでエラーが発生したかを明示\r\n *\r\n * 設計ポイント:\r\n * - optionsRequired: オプションが必須なフィルタで未指定時にエラー\r\n * - optionMustBeNumber: オプション値が数値でない場合にエラー\r\n * - valueMustBeNumber: 値が数値でない場合にエラー\r\n * - valueMustBeBoolean: 値がbooleanでない場合にエラー\r\n * - valueMustBeDate: 値がDateでない場合にエラー\r\n */\r\nimport { raiseError } from \"../utils\";\r\n\r\nexport function optionsRequired(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires at least one option`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function optionMustBeNumber(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a number as option`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function valueMustBeNumber(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a number value`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function valueMustBeBoolean(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a boolean value`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function valueMustBeDate(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a date value`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}","/**\r\n * builtinFilters.ts\r\n *\r\n * Structiveで利用可能な組み込みフィルタ関数群の実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - 数値・文字列・日付・真偽値などの変換・比較・整形・判定用フィルタを提供\r\n * - フィルタ名ごとにオプション付きの関数を定義し、バインディング時に柔軟に利用可能\r\n * - input/output両方のフィルタとして共通利用できる設計\r\n *\r\n * 設計ポイント:\r\n * - eq, ne, lt, gt, inc, fix, locale, uc, lc, cap, trim, slice, pad, int, float, round, date, time, ymd, falsy, truthy, defaults, boolean, number, string, null など多彩なフィルタを網羅\r\n * - オプション値の型チェックやエラーハンドリングも充実\r\n * - FilterWithOptions型でフィルタ関数群を一元管理し、拡張も容易\r\n * - builtinFilterFnでフィルタ名・オプションからフィルタ関数を動的に取得可能\r\n */\r\nimport { getGlobalConfig } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { optionMustBeNumber, optionsRequired, valueMustBeBoolean, valueMustBeDate, valueMustBeNumber } from \"./errorMessages.js\";\r\nimport { FilterWithOptions } from \"./types\";\r\n\r\nconst config = getGlobalConfig();\r\n\r\nconst eq = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('eq');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('eq');\r\n      return value === optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value === opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value === opt;\r\n  }\r\n}\r\n\r\nconst ne = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ne');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('ne');\r\n      return value !== optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value !== opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value !== opt;\r\n  }\r\n}\r\n\r\nconst not = (options?:string[]) => {\r\n  return (value: any) => {\r\n    if (typeof value !== 'boolean') valueMustBeBoolean('not');\r\n    return !value;\r\n  }\r\n}\r\n\r\nconst lt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('lt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('lt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('lt');\r\n    return value < optValue;\r\n  }\r\n}\r\n\r\nconst le = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('le');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('le');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('le');\r\n    return value <= optValue;\r\n  }\r\n}\r\n\r\nconst gt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('gt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('gt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('gt');\r\n    return value > optValue;\r\n  }\r\n}\r\n\r\nconst ge = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ge');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ge');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ge');\r\n    return value >= optValue;\r\n  }\r\n}\r\n\r\nconst inc = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('inc');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('inc');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('inc');\r\n    return value + optValue;\r\n  }\r\n}\r\n\r\nconst dec = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('dec');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('dec');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('dec');\r\n    return value - optValue;\r\n  }\r\n}\r\n\r\nconst mul = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('mul');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('mul');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('mul');\r\n    return value * optValue;\r\n  }\r\n}\r\n\r\nconst div = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('div');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value / optValue;\r\n  }\r\n}\r\n\r\nconst mod = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('mod');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('mod');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('mod');\r\n    return value % optValue;\r\n  }\r\n}\r\n\r\nconst fix = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('fix');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('fix');\r\n    return value.toFixed(optValue);\r\n  }\r\n}\r\n\r\nconst locale = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('locale');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst uc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toUpperCase();\r\n  }\r\n}\r\n\r\nconst lc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toLowerCase();\r\n  }\r\n}\r\n\r\nconst cap = (options?:string[]) => {\r\n  return (value: any) => {\r\n    const v = value.toString();\r\n    if (v.length === 0) return v;\r\n    if (v.length === 1) return v.toUpperCase();\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n  }\r\n}\r\n\r\nconst trim = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().trim();\r\n  }\r\n}\r\n\r\nconst slice = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('slice');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('slice');\r\n  return (value: any) => {\r\n    return value.toString().slice(optValue);\r\n  }\r\n}\r\n\r\nconst substr = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('substr');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('substr');\r\n  const opt2 = options?.[1] ?? optionsRequired('substr');\r\n  const opt2Value = Number(opt2);\r\n  if (isNaN(opt2Value)) optionMustBeNumber('substr');\r\n  return (value: any) => {\r\n    return value.toString().substr(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst pad = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('pad');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('pad');\r\n  const opt2 = options?.[1] ?? '0';\r\n  const opt2Value = opt2;\r\n  return (value: any) => {\r\n    return value.toString().padStart(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst rep = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('rep');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('rep');\r\n  return (value: any) => {\r\n    return value.toString().repeat(optValue);\r\n  }\r\n}\r\n\r\nconst rev = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().split('').reverse().join('');\r\n  }\r\n}\r\n\r\nconst int = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseInt(value, 10);\r\n  }\r\n}\r\n\r\nconst float = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseFloat(value);\r\n  }\r\n}\r\n\r\nconst round = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('round');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('round');\r\n    return Math.round(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst floor = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('floor');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('floor');\r\n    return Math.floor(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst ceil = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('ceil');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ceil');\r\n    return Math.ceil(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst percent = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('percent');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('percent');\r\n    return (value * 100).toFixed(optValue) + '%';\r\n  }\r\n}\r\n\r\nconst date = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date))  valueMustBeDate('date');\r\n    return value.toLocaleDateString(opt);\r\n  }\r\n}\r\n\r\nconst time = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('time');\r\n    return value.toLocaleTimeString(opt);\r\n  }\r\n}\r\n\r\nconst datetime = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('datetime');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst ymd = (options?:string[]) => {\r\n  const opt = options?.[0] ?? '-';\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('ymd');\r\n    const year = value.getFullYear().toString();\r\n    const month = (value.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = value.getDate().toString().padStart(2, '0');\r\n    return `${year}${opt}${month}${opt}${day}`;\r\n  }\r\n}\r\n\r\nconst falsy = (options?:string[]) => {\r\n  return (value: any) => value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value);\r\n}\r\n\r\nconst truthy = (options?:string[]) => {\r\n  return (value: any) =>value !== false && value !== null && value !== undefined && value !== 0 && value !== '' && !Number.isNaN(value);\r\n}\r\n\r\nconst defaults = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('defaults');\r\n  return (value: any) => {\r\n    if (value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value)) return opt;\r\n    return value;\r\n  }\r\n}\r\n\r\nconst boolean = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Boolean(value);\r\n  }\r\n}\r\n\r\nconst number = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Number(value);\r\n  }\r\n}\r\n\r\nconst string = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return String(value);\r\n  }\r\n}\r\n\r\nconst _null = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return (value === \"\") ? null : value;\r\n  } \r\n}\r\n\r\nconst builtinFilters: FilterWithOptions = {\r\n  \"eq\": eq,\r\n  \"ne\": ne,\r\n  \"not\": not,\r\n\r\n  \"lt\": lt,\r\n  \"le\": le,\r\n  \"gt\": gt,\r\n  \"ge\": ge,\r\n\r\n  \"inc\": inc,\r\n  \"dec\": dec,\r\n  \"mul\": mul,\r\n  \"div\": div,\r\n  \"mod\": mod,\r\n\r\n  \"fix\": fix,\r\n  \"locale\": locale,\r\n  \"uc\": uc,\r\n  \"lc\": lc,\r\n  \"cap\": cap,\r\n  \"trim\": trim,\r\n  \"slice\": slice,\r\n  \"substr\": substr,\r\n  \"pad\": pad,\r\n  \"rep\": rep,\r\n  \"rev\": rev,\r\n\r\n  \"int\": int,\r\n  \"float\": float,\r\n  \"round\": round,\r\n  \"floor\": floor,\r\n  \"ceil\": ceil,\r\n  \"percent\": percent,\r\n\r\n  \"date\": date,\r\n  \"time\": time,\r\n  \"datetime\": datetime,\r\n  \"ymd\": ymd,\r\n\r\n  \"falsy\": falsy,\r\n  \"truthy\": truthy,\r\n  \"defaults\": defaults,\r\n\r\n  \"boolean\": boolean,\r\n  \"number\": number,\r\n  \"string\": string,\r\n  \"null\": _null,\r\n};\r\n\r\nexport const outputBuiltinFilters = builtinFilters;\r\nexport const inputBuiltinFilters = builtinFilters;\r\n\r\nexport const builtinFilterFn = (name:string, options: string[]) => (filters: FilterWithOptions) => {\r\n  const filter = filters[name];\r\n  if (!filter) {\r\n    raiseError({\r\n      code: \"FLT-201\",\r\n      message: `Filter not found: ${name}`,\r\n      context: { where: 'builtinFilterFn', name },\r\n      docsUrl: \"./docs/error-codes.md#flt\",\r\n    });\r\n  }\r\n  return filter(options);\r\n}\r\n\r\n","\r\nlet id = 0;\r\n\r\nexport function generateId(): number {\r\n  return ++id;\r\n}","/**\r\n * registerStateClass.ts\r\n *\r\n * StateClassインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - stateClassById: IDをキーにStateClassインスタンスを管理するレコード\r\n * - registerStateClass: 指定IDでStateClassインスタンスを登録\r\n * - getStateClassById: 指定IDのStateClassインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにStateClassインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IStructiveState } from \"./types\";\r\n\r\nconst stateClassById: Record<number,IStructiveState> = {};\r\n\r\nexport function registerStateClass(id: number, stateClass: IStructiveState) {\r\n  stateClassById[id] = stateClass;\r\n}\r\n\r\nexport function getStateClassById(id: number): IStructiveState {\r\n  return stateClassById[id] ?? raiseError({\r\n    code: \"STATE-101\",\r\n    message: `StateClass not found: ${id}`,\r\n    context: { where: 'registerStateClass.getStateClassById', stateClassId: id },\r\n    docsUrl: \"./docs/error-codes.md#state\",\r\n  });\r\n}\r\n","/**\r\n * registerStyleSheet.ts\r\n *\r\n * CSSStyleSheetインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - styleSheetById: IDをキーにCSSStyleSheetインスタンスを管理するレコード\r\n * - registerStyleSheet: 指定IDでCSSStyleSheetインスタンスを登録\r\n * - getStyleSheetById: 指定IDのCSSStyleSheetインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにCSSStyleSheetインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst styleSheetById: Record<number,CSSStyleSheet> = {};\r\n\r\nexport function registerStyleSheet(id: number, css: CSSStyleSheet) {\r\n  styleSheetById[id] = css;\r\n}\r\n\r\nexport function getStyleSheetById(id: number): CSSStyleSheet {\r\n  return styleSheetById[id] ?? raiseError({\r\n    code: \"CSS-001\",\r\n    message: `Stylesheet not found: ${id}`,\r\n    context: { where: 'registerStyleSheet.getStyleSheetById', styleSheetId: id },\r\n    docsUrl: \"./docs/error-codes.md#css\",\r\n  });\r\n}","/**\r\n * regsiterCss.ts\r\n *\r\n * CSS文字列をCSSStyleSheetとして生成し、IDで登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - CSS文字列からCSSStyleSheetインスタンスを生成\r\n * - registerStyleSheetを利用して、指定IDでCSSStyleSheetを登録\r\n *\r\n * 設計ポイント:\r\n * - styleSheet.replaceSyncで同期的にCSSを適用\r\n * - グローバルなスタイル管理や動的スタイル適用に利用可能\r\n */\r\nimport { registerStyleSheet } from \"./registerStyleSheet.js\";\r\n\r\nexport function registerCss(id: number, css: string) {\r\n  const styleSheet = new CSSStyleSheet();\r\n  styleSheet.replaceSync(css);\r\n  registerStyleSheet(id, styleSheet);\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * Utility function to traverse and retrieve the target node from root node and node path (index array).\r\n *\r\n * NodePath structure:\r\n * - Numeric array representing childNodes index at each level\r\n * - Example: [1, 2] represents root.childNodes[1].childNodes[2]\r\n * - Empty array [] represents root node itself\r\n * \r\n * Processing characteristics:\r\n * - Traverse childNodes[index] sequentially from root to get target node\r\n * - Returns null if node doesn't exist midway (error-safe)\r\n * - Uses for loop instead of reduce (breaks immediately when null)\r\n * \r\n * Processing flow:\r\n * 1. Set root node as starting point\r\n * 2. If path is empty array, return root node (early return)\r\n * 3. Traverse each index in path sequentially:\r\n *    a. Get childNodes[index] of current node\r\n *    b. If node doesn't exist, set null and break loop\r\n * 4. Return final node (or null)\r\n * \r\n * DOM tree example:\r\n * ```html\r\n * <div>                    // root (index: -)\r\n *   <span>Hello</span>     // root.childNodes[0]\r\n *   <ul>                   // root.childNodes[1]\r\n *     <li>Item 1</li>      // root.childNodes[1].childNodes[0]\r\n *     <li>Item 2</li>      // root.childNodes[1].childNodes[1]\r\n *   </ul>\r\n * </div>\r\n * ```\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * const root = document.querySelector('#root');\r\n * \r\n * // Empty path → Returns root node itself\r\n * const node1 = resolveNodeFromPath(root, []);\r\n * // → root\r\n * \r\n * // Single index\r\n * const node2 = resolveNodeFromPath(root, [1]);\r\n * // → root.childNodes[1] (<ul> element)\r\n * \r\n * // Multiple levels\r\n * const node3 = resolveNodeFromPath(root, [1, 1]);\r\n * // → root.childNodes[1].childNodes[1] (<li>Item 2</li>)\r\n * \r\n * // Invalid path (non-existent index)\r\n * const node4 = resolveNodeFromPath(root, [1, 5]);\r\n * // → null (childNodes[5] doesn't exist)\r\n * \r\n * // Invalid path (no node midway)\r\n * const node5 = resolveNodeFromPath(root, [0, 0, 0]);\r\n * // → null (<span>Hello</span>'s childNodes[0] is text node,\r\n * //         its childNodes[0] doesn't exist)\r\n * ```\r\n * \r\n * @param root - Root node as starting point for traversal\r\n * @param path - Index array for each level (NodePath)\r\n * @returns Node specified by path, or null\r\n */\r\nexport function resolveNodeFromPath(root: Node, path: NodePath): Node | null {\r\n  // Step 1: Set root node as starting point\r\n  let node = root;\r\n  \r\n  // Step 2: Return root node if path is empty\r\n  if (path.length === 0) return node;\r\n  \r\n  // Step 3: Traverse each index in path sequentially\r\n  // Using for loop instead of path.reduce() to explicitly check and break when null\r\n  for (let i = 0; i < path.length; i++) {\r\n    // Get childNodes[index] of current node (null if doesn't exist)\r\n    node = node?.childNodes[path[i]] ?? null;\r\n    \r\n    // Break loop if node doesn't exist\r\n    if (node === null) break;\r\n  }\r\n  \r\n  // Step 4: Return final node (or null)\r\n  return node;\r\n}","import { FilterFn, Filters, FilterWithOptions } from \"../Filter/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\n\r\n/**\r\n * Generates an executable filter function (FilterFn) from filter text metadata\r\n * (containing name and options).\r\n * \r\n * Processing flow:\r\n * 1. Look up filter function from registry by filter name\r\n * 2. Raise error if not found\r\n * 3. Apply options array and return customized filter function\r\n * \r\n * @param filters - Filter registry (name -> factory function map)\r\n * @param text - Filter metadata (name and options array)\r\n * @returns Customized filter function\r\n * @throws When filter is not found\r\n */\r\nfunction textToFilter(filters: FilterWithOptions, text: IFilterText): FilterFn {\r\n  // Look up filter from registry by name\r\n  const filter = filters[text.name];\r\n  \r\n  if (!filter) {\r\n    // Raise error when filter is not found\r\n    raiseError({\r\n      code: 'FLT-201',\r\n      message: `Filter not found: ${text.name}`,\r\n      context: { where: 'createFilters.textToFilter', name: text.name },\r\n      docsUrl: './docs/error-codes.md#flt',\r\n    });\r\n  }\r\n  \r\n  // Pass options array to filter factory to generate executable function\r\n  // Example: filters['currency'](['USD', '2']) => (value) => formatCurrency(value, 'USD', 2)\r\n  return filter(text.options);\r\n}\r\n\r\n/**\r\n * Cache for filter text arrays\r\n * When the same filter array is used multiple times, return from cache instead of regenerating\r\n */\r\nconst cache: Map<IFilterText[], Filters> = new Map();\r\n\r\n/**\r\n * Generates an array of executable filter functions from filter text array (metadata).\r\n * Uses cache for the same texts array to optimize performance.\r\n * \r\n * Processing flow:\r\n * 1. Check cache (has this texts array been processed before?)\r\n * 2. On cache hit, return cached result\r\n * 3. On cache miss, transform each filter text via textToFilter\r\n * 4. Store generated function array in cache\r\n * 5. Return filter function array\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * const filterTexts = [\r\n *   { name: 'trim', options: [] },\r\n *   { name: 'uppercase', options: [] }\r\n * ];\r\n * const filterFns = createFilters(registry, filterTexts);\r\n * // filterFns[0](value) -> trim(value)\r\n * // filterFns[1](value) -> uppercase(value)\r\n * ```\r\n * \r\n * @param filters - Filter registry (name -> factory function map)\r\n * @param texts - Array of filter metadata\r\n * @returns Array of executable filter functions\r\n */\r\nexport function createFilters(filters: FilterWithOptions, texts: IFilterText[]): Filters {\r\n  // Check cache\r\n  let result = cache.get(texts);\r\n  \r\n  if (typeof result === \"undefined\") {\r\n    // Cache miss: generate new\r\n    result = [];\r\n    \r\n    // Transform each filter text into executable function\r\n    for (let i = 0; i < texts.length; i++) {\r\n      result.push(textToFilter(filters, texts[i]));\r\n    }\r\n    \r\n    // Store generated function array in cache (reuse in subsequent calls)\r\n    cache.set(texts, result);\r\n  }\r\n  \r\n  // Return cached or newly generated result\r\n  return result;\r\n}\r\n","import { Filters } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IReadonlyStateProxy } from \"../../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../../Updater/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { IBindingNode } from \"./types\";\r\n\r\n/**\r\n * BindingNode class is the base class for binding processing on a single target node (Element, Text, etc.).\r\n *\r\n * Architecture:\r\n * - _binding: Reference to parent binding (IBinding)\r\n * - _node: Target DOM node for binding\r\n * - _name: Property name of binding (e.g., \"textContent\", \"value\")\r\n * - _filters: Array of filter functions applied when retrieving value\r\n * - _decorates: Array of decorator strings (e.g., [\"prevent\", \"stop\"])\r\n * - _bindContents: Array of child BindContent (for structural control bindings)\r\n *\r\n * Main responsibilities:\r\n * 1. Hold node, property name, filters, decorators, and binding info\r\n * 2. Provide interface for binding value update (applyChange → assignValue)\r\n * 3. Manage multiple bind contents (bindContents) for structural control bindings\r\n * 4. Extend binding processing per node/property type by implementing assignValue, updateElements in subclasses\r\n *\r\n * Design patterns:\r\n * - Template Method: applyChange provides common flow, assignValue implemented in subclasses\r\n * - Strategy: Customize behavior with filters and decorators\r\n *\r\n * Subclasses:\r\n * - BindingNodeAttribute: Attribute binding\r\n * - BindingNodeProperty*: Property binding (value, checked, etc.)\r\n * - BindingNodeEvent*: Event binding\r\n * - BindingNodeFor, BindingNodeIf: Structural control binding\r\n *\r\n * Design points:\r\n * - assignValue, updateElements are unimplemented (must override in subclasses)\r\n * - isSelectElement, value, filteredValue etc. extended in subclasses as needed\r\n * - Flexible handling of filters, decorators, and bind contents\r\n */\r\nexport class BindingNode implements IBindingNode {\r\n  private _binding: IBinding;\r\n  private _node: Node;\r\n  private _name: string;\r\n  private _subName: string;\r\n  private _filters: Filters;\r\n  private _decorates: string[];\r\n  \r\n  /**\r\n   * Getter to return target DOM node for binding.\r\n   * \r\n   * @returns Target DOM node\r\n   */\r\n  get node(): Node {\r\n    return this._node;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return property name of binding (e.g., \"textContent\", \"value\").\r\n   * \r\n   * @returns Property name string\r\n   */\r\n  get name(): string {\r\n    return this._name;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return sub-property name (same as name in base class, can be overridden in subclasses).\r\n   * \r\n   * @returns Sub-property name string\r\n   */\r\n  get subName(): string {\r\n    return this._subName;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return parent binding (IBinding).\r\n   * \r\n   * @returns Parent IBinding instance\r\n   */\r\n  get binding(): IBinding {\r\n    return this._binding;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return array of decorator strings (e.g., [\"prevent\", \"stop\"]).\r\n   * \r\n   * @returns Array of decorator strings\r\n   */\r\n  get decorates(): string[] {\r\n    return this._decorates;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return array of filter functions.\r\n   * \r\n   * @returns Array of filter functions\r\n   */\r\n  get filters(): Filters {\r\n    return this._filters;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return array of child BindContent (for structural control bindings).\r\n   * \r\n   * @returns Array of IBindContent instances (empty in base class)\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return [];\r\n  }\r\n  \r\n  /**\r\n   * Constructor.\r\n   * - binding: Parent binding\r\n   * - node: Target DOM node for binding\r\n   * - name: Property name of binding\r\n   * - filters: Array of filter functions\r\n   * - decorates: Array of decorator strings\r\n   *\r\n   * Initialization process:\r\n   * 1. Save all parameters to private fields\r\n   * 2. bindContents initialized as empty array\r\n   * 3. Subclasses can implement additional initialization in activate()\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Target DOM node\r\n   * @param name - Property name of binding\r\n   * @param subName - Sub-property name\r\n   * @param filters - Array of filter functions\r\n   * @param decorates - Array of decorator strings\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    this._binding = binding;\r\n    this._node = node;\r\n    this._name = name;\r\n    this._subName = subName;\r\n    this._filters = filters;\r\n    this._decorates = decorates;\r\n  }\r\n  \r\n  /**\r\n   * Method to assign value to DOM (unimplemented in base class, must override in subclasses).\r\n   * - Attribute binding: Set attribute value\r\n   * - Property binding: Set property value\r\n   * - Event binding: Register event listener\r\n   * - Structural control binding: Modify DOM structure\r\n   *\r\n   * @param value - Value to assign to DOM\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  assignValue(value: any): void {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingNode.assignValue', name: this.name },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Method to batch update multiple elements (unimplemented in base class, override in structural control bindings).\r\n   * - BindingNodeFor: Batch update of loop items\r\n   * - Other bindings: Normally not used\r\n   *\r\n   * @param listIndexes - Array of list indices\r\n   * @param values - Array of values\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingNode.updateElements', name: this.name },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Redraw notification method (empty implementation in base class, can override in subclasses).\r\n   * - Used to update related bindings after dynamic dependency resolution\r\n   * - Used in structural control bindings to notify child BindContent\r\n   *\r\n   * @param refs - Array of state references for redraw\r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    // Subclasses can implement notification considering parent-child relationships\r\n  }\r\n  \r\n  /**\r\n   * Change application method (Template Method pattern).\r\n   * - Retrieves filtered value from BindingState\r\n   * - Calls assignValue to reflect to DOM\r\n   * - Subclasses override assignValue to implement specific processing\r\n   *\r\n   * @param renderer - Renderer instance for state access\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState, renderer.readonlyHandler);\r\n    this.assignValue(filteredValue);\r\n  }\r\n  \r\n  /**\r\n   * Method to activate binding node (empty implementation in base class, can override in subclasses).\r\n   * - Execute initial rendering\r\n   * - Register event listeners (event binding)\r\n   * - Initialize child BindContent (structural control binding)\r\n   */\r\n  activate(): void {\r\n    // Subclasses can implement activation processing\r\n  }\r\n  \r\n  /**\r\n   * Method to inactivate binding node (empty implementation in base class, can override in subclasses).\r\n   * - Unregister event listeners (event binding)\r\n   * - Cleanup child BindContent (structural control binding)\r\n   */\r\n  inactivate(): void {\r\n    // Subclasses can implement inactivation processing\r\n  }\r\n\r\n  /**\r\n   * Getter to determine if node is HTMLSelectElement.\r\n   * Used for special handling of select elements in property binding.\r\n   * \r\n   * @returns true if node is HTMLSelectElement, false otherwise\r\n   */\r\n  get isSelectElement(): boolean {\r\n    return this.node instanceof HTMLSelectElement;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return current value (null in base class, override in subclasses).\r\n   * Used to get current DOM value in bidirectional binding.\r\n   * \r\n   * @returns Current value or null\r\n   */\r\n  get value():any {\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return filtered value (null in base class, override in subclasses).\r\n   * Used to get filtered DOM value in bidirectional binding.\r\n   * \r\n   * @returns Filtered value or null\r\n   */\r\n  get filteredValue():any {\r\n    return null;\r\n  }\r\n\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeAttribute class implements binding node for attribute bindings (e.g., attr.src, attr.alt).\r\n * Converts null/undefined/NaN to empty string to conform to HTML spec.\r\n */\r\nclass BindingNodeAttribute extends BindingNode {\r\n  /**\r\n   * Assigns attribute value to DOM element.\r\n   * Converts null/undefined/NaN to empty string.\r\n   * \r\n   * @param value - Value to assign to attribute\r\n   */\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as Element;\r\n    element.setAttribute(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate attribute binding node.\r\n * \r\n * @param name - Binding name (e.g., \"attr.src\", \"attr.alt\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeAttribute with binding, node, and filters\r\n */\r\nexport const createBindingNodeAttribute: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      const [, subName] = name.split(\".\");\r\n      return new BindingNodeAttribute(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","export const DATA_BIND_ATTRIBUTE = \"data-bind\";\r\nexport const COMMENT_EMBED_MARK = \"@@:\"; // 埋め込み変数のマーク\r\nexport const COMMENT_TEMPLATE_MARK = \"@@|\"; // テンプレートのマーク\r\nexport const MAX_WILDCARD_DEPTH = 32; // ワイルドカードの最大深度\r\nexport const WILDCARD = \"*\"; // ワイルドカード\r\nexport const RESERVED_WORD_SET = new Set([\r\n  \"constructor\", \"prototype\", \"__proto__\", \"toString\",\r\n  \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\r\n  \"watch\", \"unwatch\", \"eval\", \"arguments\",\r\n  \"let\", \"var\", \"const\", \"class\", \"function\",\r\n  \"null\", \"true\", \"false\", \"new\", \"return\",\r\n]);\r\n\r\nexport const CONNECTED_CALLBACK_FUNC_NAME = \"$connectedCallback\";\r\nexport const DISCONNECTED_CALLBACK_FUNC_NAME = \"$disconnectedCallback\";\r\nexport const UPDATED_CALLBACK_FUNC_NAME = \"$updatedCallback\";","/**\r\n * getStructuredPathInfo.ts\r\n *\r\n * Stateプロパティのパス文字列から、詳細な構造化パス情報（IStructuredPathInfo）を生成・キャッシュするユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス文字列を分割し、各セグメントやワイルドカード（*）の位置・親子関係などを解析\r\n * - cumulativePaths/wildcardPaths/parentPathなど、パス階層やワイルドカード階層の情報を構造化\r\n * - 解析結果をIStructuredPathInfoとしてキャッシュし、再利用性とパフォーマンスを両立\r\n * - reservedWords（予約語）チェックで安全性を担保\r\n *\r\n * 設計ポイント:\r\n * - パスごとにキャッシュし、同じパスへの複数回アクセスでも高速に取得可能\r\n * - ワイルドカードや親子関係、階層構造を厳密に解析し、バインディングや多重ループに最適化\r\n * - childrenプロパティでパス階層のツリー構造も構築\r\n * - 予約語や危険なパスはraiseErrorで例外を発生\r\n */\r\nimport { RESERVED_WORD_SET } from '../constants.js';\r\nimport { raiseError } from '../utils.js';\r\nimport { IStructuredPathInfo } from './types';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IStructuredPathInfo } = {};\r\n\r\n/**\r\n * パターン情報を取得します\r\n * @param pattern パターン\r\n * @returns {IPatternInfo} パターン情報\r\n */\r\nclass StructuredPathInfo implements IStructuredPathInfo {\r\n  static id : number = 0;\r\n  id = ++StructuredPathInfo.id;\r\n  sid = this.id.toString();\r\n  pattern;\r\n  pathSegments;\r\n  lastSegment;\r\n  cumulativePaths;\r\n  cumulativePathSet;\r\n  cumulativeInfos;\r\n  cumulativeInfoSet;\r\n  wildcardPaths;\r\n  wildcardPathSet;\r\n  wildcardInfos;\r\n  indexByWildcardPath;\r\n  wildcardInfoSet;\r\n  wildcardParentPaths;\r\n  wildcardParentPathSet;\r\n  wildcardParentInfos;\r\n  wildcardParentInfoSet;\r\n  lastWildcardPath;\r\n  lastWildcardInfo;\r\n  parentPath;\r\n  parentInfo;\r\n  wildcardCount;\r\n  children = {};\r\n\r\n  constructor(pattern: string) {\r\n    const getPattern = (_pattern: string): IStructuredPathInfo => {\r\n      return (pattern === _pattern) ? this : getStructuredPathInfo(_pattern);\r\n    };\r\n    const pathSegments = pattern.split(\".\");\r\n    const cumulativePaths = [];\r\n    const cumulativeInfos: IStructuredPathInfo[] = [];\r\n    const wildcardPaths = [];\r\n    const indexByWildcardPath: Record<string, number> = {};\r\n    const wildcardInfos = [];\r\n    const wildcardParentPaths = [];\r\n    const wildcardParentInfos = [];\r\n    let currentPatternPath = \"\", prevPatternPath = \"\";\r\n    let wildcardCount = 0;\r\n    for(let i = 0; i < pathSegments.length; i++) {\r\n      currentPatternPath += pathSegments[i];\r\n      if (pathSegments[i] === \"*\") {\r\n        wildcardPaths.push(currentPatternPath);\r\n        indexByWildcardPath[currentPatternPath] = wildcardCount;\r\n        wildcardInfos.push(getPattern(currentPatternPath));\r\n        wildcardParentPaths.push(prevPatternPath);\r\n        wildcardParentInfos.push(getPattern(prevPatternPath));\r\n        wildcardCount++;\r\n      }\r\n      cumulativePaths.push(currentPatternPath);\r\n      cumulativeInfos.push(getPattern(currentPatternPath));\r\n      prevPatternPath = currentPatternPath;\r\n      currentPatternPath += \".\";\r\n    }\r\n    const lastWildcardPath = wildcardPaths.length > 0 ? wildcardPaths[wildcardPaths.length - 1] : null;\r\n    const parentPath = cumulativePaths.length > 1 ? cumulativePaths[cumulativePaths.length - 2] : null;\r\n    this.pattern = pattern;\r\n    this.pathSegments = pathSegments;\r\n    this.lastSegment = pathSegments[pathSegments.length - 1];\r\n    this.cumulativePaths = cumulativePaths;\r\n    this.cumulativePathSet = new Set(cumulativePaths);\r\n    this.cumulativeInfos = cumulativeInfos;\r\n    this.cumulativeInfoSet = new Set(cumulativeInfos);\r\n    this.wildcardPaths = wildcardPaths;\r\n    this.wildcardPathSet = new Set(wildcardPaths);\r\n    this.indexByWildcardPath = indexByWildcardPath;\r\n    this.wildcardInfos = wildcardInfos;\r\n    this.wildcardInfoSet = new Set(wildcardInfos);\r\n    this.wildcardParentPaths = wildcardParentPaths;\r\n    this.wildcardParentPathSet = new Set(wildcardParentPaths);\r\n    this.wildcardParentInfos = wildcardParentInfos;\r\n    this.wildcardParentInfoSet = new Set(wildcardParentInfos);\r\n    this.lastWildcardPath = lastWildcardPath;\r\n    this.lastWildcardInfo = lastWildcardPath ? getPattern(lastWildcardPath) : null;\r\n    this.parentPath = parentPath;\r\n    this.parentInfo = parentPath ? getPattern(parentPath) : null;\r\n    this.wildcardCount = wildcardCount;\r\n    if (this.parentInfo) {\r\n      this.parentInfo.children[this.lastSegment] = this;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport function getStructuredPathInfo(structuredPath: string): IStructuredPathInfo {\r\n  if (RESERVED_WORD_SET.has(structuredPath)) {\r\n    raiseError({\r\n      code: 'STATE-202',\r\n      message: `Pattern is reserved word: ${structuredPath}`,\r\n      context: { where: 'getStructuredPathInfo', structuredPath },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n  const info = _cache[structuredPath];\r\n  if (typeof info !== \"undefined\") {\r\n    return info;\r\n  }\r\n  return (_cache[structuredPath] = new StructuredPathInfo(structuredPath));\r\n}\r\n","import { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IPathNode } from \"./types\";\r\n\r\nclass NodePath implements IPathNode {\r\n  parentPath: string;\r\n  currentPath: string;\r\n  name: string;\r\n  childNodeByName: Map<string, IPathNode>;\r\n  level: number;\r\n\r\n  constructor(parentPath: string, name: string, level: number) {\r\n    this.parentPath = parentPath;\r\n    this.currentPath = parentPath ? parentPath + \".\" + name : name;\r\n    this.name = name;\r\n    this.level = level;\r\n    this.childNodeByName = new Map<string, IPathNode>();\r\n  }\r\n\r\n  find(segments: string[], segIndex: number = 0): IPathNode | null {\r\n    if (segIndex >= segments.length) {\r\n      return null;\r\n    }\r\n\r\n    const currentSegment = segments[segIndex];\r\n    const childNode = this.childNodeByName.get(currentSegment);\r\n\r\n    if (childNode) {\r\n      if (segIndex === segments.length - 1) {\r\n        return childNode;\r\n      }\r\n      return childNode.find(segments, segIndex + 1);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  appendChild(childName: string): IPathNode {\r\n    let childNode = this.childNodeByName.get(childName);\r\n    if (!childNode) {\r\n      const currentPath = this.parentPath ? this.parentPath + \".\" + this.name : this.name;\r\n      childNode = new NodePath(currentPath, childName, this.level + 1);\r\n      this.childNodeByName.set(childName, childNode);\r\n    }\r\n    return childNode;\r\n  }\r\n}\r\n\r\nexport function createRootNode(): IPathNode {\r\n  return new NodePath(\"\", \"\", 0);\r\n}\r\n\r\nconst cache = new Map<IPathNode, Map<string, IPathNode | null>>();\r\nexport function findPathNodeByPath(rootNode: IPathNode, path: string): IPathNode | null {\r\n  let nodeCache = cache.get(rootNode);\r\n  if (!nodeCache) {\r\n    nodeCache = new Map<string, IPathNode>();\r\n    cache.set(rootNode, nodeCache);\r\n  }\r\n  let cachedNode = nodeCache.get(path) ?? null;\r\n  if (cachedNode) {\r\n    return cachedNode;\r\n  }\r\n  const info = getStructuredPathInfo(path);\r\n  cachedNode = rootNode.find(info.pathSegments);\r\n  nodeCache.set(path, cachedNode);\r\n  return cachedNode;\r\n}\r\n\r\nexport function addPathNode(rootNode: IPathNode, path: string): IPathNode {\r\n  const info = getStructuredPathInfo(path);\r\n  if (info.parentPath === null) {\r\n    return rootNode.appendChild(path);\r\n  } else {\r\n    let parentNode = findPathNodeByPath(rootNode, info.parentPath);\r\n    if (parentNode === null) {\r\n      parentNode = addPathNode(rootNode, info.parentPath);\r\n    }\r\n    return parentNode.appendChild(info.lastSegment);\r\n  }\r\n}\r\n","\r\nconst symbolName = \"state\";\r\n\r\nexport const GetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.GetByRef`);\r\nexport const SetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.SetByRef`);\r\nexport const SetCacheableSymbol        : unique symbol = Symbol.for(`${symbolName}.SetCacheable`);\r\nexport const ConnectedCallbackSymbol   : unique symbol = Symbol.for(`${symbolName}.ConnectedCallback`);\r\nexport const DisconnectedCallbackSymbol: unique symbol = Symbol.for(`${symbolName}.DisconnectedCallback`);\r\nexport const UpdatedCallbackSymbol     : unique symbol = Symbol.for(`${symbolName}.UpdatedCallback`);\r\nexport const GetListIndexesByRefSymbol : unique symbol = Symbol.for(`${symbolName}.GetListIndexesByRef`);\r\n","/**\r\n * getResolvedPathInfo.ts\r\n *\r\n * Stateプロパティ名（パス文字列）から、ワイルドカードやインデックス情報を含む\r\n * 詳細なパス情報（IResolvedPathInfo）を解析・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - プロパティ名を分解し、ワイルドカードやインデックスの有無・種別を判定\r\n * - context/all/partial/none のワイルドカード種別を自動判定\r\n * - パスごとにキャッシュし、再利用性とパフォーマンスを両立\r\n * - getStructuredPathInfoで構造化パス情報も取得\r\n *\r\n * 設計ポイント:\r\n * - \"constructor\"や\"toString\"などの予約語も扱えるよう、Mapではなくオブジェクトでキャッシュ\r\n * - ワイルドカード（*）や数値インデックスを柔軟に判定し、wildcardIndexesに格納\r\n * - context型は未確定インデックス、all型は全て確定インデックス、partial型は混在を示す\r\n * - ResolvedPathInfoクラスでパス解析・情報保持を一元化\r\n */\r\nimport { IResolvedPathInfo, WildcardType } from './types';\r\nimport { getStructuredPathInfo } from './getStructuredPathInfo.js';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: Map<string, IResolvedPathInfo> = new Map();\r\n\r\nclass ResolvedPathInfo implements IResolvedPathInfo {\r\n  static id : number = 0;\r\n  id = ++ResolvedPathInfo.id;\r\n  name;\r\n  elements;\r\n  paths;\r\n  wildcardCount;\r\n  wildcardType;\r\n  wildcardIndexes;\r\n  info;\r\n  constructor(name: string) {\r\n    const elements = name.split(\".\");\r\n    const tmpPatternElements = elements.slice();\r\n    const paths = [];\r\n    let incompleteCount = 0;\r\n    let completeCount = 0;\r\n    let lastPath = \"\";\r\n    let wildcardCount = 0;\r\n    let wildcardType: WildcardType = \"none\";\r\n    let wildcardIndexes: (number | null)[] = [];\r\n    for(let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (element === \"*\") {\r\n        tmpPatternElements[i] = \"*\";\r\n        wildcardIndexes.push(null);\r\n        incompleteCount++;\r\n        wildcardCount++;\r\n      } else {\r\n        const number = Number(element);\r\n        if (!Number.isNaN(number)) {\r\n          tmpPatternElements[i] = \"*\";\r\n          wildcardIndexes.push(number);\r\n          completeCount++;\r\n          wildcardCount++;\r\n        }\r\n      }\r\n      lastPath += element;\r\n      paths.push(lastPath);\r\n      lastPath += (i < elements.length - 1 ? \".\" : \"\");\r\n    }\r\n    const pattern = tmpPatternElements.join(\".\");\r\n    const info = getStructuredPathInfo(pattern);\r\n    if (incompleteCount > 0 || completeCount > 0) {\r\n      if (incompleteCount === wildcardCount) {\r\n        wildcardType = \"context\";\r\n      } else if (completeCount === wildcardCount) {\r\n        wildcardType = \"all\";\r\n      } else {\r\n        wildcardType = \"partial\";\r\n      }\r\n    }\r\n    this.name = name;\r\n    this.elements = elements;\r\n    this.paths = paths;\r\n    this.wildcardCount = wildcardCount;\r\n    this.wildcardType = wildcardType;\r\n    this.wildcardIndexes = wildcardIndexes;\r\n    this.info = info;\r\n  }\r\n}\r\n\r\nexport function getResolvedPathInfo(name:string):IResolvedPathInfo {\r\n  let nameInfo: IResolvedPathInfo | undefined;\r\n  return _cache.get(name) ?? (_cache.set(name, nameInfo = new ResolvedPathInfo(name)), nameInfo);\r\n}","/**\r\n * StatePropertyRef\r\n *\r\n * 目的:\r\n * - State の構造化パス情報(IStructuredPathInfo)と、任意のリストインデックス(IListIndex)から\r\n *   一意な参照オブジェクト(IStatePropertyRef)を生成・キャッシュする。\r\n * - 同一(info,listIndex)組み合わせに対しては同一インスタンスを返し、比較やMapキーとして安定運用できるようにする。\r\n *\r\n * 実装メモ:\r\n * - key は info.sid と listIndex.sid から合成（listIndex が null の場合は info.sid のみ）\r\n * - listIndex は WeakRef で保持し、GC で消えた場合は LIST-201 を送出\r\n * - キャッシュは listIndex 非 null の場合は WeakMap(listIndex) 配下に、null の場合は Map(info) に保持\r\n */\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IStatePropertyRef } from \"./types\";\r\n\r\nclass StatePropertyRef implements IStatePropertyRef {\r\n  info: IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null;\r\n  get listIndex(): IListIndex | null {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError({\r\n      code: \"LIST-201\",\r\n      message: \"listIndex is null\",\r\n      context: { sid: this.info.sid, key: this.key },\r\n      docsUrl: \"./docs/error-codes.md#list\",\r\n    });\r\n  }\r\n  key: string;\r\n  constructor(\r\n    info: IStructuredPathInfo,\r\n    listIndex: IListIndex | null,\r\n  ) {\r\n    this.info = info;\r\n    this.#listIndexRef = listIndex !== null ? new WeakRef(listIndex) : null;\r\n    this.key = (listIndex == null) ? info.sid : (info.sid + \"#\" + listIndex.sid);\r\n  }\r\n\r\n  get parentRef(): IStatePropertyRef | null {\r\n    const parentInfo = this.info.parentInfo;\r\n    if (!parentInfo) return null;\r\n    const parentListIndex = (this.info.wildcardCount > parentInfo.wildcardCount ? this.listIndex?.at(-2) : this.listIndex) ?? null;\r\n    return getStatePropertyRef(parentInfo, parentListIndex);\r\n  }\r\n}\r\n\r\nconst refByInfoByListIndex: WeakMap<IListIndex, Record<string, IStatePropertyRef>> = new WeakMap();\r\nconst refByInfoByNull: Record<string, IStatePropertyRef> = {};\r\n\r\nexport function getStatePropertyRef(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n): IStatePropertyRef {\r\n  let ref = null;\r\n  if (listIndex !== null) {\r\n    let refByInfo;\r\n    if (typeof (refByInfo = refByInfoByListIndex.get(listIndex)) === \"undefined\") {\r\n      ref = new StatePropertyRef(info, listIndex);\r\n      refByInfoByListIndex.set(listIndex, { [info.pattern]: ref });\r\n    } else {\r\n      if (typeof (ref = refByInfo[info.pattern]) === \"undefined\") {\r\n        return refByInfo[info.pattern] = new StatePropertyRef(info, listIndex);\r\n      }\r\n    }\r\n  } else {\r\n    if (typeof (ref = refByInfoByNull[info.pattern]) === \"undefined\") {\r\n      return refByInfoByNull[info.pattern] = new StatePropertyRef(info, null);\r\n    }\r\n  }\r\n  return ref;\r\n}\r\n","/**\r\n * getContextListIndex.ts\r\n *\r\n * StateClassの内部APIとして、現在のプロパティ参照スコープにおける\r\n * 指定したstructuredPath（ワイルドカード付きプロパティパス）に対応する\r\n * リストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - handlerの最後にアクセスされたStatePropertyRefから、指定パスに対応するリストインデックスを取得\r\n * - ワイルドカード階層に対応し、多重ループやネストした配列バインディングにも利用可能\r\n *\r\n * 設計ポイント:\r\n * - 直近のプロパティ参照情報を取得\r\n * - info.wildcardPathsからstructuredPathのインデックスを特定\r\n * - listIndex.at(index)で該当階層のリストインデックスを取得\r\n * - パスが一致しない場合や参照が存在しない場合はnullを返す\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function getContextListIndex(\r\n  handler: IStateHandler,\r\n  structuredPath: string\r\n): IListIndex | null {\r\n  const ref = handler.lastRefStack;\r\n  if (ref == null) {\r\n    return null;\r\n  }\r\n  if (ref.info == null) {\r\n    return null;\r\n  }\r\n  if (ref.listIndex == null) {\r\n    return null;\r\n  }\r\n  const index = ref.info.indexByWildcardPath[structuredPath];\r\n  if (typeof index !== \"undefined\") {\r\n    return ref.listIndex.at(index);\r\n  }\r\n  return null;\r\n}\r\n","/**\r\n * getListIndex.ts\r\n *\r\n * StateClassの内部APIとして、パス情報（IResolvedPathInfo）から\r\n * 対応するリストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - パスのワイルドカード種別（context/all/partial/none）に応じてリストインデックスを解決\r\n * - context型は現在のループコンテキストからリストインデックスを取得\r\n * - all型は各階層のリストインデックス集合からインデックスを辿って取得\r\n * - partial型やnone型は未実装またはnullを返す\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループ、ネストした配列バインディングに柔軟に対応\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - エラー時はraiseErrorで詳細な例外を投げる\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IResolvedPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { GetListIndexesByRefSymbol } from \"../symbols\";\r\nimport { IStateHandler, IReadonlyStateProxy, IStateProxy } from \"../types\";\r\nimport { getContextListIndex } from \"./getContextListIndex\";\r\n\r\nexport function getListIndex(\r\n  resolvedPath: IResolvedPathInfo, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): IListIndex | null {\r\n  switch (resolvedPath.wildcardType) {\r\n    case \"none\":\r\n      return null;\r\n    case \"context\":\r\n      const lastWildcardPath = resolvedPath.info.lastWildcardPath ?? \r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'lastWildcardPath is null',\r\n          context: { where: 'getListIndex', pattern: resolvedPath.info.pattern },\r\n          docsUrl: '/docs/error-codes.md#state',\r\n        });\r\n      return getContextListIndex(handler, lastWildcardPath) ?? \r\n        raiseError({\r\n          code: 'LIST-201',\r\n          message: `ListIndex not found: ${resolvedPath.info.pattern}`,\r\n          context: { where: 'getListIndex', pattern: resolvedPath.info.pattern },\r\n          docsUrl: '/docs/error-codes.md#list',\r\n        });\r\n    case \"all\":\r\n      let parentListIndex: IListIndex | null = null;\r\n      for(let i = 0; i < resolvedPath.info.wildcardCount; i++) {\r\n        const wildcardParentPattern = resolvedPath.info.wildcardParentInfos[i] ?? \r\n          raiseError({\r\n            code: 'STATE-202',\r\n            message: 'wildcardParentPattern is null',\r\n            context: { where: 'getListIndex', pattern: resolvedPath.info.pattern, index: i },\r\n            docsUrl: '/docs/error-codes.md#state',\r\n          });\r\n        const wildcardRef = getStatePropertyRef(wildcardParentPattern, parentListIndex);\r\n        const listIndexes: IListIndex[] = receiver[GetListIndexesByRefSymbol](wildcardRef) ?? \r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { where: 'getListIndex', wildcardParent: wildcardParentPattern.pattern },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n          });\r\n        const wildcardIndex = resolvedPath.wildcardIndexes[i] ?? \r\n          raiseError({\r\n            code: 'STATE-202',\r\n            message: 'wildcardIndex is null',\r\n            context: { where: 'getListIndex', pattern: resolvedPath.info.pattern, index: i },\r\n            docsUrl: '/docs/error-codes.md#state',\r\n          });\r\n        parentListIndex = listIndexes[wildcardIndex] ?? \r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { where: 'getListIndex', wildcardParent: wildcardParentPattern.pattern, wildcardIndex },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n          });\r\n      }\r\n      return parentListIndex;\r\n    case \"partial\":\r\n      raiseError({\r\n        code: 'STATE-202',\r\n        message: `Partial wildcard type is not supported yet: ${resolvedPath.info.pattern}`,\r\n        context: { where: 'getListIndex', pattern: resolvedPath.info.pattern },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n      });\r\n  }\r\n}\r\n","import { MAX_WILDCARD_DEPTH } from \"../../constants\";\r\n\r\n/**\r\n * stackIndexByIndexName\r\n * インデックス名からスタックインデックスへのマッピング\r\n * $1 => 0\r\n * $2 => 1\r\n * :\r\n * ${i + 1} => i\r\n * i < MAX_WILDCARD_DEPTH\r\n */\r\nexport const indexByIndexName: { [key: PropertyKey]: number } = {};\r\nfor (let i = 0; i < MAX_WILDCARD_DEPTH; i++) {\r\n  indexByIndexName[`$${i+1}`] = i;\r\n}\r\n","import { IListIndex } from \"./types\";\r\n\r\n\r\nlet version = 0;\r\nlet id = 0;\r\nclass ListIndex implements IListIndex {\r\n  #parentListIndex: IListIndex | null = null;\r\n  #pos: number = 0;\r\n  #index: number = 0;\r\n  #version: number;\r\n  #id = ++id;\r\n  #sid = this.#id.toString();\r\n  constructor(parentListIndex: IListIndex | null, index: number) {\r\n    this.#parentListIndex = parentListIndex;\r\n    this.#pos = parentListIndex ? parentListIndex.position + 1 : 0;\r\n    this.#index = index;\r\n    this.#version = version;\r\n  }\r\n\r\n  get parentListIndex() {\r\n    return this.#parentListIndex;\r\n  }\r\n\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n\r\n  get sid() {\r\n    return this.#sid;\r\n  }\r\n\r\n  get position() {\r\n    return this.#pos;\r\n  }\r\n\r\n  get length() {\r\n    return this.#pos + 1;\r\n  }\r\n\r\n  get index() {\r\n    return this.#index;\r\n  }\r\n  set index(value: number) {\r\n    this.#index = value;\r\n    this.#version = ++version;\r\n    this.indexes[this.#pos] = value;\r\n  }\r\n\r\n  get version(): number {\r\n    return this.#version;\r\n  }\r\n\r\n  get dirty(): boolean {\r\n    if (this.#parentListIndex === null) {\r\n      return false;\r\n    } else {\r\n      return this.#parentListIndex.dirty || this.#parentListIndex.version > this.#version;\r\n    }\r\n  }\r\n\r\n  #indexes: number[] | undefined;\r\n  get indexes(): number[] {\r\n    if (this.#parentListIndex === null) {\r\n      if (typeof this.#indexes === \"undefined\") {\r\n        this.#indexes = [this.#index];\r\n      }\r\n    } else {\r\n      if (typeof this.#indexes === \"undefined\" || this.dirty) {\r\n        this.#indexes = [...this.#parentListIndex.indexes, this.#index];\r\n        this.#version = version;\r\n      }\r\n    }\r\n    return this.#indexes;\r\n  }\r\n\r\n  #listIndexes: WeakRef<IListIndex>[] | undefined;\r\n  get listIndexes(): WeakRef<IListIndex>[] {\r\n    if (this.#parentListIndex === null) {\r\n      if (typeof this.#listIndexes === \"undefined\") {\r\n        this.#listIndexes = [new WeakRef(this)];\r\n      }\r\n    } else {\r\n      if (typeof this.#listIndexes === \"undefined\") {\r\n        this.#listIndexes = [...this.#parentListIndex.listIndexes, new WeakRef(this)];\r\n      }\r\n    }\r\n    return this.#listIndexes;\r\n  }\r\n\r\n  get varName(): string {\r\n    return `${this.position + 1}`;\r\n  }\r\n\r\n  at(pos: number): IListIndex | null {\r\n    if (pos >= 0) {\r\n      return this.listIndexes[pos]?.deref() || null;\r\n    } else {\r\n      return this.listIndexes[this.listIndexes.length + pos]?.deref() || null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function createListIndex(parentListIndex: IListIndex | null, index: number): IListIndex {\r\n  return new ListIndex(parentListIndex, index);\r\n}\r\n","/**\r\n * getByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）から値を取得するための関数（getByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を取得（多重ループやワイルドカードにも対応）\r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyで値をキャッシュ）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を取得\r\n *\r\n * 設計ポイント:\r\n * - handler.engine.trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n * - キャッシュ有効時はrefKeyで値をキャッシュし、取得・再利用を最適化\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値取得を実現\r\n * - finallyでキャッシュへの格納を保証\r\n */\r\nimport { ICacheEntry } from \"../../ComponentEngine/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\nimport { checkDependency } from \"./checkDependency\";\r\nimport { createListIndexes } from \"./createListIndexes\";\r\n\r\n/**\r\n * 構造化パス情報(info, listIndex)をもとに、状態オブジェクト(target)から値を取得する。\r\n * \r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyでキャッシュ）\r\n * - ネスト・ワイルドカード対応（親infoやlistIndexを辿って再帰的に値を取得）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * \r\n * @param target    状態オブジェクト\r\n * @param info      構造化パス情報\r\n * @param listIndex リストインデックス（多重ループ対応）\r\n * @param receiver  プロキシ\r\n * @param handler   状態ハンドラ\r\n * @returns         対象プロパティの値\r\n */\r\nexport function getByRef(\r\n  target   : Object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IStateProxy,\r\n  handler  : IStateHandler\r\n): any {\r\n  checkDependency(handler, ref);\r\n\r\n  let value: any;\r\n  const listable = handler.engine.pathManager.lists.has(ref.info.pattern);\r\n  const cacheable = ref.info.wildcardCount > 0 || \r\n                    handler.engine.pathManager.getters.has(ref.info.pattern);\r\n  let lastCacheEntry = null;\r\n  if (cacheable || listable) {\r\n    lastCacheEntry = handler.engine.getCacheEntry(ref);\r\n    const versionRevision = handler.engine.versionRevisionByPath.get(ref.info.pattern);\r\n    if (lastCacheEntry !== null) {\r\n      if (typeof versionRevision === \"undefined\") {\r\n        // 更新なし\r\n        return lastCacheEntry.value;\r\n      } else {\r\n        if (lastCacheEntry.version > handler.updater.version) {\r\n          // これは非同期更新が発生した場合にありえる\r\n          return lastCacheEntry.value;\r\n        }\r\n        if (lastCacheEntry.version < versionRevision.version || lastCacheEntry.revision < versionRevision.revision) {\r\n          // 更新あり\r\n        } else {\r\n          return lastCacheEntry.value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 親子関係のあるgetterが存在する場合は、外部依存から取得\r\n  // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n  if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n    return handler.engine.stateOutput.get(ref);\r\n  }\r\n\r\n  // パターンがtargetに存在する場合はgetter経由で取得\r\n  if (ref.info.pattern in target) {\r\n    if (handler.refStack.length === 0) {\r\n      raiseError({\r\n        code: 'STC-002',\r\n        message: 'handler.refStack is empty in getByRef',\r\n      });\r\n    }\r\n    handler.refIndex++;\r\n    if (handler.refIndex >= handler.refStack.length) {\r\n      handler.refStack.push(null);\r\n    }\r\n    handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n    try {\r\n      return value = Reflect.get(target, ref.info.pattern, receiver);\r\n    } finally {\r\n      handler.refStack[handler.refIndex] = null;\r\n      handler.refIndex--;\r\n      handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      // キャッシュへ格納\r\n      if (cacheable || listable) {\r\n        let newListIndexes = null;\r\n        if (listable) {\r\n          // リストインデックスを計算する必要がある\r\n          if (handler.renderer !== null) {\r\n            if (!handler.renderer.lastListInfoByRef.has(ref)) {\r\n              const listInfo = {\r\n                listIndexes: lastCacheEntry?.listIndexes ?? [],\r\n                value: lastCacheEntry?.value,\r\n              };\r\n              handler.renderer.lastListInfoByRef.set(ref, listInfo);\r\n            }\r\n          }\r\n          newListIndexes = createListIndexes(ref.listIndex, lastCacheEntry?.value, value, lastCacheEntry?.listIndexes ?? []);\r\n        }\r\n        let cacheEntry: ICacheEntry = lastCacheEntry ?? {\r\n          value: null,\r\n          listIndexes: null,\r\n          version: 0,\r\n          revision: 0,\r\n        };\r\n        cacheEntry.value = value;\r\n        cacheEntry.listIndexes = newListIndexes;\r\n        cacheEntry.version = handler.updater.version;\r\n        cacheEntry.revision = handler.updater.revision;\r\n        handler.engine.setCacheEntry(ref, cacheEntry);\r\n      }\r\n    }\r\n  } else {\r\n    // 存在しない場合エラー\r\n    raiseError({\r\n      code: \"STC-001\",\r\n      message: `Property \"${ref.info.pattern}\" does not exist in state.`,\r\n      docsUrl: \"./docs/error-codes.md#stc\",\r\n    })\r\n  }\r\n}\r\n","import { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function checkDependency(\r\n  handler: IStateHandler,\r\n  ref: IStatePropertyRef,\r\n): void {\r\n  // 動的依存関係の登録\r\n  if (handler.refIndex >= 0) {\r\n    const lastInfo = handler.lastRefStack?.info ?? null;\r\n    if (lastInfo !== null) {\r\n      if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern) &&\r\n        lastInfo.pattern !== ref.info.pattern) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, ref.info.pattern);\r\n      }\r\n    }\r\n  }\r\n}","import { createListIndex } from \"../../ListIndex/ListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\n\r\nfunction isSameList(oldList: any[], newList: any[]): boolean {\r\n  if (oldList.length !== newList.length) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < oldList.length; i++) {\r\n    if (oldList[i] !== newList[i]) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function createListIndexes(\r\n  parentListIndex: IListIndex | null,\r\n  oldList: any,\r\n  newList: any,\r\n  oldIndexes: IListIndex[]\r\n): IListIndex[] {\r\n  oldList = Array.isArray(oldList) ? oldList : [];\r\n  newList = Array.isArray(newList) ? newList : [];\r\n  const newIndexes: IListIndex[] = [];\r\n  if (newList.length === 0) {\r\n    return [];\r\n  }\r\n  if (oldList.length === 0) {\r\n    for(let i = 0; i < newList.length; i++) {\r\n      const newListIndex = createListIndex(parentListIndex, i);\r\n      newIndexes.push(newListIndex);\r\n    }\r\n    return newIndexes;\r\n  }\r\n  if (isSameList(oldList, newList)) {\r\n    return oldIndexes;\r\n  }\r\n  // インデックスベースのマップを使用して効率化\r\n  const indexByValue = new Map<any, number>();\r\n  for(let i = 0; i < oldList.length; i++) {\r\n    // 重複値の場合は最後のインデックスが優先される（既存動作を維持）\r\n    indexByValue.set(oldList[i], i);\r\n  }\r\n\r\n  for(let i = 0; i < newList.length; i++) {\r\n    const newValue = newList[i];\r\n    const oldIndex = indexByValue.get(newValue);\r\n    \r\n    if (typeof oldIndex === \"undefined\") {\r\n      // 新しい要素\r\n      const newListIndex = createListIndex(parentListIndex, i);\r\n      newIndexes.push(newListIndex);\r\n    } else {\r\n      // 既存要素の再利用\r\n      const existingListIndex = oldIndexes[oldIndex];\r\n      if (existingListIndex.index !== i) {\r\n        existingListIndex.index = i;\r\n      }\r\n      newIndexes.push(existingListIndex);\r\n    }\r\n  }\r\n  return newIndexes;\r\n\r\n}","/**\r\n * setByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）に値を設定するための関数（setByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を設定（多重ループやワイルドカードにも対応）\r\n * - getter/setter経由で値設定時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を設定\r\n * - 設定後はengine.updater.addUpdatedStatePropertyRefValueで更新情報を登録\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値設定を実現\r\n * - finallyで必ず更新情報を登録し、再描画や依存解決に利用\r\n * - getter/setter経由のスコープ切り替えも考慮した設計\r\n */\r\nimport { createListIndex } from \"../../ListIndex/ListIndex\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IListInfo } from \"../../Updater/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { GetByRefSymbol, GetListIndexesByRefSymbol } from \"../symbols\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\nimport { getByRef } from \"./getByRef\";\r\n\r\nexport function setByRef(\r\n    target   : Object, \r\n    ref      : IStatePropertyRef,\r\n    value    : any, \r\n    receiver : IStateProxy,\r\n    handler  : IStateHandler\r\n): any {\r\n  const isElements = handler.engine.pathManager.elements.has(ref.info.pattern);\r\n  let parentRef: IStatePropertyRef | null = null;\r\n  let swapInfo: IListInfo | null = null;\r\n  // elementsの場合はswapInfoを準備\r\n  if (isElements) {\r\n    parentRef = ref.parentRef ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'propRef.stateProp.parentInfo is undefined',\r\n      context: { where: 'setByRef (element)', refPath: ref.info.pattern },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n    swapInfo = handler.updater.swapInfoByRef.get(parentRef) || null;\r\n    if (swapInfo === null) {\r\n      swapInfo = {\r\n        value: [...(receiver[GetByRefSymbol](parentRef) ?? [])],\r\n        listIndexes: [...(receiver[GetListIndexesByRefSymbol](parentRef) ?? [])]\r\n      }\r\n      handler.updater.swapInfoByRef.set(parentRef, swapInfo);\r\n    }\r\n  }\r\n  try {\r\n    // 親子関係のあるgetterが存在する場合は、外部依存を通じて値を設定\r\n    // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n    if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.setters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n      return handler.engine.stateOutput.set(ref, value);\r\n    }\r\n    if (ref.info.pattern in target) {\r\n      handler.refIndex++;\r\n      if (handler.refIndex >= handler.refStack.length) {\r\n        handler.refStack.push(null);\r\n      }\r\n      handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n      try {\r\n        return Reflect.set(target, ref.info.pattern, value, receiver);\r\n      } finally {\r\n        handler.refStack[handler.refIndex] = null;\r\n        handler.refIndex--;\r\n        handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      }\r\n    } else {\r\n      const parentInfo = ref.info.parentInfo ?? raiseError({\r\n        code: 'STATE-202',\r\n        message: 'propRef.stateProp.parentInfo is undefined',\r\n        context: { where: 'setByRef', refPath: ref.info.pattern },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n      });\r\n      const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount ? (ref.listIndex?.parentListIndex ?? null) : ref.listIndex;\r\n      const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n      const parentValue = getByRef(target, parentRef, receiver, handler);\r\n      const lastSegment = ref.info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        const index = ref.listIndex?.index ?? raiseError({\r\n          code: 'STATE-202',\r\n          message: 'propRef.listIndex?.index is undefined',\r\n          context: { where: 'setByRef', refPath: ref.info.pattern },\r\n          docsUrl: '/docs/error-codes.md#state',\r\n        });\r\n        return Reflect.set(parentValue, index, value);\r\n      } else {\r\n        return Reflect.set(parentValue, lastSegment, value);\r\n      }\r\n    }\r\n  } finally {\r\n    handler.updater.enqueueRef(ref);\r\n    if (isElements) {\r\n      const index = swapInfo!.value.indexOf(value);\r\n      const currentListIndexes = receiver[GetListIndexesByRefSymbol](parentRef!) ?? [];\r\n      const curIndex = ref.listIndex!.index; \r\n      const listIndex = (index !== -1) ? swapInfo!.listIndexes[index] : createListIndex(parentRef!.listIndex, -1);\r\n      currentListIndexes[curIndex] = listIndex;\r\n      // 重複チェック\r\n      // 重複していない場合、swapが完了したとみなし、インデックスを更新\r\n      const listValueSet = new Set(receiver[GetByRefSymbol](parentRef!) ?? []);\r\n      if (listValueSet.size === swapInfo!.value.length) {\r\n        for(let i = 0; i < currentListIndexes.length; i++) {\r\n          currentListIndexes[i].index = i;\r\n        }\r\n        // 完了したのでswapInfoを削除\r\n        handler.updater.swapInfoByRef.delete(parentRef!);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * resolve.ts\r\n *\r\n * StateClassのAPIとして、パス（path）とインデックス（indexes）を指定して\r\n * Stateの値を取得・設定するための関数（resolve）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列パス（path）とインデックス配列（indexes）から、該当するState値の取得・設定を行う\r\n * - ワイルドカードや多重ループを含むパスにも対応\r\n * - value未指定時は取得（getByRef）、指定時は設定（setByRef）を実行\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパスを解析し、ワイルドカード階層ごとにリストインデックスを解決\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - getByRef/setByRefで値の取得・設定を一元的に処理\r\n * - 柔軟なバインディングやAPI経由での利用が可能\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { GetListIndexesByRefSymbol, SetByRefSymbol } from \"../symbols.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\n\r\nexport function resolve(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): Function {\r\n  return (path: string, indexes: number[], value?: any): any => {\r\n    const info = getStructuredPathInfo(path);\r\n    const lastInfo = handler.lastRefStack?.info ?? null;\r\n    if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n      // gettersに含まれる場合は依存関係を登録\r\n      if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern)) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n      }\r\n    }\r\n\r\n    if (info.wildcardParentInfos.length > indexes.length) {\r\n      raiseError({\r\n        code: 'STATE-202',\r\n        message: `indexes length is insufficient: ${path}`,\r\n        context: { path, expected: info.wildcardParentInfos.length, received: indexes.length },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    // ワイルドカード階層ごとにListIndexを解決していく\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i];\r\n      const wildcardRef = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n      const tmpValue = getByRef(target, wildcardRef, receiver, handler);\r\n      const listIndexes = receiver[GetListIndexesByRefSymbol](wildcardRef);\r\n      if (listIndexes == null) {\r\n        raiseError({\r\n          code: 'LIST-201',\r\n          message: `ListIndexes not found: ${wildcardParentPattern.pattern}`,\r\n          context: { pattern: wildcardParentPattern.pattern },\r\n          docsUrl: '/docs/error-codes.md#list',\r\n          severity: 'error',\r\n        });\r\n      }\r\n      const index = indexes[i];\r\n      listIndex = listIndexes[index] ?? raiseError({\r\n        code: 'LIST-201',\r\n        message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n        context: { pattern: wildcardParentPattern.pattern, index },\r\n        docsUrl: '/docs/error-codes.md#list',\r\n        severity: 'error',\r\n      });\r\n    }\r\n\r\n    // WritableかReadonlyかを判定して適切なメソッドを呼び出す\r\n    const ref = getStatePropertyRef(info, listIndex);\r\n    const hasSetValue = typeof value !== \"undefined\";\r\n    if (SetByRefSymbol in receiver) {\r\n      if (!hasSetValue) {\r\n        return getByRef(target, ref, receiver, handler);\r\n      } else {\r\n        setByRef(target, ref, value, receiver, handler);\r\n      }\r\n    } else {\r\n      if (!hasSetValue) {\r\n        return getByRef(target, ref, receiver, handler);\r\n      } else {\r\n        // readonlyなので、setはできない\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: `Cannot set value on a readonly proxy: ${path}`,\r\n          context: { path },\r\n          docsUrl: '/docs/error-codes.md#state',\r\n          severity: 'error',\r\n        });\r\n      }\r\n    }\r\n  };\r\n} ","/**\r\n * get.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティアクセス時の値取得処理を担う関数（get）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、特殊プロパティ（$1〜$9, $resolve, $getAll, $navigate）に応じた値やAPIを返却\r\n * - 通常のプロパティはgetResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - getByRefで構造化パス・リストインデックスに対応した値を取得\r\n * - シンボルプロパティの場合はhandler.callableApi経由でAPIを呼び出し\r\n * - それ以外はReflect.getで通常のプロパティアクセスを実行\r\n *\r\n * 設計ポイント:\r\n * - $1〜$9は直近のStatePropertyRefのリストインデックス値を返す特殊プロパティ\r\n * - $resolve, $getAll, $navigateはAPI関数やルーターインスタンスを返す\r\n * - 通常のプロパティアクセスもバインディングや多重ループに対応\r\n * - シンボルAPIやReflect.getで拡張性・互換性も確保\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types.js\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, GetListIndexesByRefSymbol, SetByRefSymbol, UpdatedCallbackSymbol } from \"../symbols.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\nimport { indexByIndexName } from \"./indexByIndexName.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"../apis/resolve.js\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { connectedCallback } from \"../apis/connectedCallback.js\";\r\nimport { disconnectedCallback } from \"../apis/disconnectedCallback.js\";\r\nimport { getAll } from \"../apis/getAll.js\";\r\nimport { getListIndexesByRef } from \"../methods/getListIndexesByRef.js\";\r\nimport { updatedCallback } from \"../apis/updatedCallback.js\";\r\n\r\nexport function get(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler : IStateHandler\r\n): any {\r\n  const index = indexByIndexName[prop];\r\n  if (typeof index !== \"undefined\") {\r\n    const listIndex = handler.lastRefStack?.listIndex;\r\n    return listIndex?.indexes[index] ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: `ListIndex not found: ${prop.toString()}`,\r\n      context: { prop: String(prop), indexes: listIndex?.indexes ?? null, index },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n      severity: 'error',\r\n    });\r\n  }\r\n  if (typeof prop === \"string\") {\r\n    if (prop[0] === \"$\") {\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolve(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAll(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n        case \"$component\":\r\n          return handler.engine.owner;\r\n      }\r\n    }\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return getByRef(\r\n      target, \r\n      ref,\r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    if (handler.symbols.has(prop)) {\r\n      switch (prop) {\r\n        case GetByRefSymbol: \r\n          return (ref: IStatePropertyRef) => \r\n            getByRef(target, ref, receiver, handler);\r\n        case SetByRefSymbol: \r\n          return (ref: IStatePropertyRef, value: any) => \r\n            setByRef(target, ref, value, receiver, handler);\r\n        case GetListIndexesByRefSymbol:\r\n          return (ref: IStatePropertyRef) =>\r\n            getListIndexesByRef(target, ref, receiver, handler);\r\n        case ConnectedCallbackSymbol:\r\n          return () => connectedCallback(target, prop, receiver, handler);\r\n        case DisconnectedCallbackSymbol: \r\n          return () => disconnectedCallback(target, prop, receiver, handler);\r\n        case UpdatedCallbackSymbol:\r\n          return (refs: IStatePropertyRef[]) =>\r\n            updatedCallback(target, refs, receiver, handler);\r\n      }\r\n    } else {\r\n      return Reflect.get(\r\n        target, \r\n        prop, \r\n        receiver\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * getAllReadonly\r\n *\r\n * ワイルドカードを含む State パスから、対象となる全要素を配列で取得する。\r\n * Throws: LIST-201（インデックス未解決）、BIND-201（ワイルドカード情報不整合）\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"./resolve.js\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\nimport { GetListIndexesByRefSymbol } from \"../symbols.js\";\r\n\r\nexport function getAll(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n    const resolveFn = resolve(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      const lastInfo = handler.lastRefStack?.info ?? null;\r\n      if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n        // gettersに含まれる場合は依存関係を登録\r\n        if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern)) {\r\n          handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError({\r\n            code: 'BIND-201',\r\n            message: 'wildcardPattern is null',\r\n            context: { index: i, infoPattern: info.pattern },\r\n            docsUrl: '/docs/error-codes.md#bind',\r\n            severity: 'error',\r\n          });\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const wildcardRef = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n        const tmpValue = getByRef(target, wildcardRef, receiver, handler);\r\n        const listIndexes = receiver[GetListIndexesByRefSymbol](wildcardRef);\r\n        if (listIndexes === null) {\r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { pattern: wildcardParentPattern.pattern },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n            severity: 'error',\r\n          });\r\n        }\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { pattern: wildcardParentPattern.pattern, index },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n            severity: 'error',\r\n          });\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          } else {\r\n            // 最終ワイルドカード層まで到達しているので、結果を確定\r\n            results.push(parentIndexes.concat(listIndex.index));\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolveFn(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * trackDependency.ts\r\n *\r\n * StateClassのAPIとして、getterチェーン中に参照されたパス間の\r\n * 依存関係を動的に登録するための関数（trackDependency）の実装です。\r\n *\r\n * 主な役割:\r\n * - 現在解決中のStatePropertyRef（lastRefStack）を取得\r\n * - pathManager.gettersに登録されているgetterの場合のみ依存を追跡\r\n * - 自身と同一パターンでない参照に対してaddDynamicDependencyを呼び出す\r\n *\r\n * 設計ポイント:\r\n * - lastRefStackが存在しない場合はSTATE-202エラーを発生させる\r\n * - getter同士の再帰（自己依存）は登録しない\r\n * - 動的依存はpathManagerに集約し、キャッシュの無効化に利用する\r\n */\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\n/**\r\n * 現在解決中のgetterから、指定されたパスへの動的依存を登録する関数を返します。\r\n *\r\n * - pathManager.gettersに登録されているgetterのみ依存追跡を行う\r\n * - 自己参照は除外し、異なるパターン間の依存だけを記録\r\n * - 動的依存はpathManager.addDynamicDependencyで集中管理される\r\n *\r\n * @param target   プロキシ対象オブジェクト\r\n * @param prop     アクセスされたプロパティキー\r\n * @param receiver プロキシレシーバ\r\n * @param handler  StateClassハンドラ\r\n * @returns        引数pathで指定されたパターンへの依存を登録する無名関数\r\n */\r\nexport function trackDependency(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): Function {\r\n  return (path: string): void => {\r\n    const lastInfo = handler.lastRefStack?.info ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'Internal error: lastRefStack is null',\r\n      context: { where: 'trackDependency', path },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n    if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n      lastInfo.pattern !== path) {\r\n      handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, path);\r\n    }\r\n  };\r\n}\r\n","/**\r\n * Router.ts\r\n *\r\n * シングルページアプリケーション（SPA）向けのカスタムエレメント Router の実装です。\r\n *\r\n * 主な役割:\r\n * - ルート定義（entryRoute）に基づき、URLパスに応じてカスタム要素を動的に生成・表示\r\n * - pushState/popstateイベントを利用した履歴管理とルーティング制御\r\n * - ルートパラメータの抽出とカスタム要素への受け渡し\r\n * - 404ページ（未定義ルート時）の表示\r\n *\r\n * 設計ポイント:\r\n * - entryRouteでルートパスとカスタム要素タグ名のペアを登録\r\n * - popstateイベントでURL変更時に自動で再描画\r\n * - ルートパスのパラメータ（:id等）も正規表現で抽出し、data-state属性で渡す\r\n * - getRouterでグローバルなRouterインスタンスを取得可能\r\n */\r\nimport { isLazyLoadComponent, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap\";\r\nimport { IRouter } from \"./types\";\r\n\r\nconst DEFAULT_ROUTE_PATH = '/'; // Default route path\r\nconst ROUTE_PATH_PREFIX = 'routes:'; // Prefix for route paths\r\n/**\r\n * example:\r\n * ```ts\r\n * entryRoute('my-view', '/my-view/:id');\r\n */\r\nconst routeEntries: Array<[string, string]> = [];\r\n\r\nlet globalRouter : Router | null = null;\r\n\r\nexport class Router extends HTMLElement implements IRouter {\r\n  originalPathName = window.location.pathname; // Store the original path name\r\n  originalFileName = window.location.pathname.split('/').pop() || ''; // Store the original file name\r\n  basePath = document.querySelector('base')?.href.replace(window.location.origin, \"\") || DEFAULT_ROUTE_PATH;\r\n\r\n  _popstateHandler: (event: PopStateEvent) => void;\r\n  constructor() {\r\n    super();\r\n    this._popstateHandler = this.popstateHandler.bind(this);\r\n  }\r\n\r\n  connectedCallback() {\r\n    globalRouter = this;\r\n    this.innerHTML = '<slot name=\"content\"></slot>';\r\n    window.addEventListener('popstate', this._popstateHandler);\r\n    window.dispatchEvent(new Event(\"popstate\")); // Dispatch popstate event to trigger the initial render\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    window.removeEventListener('popstate', this._popstateHandler);\r\n    globalRouter = null;\r\n  }\r\n\r\n  popstateHandler(event: PopStateEvent) {\r\n    event.preventDefault();\r\n    this.render();\r\n  }\r\n\r\n  navigate(to: string) {\r\n    const toPath = to[0] === '/' ? (this.basePath + to.slice(1)) : to; // Ensure the path starts with '/'\r\n    history.pushState({}, '', toPath);\r\n    this.render();\r\n  }\r\n\r\n  render() {\r\n    // スロットコンテントをクリア\r\n    const slotChildren = Array.from(this.childNodes).filter(\r\n      n => (n as HTMLElement).getAttribute?.('slot') === 'content'\r\n    );\r\n    slotChildren.forEach(n => this.removeChild(n));\r\n\r\n    const paths = window.location.pathname.split('/');\r\n    if (paths.at(-1) === this.originalFileName) {\r\n      paths[paths.length - 1] = ''; // Ensure the last path is empty for root\r\n    }\r\n    const pathName = paths.join('/');\r\n    const replacedPath = pathName.replace(this.basePath, ''); // Remove base path and ensure default route\r\n    const currentPath = replacedPath[0] !== '/' ? '/' + replacedPath : replacedPath; // Ensure the path starts with '/'\r\n    let tagName: string | undefined = undefined;\r\n    let params: Record<string, string> = {};\r\n    // Check if the routePath matches any of the defined routes\r\n    for (const [path, tag] of routeEntries) {\r\n      const regex = new RegExp(\"^\" + path.replace(/:[^\\s/]+/g, '([^/]+)') + \"$\");\r\n      if (regex.test(currentPath)) {\r\n        tagName = tag;\r\n        // Extract the parameters from the routePath\r\n        const matches = currentPath.match(regex);\r\n        if (matches) {\r\n          const keys = path.match(/:[^\\s/]+/g) || [];\r\n          keys.forEach((key, index) => {\r\n            params[key.substring(1)] = matches[index + 1]; // +1 to skip the full match\r\n          });\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (tagName) {\r\n      // If a route matches, create the custom element and set its state\r\n      // Create the custom element with the tag name\r\n      // project the custom element into the router slot\r\n      const customElement = document.createElement(tagName) as HTMLElement;\r\n      customElement.setAttribute('data-state', JSON.stringify(params));\r\n      customElement.setAttribute('slot', 'content');\r\n      this.appendChild(customElement);\r\n      if (isLazyLoadComponent(tagName)) {\r\n        loadLazyLoadComponent(tagName); // Load lazy load component if necessary\r\n      }\r\n    } else {\r\n      // If no route matches, show 404 content\r\n      const messageElement = document.createElement('h1') as HTMLElement;\r\n      messageElement.setAttribute('slot', 'content');\r\n      messageElement.textContent = '404 Not Found';\r\n      this.appendChild(messageElement);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function entryRoute(tagName: string, routePath: string): void {\r\n  if (routePath.startsWith(ROUTE_PATH_PREFIX)) {\r\n    routePath = routePath.substring(ROUTE_PATH_PREFIX.length); // Remove 'routes:' prefix\r\n  }\r\n  routeEntries.push([routePath, tagName]);\r\n}\r\n\r\nexport function getRouter(): Router | null {\r\n  return globalRouter;\r\n}\r\n\r\n","import { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { get } from \"../traps/get\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { getByRef } from \"./getByRef\";\r\n\r\nexport function getListIndexesByRef(\r\n  target   : Object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IStateProxy,\r\n  handler  : IStateHandler\r\n \r\n): IListIndex[] {\r\n  if (!handler.engine.pathManager.lists.has(ref.info.pattern)) {\r\n    raiseError({\r\n      code: 'LIST-201',\r\n      message: `path is not a list: ${ref.info.pattern}`,\r\n      context: { where: 'getListIndexesByRef', pattern: ref.info.pattern },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n  if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n    return handler.engine.stateOutput.getListIndexes(ref) ?? [];\r\n  }\r\n\r\n  getByRef(target, ref, receiver, handler); // キャッシュ更新を兼ねる\r\n  const cacheEntry = handler.engine.getCacheEntry(ref);\r\n  if (cacheEntry === null) {\r\n    raiseError({\r\n      code: 'LIST-202',\r\n      message: `List cache entry not found: ${ref.info.pattern}`,\r\n      context: { where: 'getListIndexesByRef', pattern: ref.info.pattern },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  const listIndexes = cacheEntry.listIndexes;\r\n  if (listIndexes == null) {\r\n    raiseError({\r\n      code: 'LIST-203',\r\n      message: `List indexes not found in cache entry: ${ref.info.pattern}`,\r\n      context: { where: 'getListIndexesByRef', pattern: ref.info.pattern },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  return listIndexes;\r\n}","/**\r\n * connectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$connectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$connectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$connectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やカスタム初期化処理に利用\r\n */\r\nimport { CONNECTED_CALLBACK_FUNC_NAME } from \"../../constants\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nexport function connectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Promise<void> | void {\r\n  const callback = Reflect.get(target, CONNECTED_CALLBACK_FUNC_NAME);\r\n  if (typeof callback === \"function\") {\r\n    return callback.call(receiver);\r\n  }\r\n}","/**\r\n * disconnectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$disconnectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$disconnectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$disconnectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やクリーンアップ処理に利用\r\n */\r\nimport { DISCONNECTED_CALLBACK_FUNC_NAME } from \"../../constants\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nexport function disconnectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): void {\r\n  const callback = Reflect.get(target, DISCONNECTED_CALLBACK_FUNC_NAME);\r\n  if (typeof callback === \"function\") {\r\n    callback.call(receiver);\r\n  }\r\n}","/**\r\n * updatedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$updatedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$updatedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$disconnectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やクリーンアップ処理に利用\r\n */\r\nimport { UPDATED_CALLBACK_FUNC_NAME } from \"../../constants\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nexport function updatedCallback(\r\n  target: Object, \r\n  refs: IStatePropertyRef[], \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler,\r\n):Promise<void> | void {\r\n  const callback = Reflect.get(target, UPDATED_CALLBACK_FUNC_NAME);\r\n  if (typeof callback === \"function\") {\r\n    const paths: Set<string> = new Set();\r\n    const indexesByPath: Record<string, number[]> = {};\r\n    for (const ref of refs) {\r\n      const path = ref.info.pattern;\r\n      paths.add(path);\r\n      if (ref.info.wildcardCount > 0) {\r\n        const index = ref.listIndex!.index;\r\n        let indexes = indexesByPath[path];\r\n        if (typeof indexes === \"undefined\") {\r\n          indexesByPath[path] = [index];\r\n        } else {\r\n          indexes.push(index);\r\n        }\r\n      }\r\n    }\r\n    return callback.call(receiver, Array.from(paths), indexesByPath);\r\n  }\r\n}","/**\r\n * createReadonlyStateProxy.ts\r\n *\r\n * StateClass の「読み取り専用」プロキシを生成します。\r\n *\r\n * 主な役割:\r\n * - State オブジェクトに対する読み取り専用の Proxy を作成\r\n * - get トラップでバインディング/API呼び出し/依存解決/レンダラー連携に対応\r\n * - set トラップは常に例外を投げて書き込みを禁止\r\n * - has トラップで内部APIシンボル（GetByRefSymbol 等）を公開\r\n *\r\n * Throws:\r\n * - STATE-202 Cannot set property ... of readonly state（set トラップ）\r\n */\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateHandler, IState, IReadonlyStateProxy } from \"./types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IRenderer, IUpdater } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { GetByRefSymbol, GetListIndexesByRefSymbol } from \"./symbols\";\r\nimport { get as trapGet } from \"./traps/get.js\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IReadonlyStateHandler {\r\n  engine: IComponentEngine;\r\n  updater: IUpdater;\r\n  renderer: IRenderer | null;\r\n  refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  lastRefStack: IStatePropertyRef | null = null;\r\n  loopContext: ILoopContext | null = null;\r\n  symbols: Set<PropertyKey> = new Set<PropertyKey>([ GetByRefSymbol, GetListIndexesByRefSymbol ]);\r\n  apis: Set<PropertyKey> = new Set<PropertyKey>([ \"$resolve\", \"$getAll\", \"$trackDependency\", \"$navigate\", \"$component\" ]);\r\n\r\n  constructor(engine: IComponentEngine, updater: IUpdater, renderer: IRenderer | null) {\r\n    this.engine = engine;\r\n    this.updater = updater;\r\n    this.renderer = renderer;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IReadonlyStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IReadonlyStateProxy\r\n  ): boolean {\r\n    raiseError({\r\n      code: 'STATE-202',\r\n      message: `Cannot set property ${String(prop)} of readonly state`,\r\n      context: { where: 'createReadonlyStateProxy.set', prop: String(prop) },\r\n  docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  has(\r\n    target: Object, \r\n    prop  : PropertyKey\r\n  ): boolean {\r\n    return Reflect.has(target, prop) || this.symbols.has(prop) || this.apis.has(prop);\r\n  }\r\n}\r\n\r\nexport function createReadonlyStateHandler(engine: IComponentEngine, updater: IUpdater, renderer: IRenderer | null): IReadonlyStateHandler {\r\n  return new StateHandler(engine, updater, renderer);\r\n}\r\n\r\nexport function createReadonlyStateProxy(\r\n  state: Object,\r\n  handler: IReadonlyStateHandler,\r\n): IReadonlyStateProxy {\r\n  return new Proxy<IState>(state, handler) as IReadonlyStateProxy;\r\n}\r\n","/**\r\n * createWritableStateProxy.ts\r\n *\r\n * StateClassの「書き込み可能」プロキシを生成するための実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - Stateオブジェクトに対して、書き込み可能なProxyを作成\r\n * - StateHandlerクラスで各種APIやトラップ（get/set）を実装\r\n * - getトラップでバインディングやAPI呼び出し、依存解決などに対応\r\n * - setトラップで値の書き込みや副作用（依存解決・再描画）を一元管理\r\n *\r\n * 設計ポイント:\r\n * - StateHandlerはIWritableStateHandlerを実装し、状態管理やAPI呼び出しの基盤となる\r\n * - callableApiに各種APIシンボルと関数をマッピングし、柔軟なAPI拡張が可能\r\n * - createWritableStateProxyで一貫した生成・利用が可能\r\n * - 依存解決やキャッシュ、ループ・プロパティ参照スコープ管理など多機能な設計\r\n */\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IState, IWritableStateHandler, IWritableStateProxy } from \"./types\";\r\nimport { set as trapSet } from \"./traps/set.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { setLoopContext } from \"./methods/setLoopContext\";\r\nimport { IRenderer, IUpdater } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, GetListIndexesByRefSymbol, SetByRefSymbol, UpdatedCallbackSymbol } from \"./symbols\";\r\nimport { get as trapGet } from \"./traps/get.js\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IWritableStateHandler {\r\n  engine: IComponentEngine;\r\n  refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  lastRefStack: IStatePropertyRef | null = null;\r\n  loopContext: ILoopContext | null = null;\r\n  updater: IUpdater;\r\n  renderer: IRenderer | null = null;\r\n  symbols: Set<PropertyKey> = new Set<PropertyKey>([ \r\n    GetByRefSymbol, SetByRefSymbol, GetListIndexesByRefSymbol, \r\n    ConnectedCallbackSymbol, DisconnectedCallbackSymbol,\r\n    UpdatedCallbackSymbol\r\n  ]);\r\n  apis: Set<PropertyKey> = new Set<PropertyKey>([ \"$resolve\", \"$getAll\", \"$trackDependency\", \"$navigate\", \"$component\" ]);\r\n  \r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this.engine = engine;\r\n    this.updater = updater;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IWritableStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IWritableStateProxy\r\n  ): boolean {\r\n    return trapSet(target, prop, value, receiver, this);\r\n  }\r\n\r\n  has(\r\n    target: Object, \r\n    prop  : PropertyKey\r\n  ): boolean {\r\n    return Reflect.has(target, prop) || this.symbols.has(prop) || this.apis.has(prop);\r\n  }\r\n}\r\n\r\nexport function useWritableStateProxy<R extends Promise<any> | any>(\r\n  engine: IComponentEngine, \r\n  updater: IUpdater,\r\n  state: Object,\r\n  loopContext: ILoopContext | null,\r\n  callback: (stateProxy: IWritableStateProxy, handler: IWritableStateHandler) => R\r\n): R {\r\n  const handler = new StateHandler(engine, updater);\r\n  const stateProxy = new Proxy<IState>(state, handler) as IWritableStateProxy;\r\n  return setLoopContext<R>(handler, loopContext, () => {\r\n    return callback(stateProxy, handler);\r\n  });\r\n}\r\n\r\n","/**\r\n * set.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティ設定時の値セット処理を担う関数（set）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、getResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - setByRefで構造化パス・リストインデックスに対応した値設定を実行\r\n * - それ以外（シンボル等）の場合はReflect.setで通常のプロパティ設定を実行\r\n *\r\n * 設計ポイント:\r\n * - バインディングや多重ループ、ワイルドカードを含むパスにも柔軟に対応\r\n * - setByRefを利用することで、依存解決や再描画などの副作用も一元管理\r\n * - Reflect.setで標準的なプロパティ設定の互換性も確保\r\n */\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\n\r\nexport function set(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  value   : any, \r\n  receiver: IStateProxy,\r\n  handler : IStateHandler\r\n): boolean {\r\n  if (typeof prop === \"string\") {\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return setByRef(\r\n      target, \r\n      ref,\r\n      value, \r\n      receiver,\r\n      handler\r\n    );\r\n  } else {\r\n    return Reflect.set(\r\n      target, \r\n      prop, \r\n      value, \r\n      receiver\r\n    );\r\n  }\r\n}\r\n","/**\r\n * setLoopContext.ts\r\n *\r\n * StateClassの内部APIとして、ループコンテキスト（ILoopContext）を一時的に設定し、\r\n * 指定した非同期コールバックをそのスコープ内で実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.loopContextにループコンテキストを一時的に設定\r\n * - 既にループコンテキストが設定されている場合はエラーを投げる\r\n * - loopContextが存在する場合はasyncSetStatePropertyRefでスコープを設定しコールバックを実行\r\n * - loopContextがnullの場合はそのままコールバックを実行\r\n * - finallyで必ずloopContextをnullに戻し、スコープ外への影響を防止\r\n *\r\n * 設計ポイント:\r\n * - ループバインディングや多重ループ時のスコープ管理を安全に行う\r\n * - finallyで状態復元を保証し、例外発生時も安全\r\n * - 非同期処理にも対応\r\n */\r\nimport { ILoopContext } from \"../../LoopContext/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IWritableStateHandler } from \"../types\";\r\n\r\nexport function setLoopContext<R>(\r\n  handler: IWritableStateHandler,\r\n  loopContext: ILoopContext | null,\r\n  callback: () => R\r\n): R {\r\n  if (handler.loopContext) {\r\n    raiseError({\r\n      code: 'STATE-301',\r\n      message: 'already in loop context',\r\n      context: { where: 'setLoopContext' },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n  handler.loopContext = loopContext;\r\n  let resultPromise: R | undefined; \r\n  try {\r\n    if (loopContext) {\r\n      if (handler.refStack.length === 0) {\r\n        raiseError({\r\n          code: 'STC-002',\r\n          message: 'handler.refStack is empty in getByRef',\r\n        });\r\n      }\r\n      handler.refIndex++;\r\n      if (handler.refIndex >= handler.refStack.length) {\r\n        handler.refStack.push(null);\r\n      }\r\n      handler.refStack[handler.refIndex] = handler.lastRefStack = loopContext.ref;\r\n      try {\r\n        resultPromise = callback();\r\n      } finally {\r\n        handler.refStack[handler.refIndex] = null;\r\n        handler.refIndex--;\r\n        handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      }\r\n    } else {\r\n      resultPromise = callback();\r\n    }\r\n  } finally {\r\n    // Promiseの場合は新しいPromiseチェーンを返してfinallyを適用\r\n    if (resultPromise instanceof Promise) {\r\n      return resultPromise.finally(() => {\r\n        handler.loopContext = null;\r\n      }) as R;\r\n    }\r\n    // 同期の場合は即座にリセット\r\n    handler.loopContext = null;\r\n  }\r\n  return resultPromise as R;\r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { WILDCARD } from \"../constants\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { findPathNodeByPath } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createReadonlyStateHandler, createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy\";\r\nimport { GetListIndexesByRefSymbol } from \"../StateClass/symbols\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy } from \"../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IListInfo, IRenderer, IUpdater, ReadonlyStateCallback } from \"./types\";\r\n\r\n/**\r\n * Renderer は、State の変更（参照 IStatePropertyRef の集合）に対応して、\r\n * PathTree を辿りつつ各 Binding（IBinding）へ applyChange を委譲するコーディネータです。\r\n *\r\n * 主な役割\r\n * - reorderList: 要素単位の並べ替え要求を収集し、親リスト単位の差分（IListDiff）へ変換して適用\r\n * - render: エントリポイント。ReadonlyState を生成し、reorder → 各 ref の描画（renderItem）の順で実行\r\n * - renderItem: 指定 ref に紐づく Binding を更新し、静的依存（子 PathNode）と動的依存を再帰的に辿る\r\n *\r\n * コントラクト\r\n * - Binding#applyChange(renderer): 変更があった場合は renderer.updatedBindings に自分自身を追加すること\r\n * - readonlyState[GetByRefSymbol](ref): ref の新しい値（読み取り専用ビュー）を返すこと\r\n *\r\n * スレッド/再入\r\n * - 同期実行前提。\r\n *\r\n * 代表的な例外\r\n * - UPD-001/002: Engine/ReadonlyState の未初期化\r\n * - UPD-003/004/005/006: ListIndex/ParentInfo/OldList* の不整合や ListDiff 未生成\r\n * - PATH-101: PathNode が見つからない\r\n */\r\nclass Renderer implements IRenderer {\r\n  #updatingRefs: IStatePropertyRef[] = [];\r\n  #updatingRefSet: Set<IStatePropertyRef> = new Set();\r\n  /**\r\n   * このレンダリングサイクルで「変更あり」となった Binding の集合。\r\n   * 注意: 実際に追加するのは各 binding.applyChange 実装側の責務。\r\n   */\r\n  #updatedBindings: Set<IBinding> = new Set();\r\n  /**\r\n   * 二重適用を避けるために処理済みとした参照。\r\n   * renderItem の再帰や依存関係の横断時に循環/重複を防ぐ。\r\n   */\r\n  #processedRefs: Set<IStatePropertyRef> = new Set();\r\n  /**\r\n   * レンダリング対象のエンジン。state, pathManager, bindings などのファサード。\r\n   */\r\n  #engine: IComponentEngine;\r\n  #readonlyState: IReadonlyStateProxy | null = null;\r\n\r\n  #readonlyHandler : IReadonlyStateHandler | null = null;\r\n\r\n  /**\r\n   * 親リスト参照ごとに「要素の新しい並び位置」を記録するためのインデックス配列。\r\n   * reorderList で収集し、後段で仮の IListDiff を生成するために用いる。\r\n   */\r\n  #reorderIndexesByRef: Map<IStatePropertyRef, number[]> = new Map();\r\n\r\n  #lastListInfoByRef: Map<IStatePropertyRef, IListInfo> = new Map();\r\n\r\n  #updater: IUpdater;\r\n\r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this.#engine = engine;\r\n    this.#updater = updater;\r\n  }\r\n\r\n  get updatingRefs(): IStatePropertyRef[] {\r\n    return this.#updatingRefs;\r\n  }\r\n\r\n  get updatingRefSet(): Set<IStatePropertyRef> {\r\n    return this.#updatingRefSet;\r\n  }\r\n\r\n  /**\r\n   * このサイクル中に更新された Binding の集合を返す（読み取り専用的に使用）。\r\n   */\r\n  get updatedBindings(): Set<IBinding> {\r\n    return this.#updatedBindings;\r\n  }\r\n\r\n  /**\r\n   * 既に処理済みの参照集合を返す。二重適用の防止に利用する。\r\n   */\r\n  get processedRefs(): Set<IStatePropertyRef> {\r\n    return this.#processedRefs;\r\n  }\r\n\r\n  /**\r\n   * 読み取り専用 State ビューを取得する。render 実行中でなければ例外。\r\n   * Throws: UPD-002\r\n   */\r\n  get readonlyState(): IReadonlyStateProxy {\r\n    if (!this.#readonlyState) {\r\n      raiseError({\r\n        code: \"UPD-002\",\r\n        message: \"ReadonlyState not initialized\",\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this.#readonlyState;\r\n  }\r\n\r\n  get readonlyHandler(): IReadonlyStateHandler {\r\n    if (!this.#readonlyHandler) {\r\n      raiseError({\r\n        code: \"UPD-002\",\r\n        message: \"ReadonlyHandler not initialized\",\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this.#readonlyHandler;\r\n  }\r\n\r\n  /**\r\n   * バッキングエンジンを取得する。未初期化の場合は例外。\r\n   * Throws: UPD-001\r\n   */\r\n  get engine(): IComponentEngine {\r\n    if (!this.#engine) {\r\n      raiseError({\r\n        code: \"UPD-001\",\r\n        message: \"Engine not initialized\",\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this.#engine;\r\n  }\r\n\r\n  get lastListInfoByRef(): Map<IStatePropertyRef, IListInfo> {\r\n    return this.#lastListInfoByRef;\r\n  }\r\n\r\n  /**\r\n   * リードオンリーな状態を生成し、コールバックに渡す\r\n   * @param callback \r\n   * @returns \r\n   */\r\n  createReadonlyState(callback: ReadonlyStateCallback): any {\r\n    const handler = createReadonlyStateHandler(this.#engine, this.#updater, this);\r\n    const stateProxy = createReadonlyStateProxy(this.#engine.state, handler);\r\n    this.#readonlyState = stateProxy;\r\n    this.#readonlyHandler = handler;\r\n    try {\r\n      return callback(stateProxy, handler);\r\n    } finally {\r\n      this.#readonlyState = null;\r\n      this.#readonlyHandler = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * レンダリングのエントリポイント。ReadonlyState を生成し、\r\n   * 並べ替え処理→各参照の描画の順に処理します。\r\n   *\r\n   * 注意\r\n   * - readonlyState はこのメソッドのスコープ内でのみ有効。\r\n   * - SetCacheableSymbol により参照解決のキャッシュをまとめて有効化できる。\r\n   */\r\n  render(items: IStatePropertyRef[]): void {\r\n    this.#reorderIndexesByRef.clear();\r\n    this.#processedRefs.clear();\r\n    this.#updatedBindings.clear();\r\n    this.#updatingRefs = [...items];\r\n    this.#updatingRefSet = new Set(items);\r\n\r\n    // 実際のレンダリングロジックを実装\r\n    this.createReadonlyState( (readonlyState, readonlyHandler) => {\r\n      // まずはリストの並び替えを処理\r\n      const remainItems: IStatePropertyRef[] = [];\r\n      const itemsByListRef = new Map<IStatePropertyRef, Set<IStatePropertyRef>>();\r\n      const refSet = new Set<IStatePropertyRef>();\r\n      for(let i = 0; i < items.length; i++) {\r\n        const ref = items[i];\r\n        refSet.add(ref);\r\n        if (!this.#engine.pathManager.elements.has(ref.info.pattern)) {\r\n          remainItems.push(ref);\r\n          continue;\r\n        }\r\n        const listRef = ref.parentRef ?? raiseError({\r\n          code: \"UPD-004\",\r\n          message: `ParentInfo is null for ref: ${ref.key}`,\r\n          context: { refKey: ref.key, pattern: ref.info.pattern },\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n        if (!itemsByListRef.has(listRef)) {\r\n          itemsByListRef.set(listRef, new Set());\r\n        }\r\n        itemsByListRef.get(listRef)!.add(ref);\r\n      }\r\n      for(const [listRef, refs] of itemsByListRef) {\r\n        if (refSet.has(listRef)) {\r\n          for(const ref of refs) {\r\n            this.#processedRefs.add(ref); // 終了済み\r\n          }\r\n          continue; // 親リストが存在する場合はスキップ\r\n        }\r\n        const bindings = this.#engine.getBindings(listRef);\r\n        for(let i = 0; i < bindings.length; i++) {\r\n          if (this.#updatedBindings.has(bindings[i])) continue;\r\n          bindings[i].applyChange(this);\r\n        }\r\n        this.processedRefs.add(listRef);\r\n      }\r\n\r\n      for(let i = 0; i < remainItems.length; i++) {\r\n        const ref = remainItems[i];\r\n        const node = findPathNodeByPath(this.#engine.pathManager.rootNode, ref.info.pattern);\r\n        if (node === null) {\r\n          raiseError({\r\n            code: \"PATH-101\",\r\n            message: `PathNode not found: ${ref.info.pattern}`,\r\n            context: { pattern: ref.info.pattern },\r\n            docsUrl: \"./docs/error-codes.md#path\",\r\n          });\r\n        }\r\n        if (!this.processedRefs.has(ref)) {\r\n          this.renderItem(ref, node);\r\n        }\r\n      }\r\n      // 子コンポーネントへの再描画通知\r\n      if (this.#engine.structiveChildComponents.size > 0) {\r\n        for(const structiveComponent of this.#engine.structiveChildComponents) {\r\n          const structiveComponentBindings = this.#engine.bindingsByComponent.get(structiveComponent) ?? new Set<IBinding>();\r\n          for(const binding of structiveComponentBindings) {\r\n            binding.notifyRedraw(remainItems);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 単一の参照 ref と対応する PathNode を描画します。\r\n   *\r\n   * - まず自身のバインディング適用\r\n   * - 次に静的依存（ワイルドカード含む）\r\n   * - 最後に動的依存（ワイルドカードは階層的に展開）\r\n   *\r\n   * 静的依存（子ノード）\r\n   * - それ以外: 親の listIndex を引き継いで子参照を生成して再帰描画\r\n   *\r\n   * 動的依存\r\n   * - pathManager.dynamicDependencies に登録されたパスを基に、ワイルドカードを展開しつつ描画を再帰\r\n   *\r\n   * Throws\r\n   * - UPD-006: WILDCARD 分岐で ListDiff が未計算（null）の場合\r\n   * - PATH-101: 動的依存の PathNode 未検出\r\n   */\r\n  renderItem(\r\n    ref: IStatePropertyRef,\r\n    node: IPathNode,\r\n  ): void {\r\n    this.processedRefs.add(ref);\r\n\r\n    // バインディングに変更を適用する\r\n    // 変更があったバインディングは updatedBindings に追加する（applyChange 実装の責務）\r\n    const bindings = this.#engine.getBindings(ref);\r\n    for(let i = 0; i < bindings.length; i++) {\r\n      if (this.#updatedBindings.has(bindings[i])) continue;\r\n      bindings[i].applyChange(this);\r\n    }\r\n\r\n    let diffListIndexes: Set<IListIndex> = new Set();\r\n    if (this.#engine.pathManager.lists.has(ref.info.pattern)) {\r\n      const currentListIndexes = new Set(this.readonlyState[GetListIndexesByRefSymbol](ref) ?? []);\r\n      const { listIndexes } = this.lastListInfoByRef.get(ref) ?? {};\r\n      const lastListIndexSet = new Set(listIndexes ?? []);\r\n      diffListIndexes = currentListIndexes.difference(lastListIndexSet);\r\n    }\r\n\r\n    // 静的な依存関係を辿る\r\n    for(const [ name, childNode ] of node.childNodeByName) {\r\n      const childInfo = getStructuredPathInfo(childNode.currentPath);\r\n      if (name === WILDCARD) {\r\n        for(const listIndex of diffListIndexes) {\r\n          const childRef = getStatePropertyRef(childInfo, listIndex);\r\n          if (!this.processedRefs.has(childRef)) {\r\n            this.renderItem(childRef, childNode);\r\n          }\r\n        }\r\n      } else {\r\n        const childRef = getStatePropertyRef(childInfo, ref.listIndex);\r\n        if (!this.processedRefs.has(childRef)) {\r\n          this.renderItem(childRef, childNode);\r\n        }\r\n      }\r\n    }\r\n\r\n    // 動的な依存関係を辿る\r\n    const deps = this.#engine.pathManager.dynamicDependencies.get(ref.info.pattern);\r\n    if (deps) {\r\n      for(const depPath of deps) {\r\n        const depInfo = getStructuredPathInfo(depPath);\r\n        const depNode = findPathNodeByPath(this.#engine.pathManager.rootNode, depInfo.pattern);\r\n        if (depNode === null) {\r\n          raiseError({\r\n            code: \"PATH-101\",\r\n            message: `PathNode not found: ${depInfo.pattern}`,\r\n            context: { pattern: depInfo.pattern },\r\n            docsUrl: \"./docs/error-codes.md#path\",\r\n          });\r\n        }\r\n        if (depInfo.wildcardCount > 0) {\r\n          const infos = depInfo.wildcardParentInfos;\r\n          const walk = (depRef: IStatePropertyRef, index: number, nextInfo: IStructuredPathInfo) => {\r\n            const listIndexes = this.readonlyState[GetListIndexesByRefSymbol](depRef) || [];\r\n            if ((index + 1) < infos.length) {\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const nextRef = getStatePropertyRef(nextInfo, listIndexes[i]);\r\n                walk(nextRef, index + 1, infos[index + 1]);\r\n              }\r\n            } else {\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const subDepRef = getStatePropertyRef(depInfo, listIndexes[i]);\r\n                if (!this.processedRefs.has(subDepRef)) {\r\n                  this.renderItem(subDepRef, depNode);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          const startRef = getStatePropertyRef(depInfo.wildcardParentInfos[0], null);\r\n          walk(startRef, 0, depInfo.wildcardParentInfos[1] || null);\r\n        } else {\r\n          const depRef = getStatePropertyRef(depInfo, null);\r\n          if (!this.processedRefs.has(depRef)) {\r\n            this.renderItem(depRef, depNode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  \r\n}\r\n\r\n/**\r\n * 便宜関数。Renderer のインスタンス化と render 呼び出しをまとめて行う。\r\n */\r\nexport function render(refs: IStatePropertyRef[], engine: IComponentEngine, updater: IUpdater): void {\r\n  const renderer = new Renderer(engine, updater);\r\n  renderer.render(refs);\r\n}\r\n\r\nexport function createRenderer(engine: IComponentEngine, updater: IUpdater): IRenderer {\r\n  return new Renderer(engine, updater);\r\n}","import { IComponentEngine, IVersionRevision } from \"../ComponentEngine/types\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { findPathNodeByPath } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createReadonlyStateHandler, createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy\";\r\nimport { UpdatedCallbackSymbol } from \"../StateClass/symbols\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { useWritableStateProxy } from \"../StateClass/useWritableStateProxy\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { createRenderer, render } from \"./Renderer\";\r\nimport { IListInfo, IRenderer, IUpdater, ReadonlyStateCallback, UpdateCallback } from \"./types\";\r\n\r\n\r\n/**\r\n * Updaterクラスは、状態管理と更新の中心的な役割を果たします。\r\n * 状態更新が必要な場合に、都度インスタンスを作成して使用します。\r\n * 主な機能は以下の通りです:\r\n */\r\nclass Updater implements IUpdater {\r\n  queue: IStatePropertyRef[] = [];\r\n  #rendering: boolean = false;\r\n  #engine: IComponentEngine;\r\n\r\n  #version: number;\r\n  #revision: number = 0;\r\n  #swapInfoByRef: Map<IStatePropertyRef, IListInfo> = new Map();\r\n  #saveQueue: IStatePropertyRef[] = [];\r\n\r\n  constructor(engine: IComponentEngine) {\r\n    this.#engine = engine;\r\n    this.#version = engine.versionUp();\r\n  }\r\n\r\n  get version(): number {\r\n    return this.#version;\r\n  }\r\n\r\n  get revision(): number {\r\n    return this.#revision;\r\n  }\r\n\r\n  get swapInfoByRef(): Map<IStatePropertyRef, IListInfo> {\r\n    return this.#swapInfoByRef;\r\n  }\r\n\r\n  /**\r\n   * 更新したRefをキューに追加し、レンダリングをスケジュールする\r\n   * @param ref \r\n   * @returns \r\n   */\r\n  enqueueRef(ref: IStatePropertyRef): void {\r\n    this.#revision++;\r\n    this.queue.push(ref);\r\n    this.#saveQueue.push(ref);\r\n    this.collectMaybeUpdates(this.#engine, ref.info.pattern, this.#engine.versionRevisionByPath, this.#revision);\r\n    // レンダリング中はスキップ\r\n    if (this.#rendering) return;\r\n    this.#rendering = true;\r\n    queueMicrotask(() => {\r\n      // 非同期処理で中断するか、更新処理が完了した後にレンダリングを実行\r\n      this.rendering();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 状態更新処理開始\r\n   * @param loopContext \r\n   * @param callback \r\n   */\r\n  update<R>(\r\n    loopContext: ILoopContext | null, \r\n    callback: (state: IWritableStateProxy, handler: IWritableStateHandler) => R\r\n  ): R {\r\n    let resultPromise: R;\r\n    resultPromise = useWritableStateProxy<R>(this.#engine, this, this.#engine.state, loopContext, (state:IWritableStateProxy, handler:IWritableStateHandler): R => {\r\n      // 状態更新処理\r\n      return callback(state, handler);\r\n    });\r\n    const updatedCallbackHandler = () =>{\r\n      if (this.#engine.pathManager.hasUpdatedCallback && this.#saveQueue.length > 0) {\r\n        const saveQueue = this.#saveQueue;\r\n        this.#saveQueue = [];\r\n        queueMicrotask(() => {\r\n          this.update<void>(null, (state, handler) => {\r\n            state[UpdatedCallbackSymbol](saveQueue);\r\n          });\r\n        });\r\n      }\r\n    };\r\n    if (resultPromise instanceof Promise) {\r\n      resultPromise.finally(() => {\r\n        updatedCallbackHandler();\r\n      });\r\n    } else {\r\n      updatedCallbackHandler();\r\n    }\r\n    return resultPromise;\r\n }\r\n\r\n  /**\r\n   * レンダリング処理\r\n   */\r\n  rendering(): void {\r\n    try {\r\n      while( this.queue.length > 0 ) {\r\n        // キュー取得\r\n        const queue = this.queue;\r\n        this.queue = [];\r\n        // レンダリング実行\r\n        render(queue, this.#engine, this);\r\n      }\r\n    } finally {\r\n      this.#rendering = false;\r\n    }\r\n  }\r\n\r\n  initialRender(callback: (renderer: IRenderer) => void): void {\r\n    const renderer = createRenderer(this.#engine, this);\r\n    callback(renderer);\r\n  }\r\n  /**\r\n   * 更新したパスに対して影響があるパスを再帰的に収集する\r\n   * @param engine \r\n   * @param path \r\n   * @param node \r\n   * @param revisionByUpdatedPath \r\n   * @param revision \r\n   * @param visitedInfo \r\n   * @returns \r\n   */\r\n  recursiveCollectMaybeUpdates(\r\n    engine: IComponentEngine,\r\n    path: string,\r\n    node: IPathNode,\r\n    visitedInfo: Set<string>,\r\n    isSource: boolean\r\n  ): void {\r\n    if (visitedInfo.has(path)) return;\r\n    // swapの場合スキップしたい\r\n    if (isSource && engine.pathManager.elements.has(path)) {\r\n      return;\r\n    }\r\n    visitedInfo.add(path);\r\n\r\n    for(const [name, childNode] of node.childNodeByName.entries()) {\r\n      const childPath = childNode.currentPath;\r\n      this.recursiveCollectMaybeUpdates(engine, childPath, childNode, visitedInfo, false);\r\n    }\r\n\r\n    const deps = engine.pathManager.dynamicDependencies.get(path) ?? [];\r\n    for(const depPath of deps) {\r\n      const depNode = findPathNodeByPath(engine.pathManager.rootNode, depPath);\r\n      if (depNode === null) {\r\n        raiseError({\r\n          code: \"UPD-004\",\r\n          message: `Path node not found for pattern: ${depPath}`,\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n      }\r\n      this.recursiveCollectMaybeUpdates(engine, depPath, depNode, visitedInfo, false);\r\n    }\r\n  }\r\n\r\n  #cacheUpdatedPathsByPath: Map<string, Set<string>> = new Map();\r\n  collectMaybeUpdates(engine: IComponentEngine, path: string, versionRevisionByPath: Map<string, IVersionRevision>, revision: number): void {\r\n    const node = findPathNodeByPath(engine.pathManager.rootNode, path);\r\n    if (node === null) {\r\n      raiseError({\r\n        code: \"UPD-003\",\r\n        message: `Path node not found for pattern: ${path}`,\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n\r\n    // キャッシュ\r\n    let updatedPaths = this.#cacheUpdatedPathsByPath.get(path);\r\n    if (typeof updatedPaths === \"undefined\") {\r\n      updatedPaths = new Set<string>();\r\n      this.recursiveCollectMaybeUpdates(engine, path, node, updatedPaths, true);\r\n    }\r\n    const versionRevision = {\r\n      version: this.version,\r\n      revision: revision,\r\n    } \r\n    for(const updatedPath of updatedPaths) {\r\n      versionRevisionByPath.set(updatedPath, versionRevision);\r\n    }\r\n    this.#cacheUpdatedPathsByPath.set(path, updatedPaths);\r\n  }\r\n\r\n  /**\r\n   * リードオンリーな状態を生成し、コールバックに渡す\r\n   * @param callback \r\n   * @returns \r\n   */\r\n  createReadonlyState<R>(\r\n    callback: (state: IReadonlyStateProxy, handler: IReadonlyStateHandler) => R\r\n  ): R {\r\n    const handler = createReadonlyStateHandler(this.#engine, this, null);\r\n    const stateProxy = createReadonlyStateProxy(this.#engine.state, handler);\r\n    return callback(stateProxy, handler);\r\n  }\r\n}\r\n\r\n/**\r\n * Updaterを生成しコールバックに渡す\r\n * スコープを明確にするための関数\r\n * @param engine \r\n * @param callback \r\n */\r\nexport function createUpdater<R>(\r\n  engine: IComponentEngine, \r\n  callback: (updater: IUpdater) => R\r\n): R {\r\n  const updater = new Updater(engine);\r\n  return callback(updater);\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeCheckbox class implements binding for checkboxes (input[type=\"checkbox\"]).\r\n * Controls checked state by comparing array value with checkbox value.\r\n * Supports bidirectional binding and readonly mode.\r\n *\r\n * @throws BIND-201 Value is not array: When non-array value is passed\r\n * @throws BIND-201 Has multiple decorators: When multiple decorators are specified\r\n */\r\nclass BindingNodeCheckbox extends BindingNode {\r\n  /**\r\n   * Returns raw value attribute of checkbox input element.\r\n   * \r\n   * @returns Value attribute string\r\n   */\r\n  get value(): any {\r\n    const element = this.node as HTMLInputElement;\r\n    return element.value;\r\n  }\r\n  \r\n  /**\r\n   * Returns value with all filters applied.\r\n   * \r\n   * @returns Filtered value\r\n   */\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for (let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  \r\n  /**\r\n   * Sets up bidirectional binding with event listener.\r\n   * Event name: \"input\" (default), \"change\" (if onchange/change decorator), or none (if readonly/ro).\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node (should be HTMLInputElement with type=\"checkbox\")\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n   * @throws BIND-201 Has multiple decorators\r\n   */\r\n  constructor(\r\n    binding: IBinding,\r\n    node: Node,\r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[],\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n\r\n    const isInputElement = this.node instanceof HTMLInputElement;\r\n    if (!isInputElement) return;\r\n    const inputElement = this.node as HTMLInputElement;\r\n    if (inputElement.type !== \"checkbox\") return;\r\n    \r\n    if (decorates.length > 1) {\r\n      raiseError({\r\n        code: \"BIND-201\",\r\n        message: \"Has multiple decorators\",\r\n        context: { where: \"BindingNodeCheckbox.constructor\", name: this.name, decoratesCount: decorates.length },\r\n        docsUrl: \"/docs/error-codes.md#bind\",\r\n        severity: \"error\",\r\n      });\r\n    }\r\n    \r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? \"input\";\r\n    \r\n    if (eventName === \"readonly\" || eventName === \"ro\") return;\r\n    \r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, async (e) => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      const value = this.filteredValue;\r\n      createUpdater<void>(engine, (updater) => {\r\n        updater.update(loopContext, (state, handler) => {\r\n          binding.updateStateValue(state, handler, value);\r\n        });\r\n      });\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Sets checked state based on whether array includes filteredValue.\r\n   * \r\n   * @param value - Array of checked values\r\n   * @throws BIND-201 Value is not array\r\n   */\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not array',\r\n        context: { where: 'BindingNodeCheckbox.update', receivedType: typeof value },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    const filteredValue = this.filteredValue;\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.includes(filteredValue);\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate checkbox binding node.\r\n * \r\n * @param name - Binding name\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n * @returns Function that creates BindingNodeCheckbox with binding, node, and filters\r\n */\r\nexport const createBindingNodeCheckbox: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      return new BindingNodeCheckbox(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassList class implements binding for class attribute (classList).\r\n * Converts array value to space-separated string and sets to className.\r\n * One-way binding only.\r\n *\r\n * @throws BIND-201 Value is not array: When non-array value is passed\r\n */\r\nclass BindingNodeClassList extends BindingNode {\r\n  /**\r\n   * Converts array to space-separated string and sets to element.className.\r\n   * \r\n   * @param value - Array of class names\r\n   * @throws BIND-201 Value is not array\r\n   */\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not array',\r\n        context: { where: 'BindingNodeClassList.update', receivedType: typeof value },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    const element = this.node as Element;\r\n    element.className = value.join(\" \");\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate classList binding node.\r\n * \r\n * @param name - Binding name (\"class\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeClassList with binding, node, and filters\r\n */\r\nexport const createBindingNodeClassList: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      return new BindingNodeClassList(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassName class implements toggle control for individual class names.\r\n * Uses classList.toggle based on boolean value.\r\n *\r\n * @throws BIND-201 Value is not boolean: When non-boolean value is passed\r\n */\r\nclass BindingNodeClassName extends BindingNode {\r\n  /**\r\n   * Adds or removes class based on boolean value using classList.toggle.\r\n   * \r\n   * @param value - Boolean value (true: add class, false: remove class)\r\n   * @throws BIND-201 Value is not boolean\r\n   */\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not boolean',\r\n        context: { where: 'BindingNodeClassName.update', receivedType: typeof value },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    const element = this.node as Element;\r\n    element.classList.toggle(this.subName, value);\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate class name binding node.\r\n * \r\n * @param name - Binding name (e.g., \"class.active\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeClassName with binding, node, and filters\r\n */\r\nexport const createBindingNodeClassName: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      const [, subName] = name.split(\".\");\r\n      return new BindingNodeClassName(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeEvent class implements event binding (onClick, onInput, etc.).\r\n * Extracts event name from binding name (\"onClick\" → \"click\") and registers as event listener.\r\n * Supports preventDefault/stopPropagation decorators and passes loop indexes to handlers.\r\n *\r\n * @throws BIND-201 is not a function: When binding value is not a function\r\n */\r\nclass BindingNodeEvent extends BindingNode {\r\n  /**\r\n   * Registers event listener once at initialization.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node to attach event listener\r\n   * @param name - Binding name (e.g., \"onClick\", \"onInput\")\r\n   * @param subName - Event name extracted from binding name (e.g., \"click\", \"input\")\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (\"preventDefault\", \"stopPropagation\")\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    \r\n    const element = node as HTMLElement;\r\n    element.addEventListener(this.subName, (e:Event) => this.handler(e));\r\n  }\r\n  \r\n  /**\r\n   * Event binding does nothing on state change.\r\n   */\r\n  update() {\r\n  }\r\n\r\n  /**\r\n   * Executes bound function with event object and loop indexes as arguments.\r\n   * Supports preventDefault/stopPropagation decorators.\r\n   * \r\n   * @param e - DOM event object\r\n   * @returns Promise if handler returns Promise, void otherwise\r\n   * @throws BIND-201 Binding value is not a function\r\n   */\r\n  async handler(e: Event) {\r\n    const engine = this.binding.engine;\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const indexes = loopContext?.serialize().map((context) => context.listIndex.index) ?? [];\r\n    const options = this.decorates;\r\n    \r\n    if (options.includes(\"preventDefault\")) {\r\n      e.preventDefault();\r\n    }\r\n    if (options.includes(\"stopPropagation\")) {\r\n      e.stopPropagation();\r\n    }\r\n    \r\n    const resultPromise = createUpdater<Promise<void> | void>(engine, (updater) => {\r\n      return updater.update<Promise<void> | void>(loopContext, (state, handler) => {\r\n        const func = this.binding.bindingState.getValue(state, handler);\r\n        if (typeof func !== \"function\") {\r\n          raiseError({\r\n            code: 'BIND-201',\r\n            message: `${this.name} is not a function`,\r\n            context: { where: 'BindingNodeEvent.handler', name: this.name, receivedType: typeof func },\r\n            docsUrl: '/docs/error-codes.md#bind',\r\n            severity: 'error',\r\n          });\r\n        }\r\n        return Reflect.apply(func, state, [e, ...indexes]);\r\n      });\r\n    });\r\n    \r\n    if (resultPromise instanceof Promise) {\r\n      await resultPromise;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Event binding does nothing on state change.\r\n   * \r\n   * @param renderer - Renderer instance (unused)\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate event binding node.\r\n * \r\n * @param name - Binding name (e.g., \"onClick\", \"onInput\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (\"preventDefault\", \"stopPropagation\")\r\n * @returns Function that creates BindingNodeEvent with binding, node, and filters\r\n */\r\nexport const createBindingNodeEvent: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      const subName = name.slice(2);\r\n      return new BindingNodeEvent(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","import { COMMENT_TEMPLATE_MARK } from \"../../constants.js\";\r\nimport { Filters } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\n\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * BindingNodeBlock is the base class for template blocks (for, if, etc.).\r\n * Extracts and validates template ID from comment node format: \"@@|<id> <pattern>\"\r\n * \r\n * Validation: Non-negative integer only, no leading zeros.\r\n *\r\n * @throws BIND-201 Invalid node: When ID cannot be extracted from comment node\r\n */\r\nexport class BindingNodeBlock extends BindingNode {\r\n  #id: number;\r\n  \r\n  /**\r\n   * Returns template ID extracted from comment node.\r\n   * \r\n   * @returns Template ID (non-negative integer)\r\n   */\r\n  get id(): number {\r\n    return this.#id;\r\n  }\r\n\r\n  /**\r\n   * Extracts and validates template ID from comment node.\r\n   * Rejects leading zeros, decimals, negatives, NaN, and Infinity.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Comment node containing template ID\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators\r\n   * @throws BIND-201 Invalid node (cannot extract valid template ID)\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    \r\n    const commentText = this.node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN) ?? raiseError({\r\n      code: 'BIND-201',\r\n      message: 'Invalid node',\r\n      context: { where: 'BindingNodeBlock.id', textContent: this.node.textContent ?? null },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n      severity: 'error',\r\n    });\r\n    \r\n    const [ id,  ] = commentText.split(' ', 2);\r\n    const numId = Number(id);\r\n    \r\n    if (numId.toString() !== id || isNaN(numId) || !isFinite(numId) || !Number.isInteger(numId) || numId < 0) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Invalid node',\r\n        context: { where: 'BindingNodeBlock.id', textContent: this.node.textContent },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    this.#id = numId;\r\n  }\r\n    \r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNode for conditional rendering (if binding).\r\n * Controls BindContent mount/unmount based on boolean value.\r\n * Uses comment node as marker to insert/remove content.\r\n *\r\n * @throws BIND-201 assignValue not implemented\r\n * @throws BIND-201 Value must be boolean\r\n * @throws BIND-201 ParentNode is null\r\n */\r\nclass BindingNodeIf extends BindingNodeBlock {\r\n  private _bindContent: IBindContent;\r\n  private _trueBindContents: IBindContent[];\r\n  private _falseBindContents: IBindContent[] = [];\r\n  private _bindContents: IBindContent[];\r\n\r\n  /**\r\n   * Initializes BindContent with blank reference.\r\n   * Initial state treated as false (unmounted).\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Comment node as marker\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string, \r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    const blankInfo = getStructuredPathInfo(\"\");\r\n    const blankRef = getStatePropertyRef(blankInfo, null);\r\n    \r\n    this._bindContent = createBindContent(\r\n      this.binding, \r\n      this.id, \r\n      this.binding.engine,\r\n      blankRef, \r\n    );\r\n    \r\n    this._trueBindContents = [this._bindContent];\r\n    this._bindContents = this._falseBindContents;\r\n  }\r\n\r\n  /**\r\n   * Returns active BindContent array (true: [_bindContent], false: []).\r\n   * \r\n   * @returns Array of active IBindContent instances\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return this._bindContents;\r\n  }\r\n\r\n  /**\r\n   * Not implemented. Use applyChange for mount/unmount control.\r\n   * \r\n   * @param value - Value (unused)\r\n   * @throws BIND-201 Not implemented\r\n   */\r\n  assignValue(value: any): void {\r\n    raiseError({\r\n      code: 'BIND-201',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingNodeIf.assignValue', name: this.name },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n      severity: 'error',\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Validates boolean value and controls mount/unmount.\r\n   * True: activate + mount + applyChange\r\n   * False: unmount + inactivate\r\n   * \r\n   * @param renderer - Renderer instance for state access\r\n   * @throws BIND-201 Value is not boolean\r\n   * @throws BIND-201 ParentNode is null\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState, renderer.readonlyHandler);\r\n    \r\n    if (typeof filteredValue !== \"boolean\") {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not boolean',\r\n        context: { where: 'BindingNodeIf.applyChange', valueType: typeof filteredValue },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ParentNode is null',\r\n        context: { where: 'BindingNodeIf.applyChange', nodeType: this.node.nodeType },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    if (filteredValue) {\r\n      this._bindContent.activate();\r\n      this._bindContent.mountAfter(parentNode, this.node);\r\n      this._bindContent.applyChange(renderer);\r\n      this._bindContents = this._trueBindContents;\r\n    } \r\n    else {\r\n      this._bindContent.unmount();\r\n      this._bindContent.inactivate();\r\n      this._bindContents = this._falseBindContents;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup: unmount and inactivate content.\r\n   */\r\n  inactivate(): void {\r\n    this._bindContent.unmount();\r\n    this._bindContent.inactivate();\r\n    this._bindContents = this._falseBindContents;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create BindingNodeIf instances.\r\n * \r\n * @param name - Binding name\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeIf with binding, node, and filters\r\n */\r\nexport const createBindingNodeIf: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      return new BindingNodeIf(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { GetByRefSymbol, GetListIndexesByRefSymbol } from \"../../StateClass/symbols.js\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nconst EMPTY_SET = new Set<any>();\r\nconst USE_ALL_APPEND = (globalThis as any).__STRUCTIVE_USE_ALL_APPEND__ === true;\r\n\r\n/**\r\n * BindingNode for loop rendering (for binding).\r\n * Manages BindContent instances for each list element with efficient diff detection and pooling.\r\n */\r\nclass BindingNodeFor extends BindingNodeBlock {\r\n  private _bindContents: IBindContent[] = [];\r\n  private _bindContentByListIndex: WeakMap<IListIndex, IBindContent> = new WeakMap();\r\n  private _bindContentPool: IBindContent[] = [];\r\n  private _bindContentLastIndex: number = 0;\r\n  private _loopInfo: IStructuredPathInfo | undefined = undefined;\r\n  private _oldList: any = undefined;\r\n  private _oldListIndexes: IListIndex[] = [];\r\n  private _oldListIndexSet: Set<IListIndex> = new Set();\r\n\r\n  /**\r\n   * Returns array of active BindContent instances for each list element.\r\n   * \r\n   * @returns Array of IBindContent instances\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return this._bindContents;\r\n  }\r\n\r\n  /**\r\n   * Returns last index of available BindContent in pool.\r\n   * \r\n   * @returns Last pool index (-1 if pool is empty)\r\n   */\r\n  get bindContentLastIndex():number {\r\n    return this._bindContentLastIndex;\r\n  }\r\n\r\n  /**\r\n   * Sets last index of available BindContent in pool.\r\n   * \r\n   * @param value - New last index value\r\n   */\r\n  set bindContentLastIndex(value:number) {\r\n    this._bindContentLastIndex = value;\r\n  }\r\n\r\n  /**\r\n   * Returns current pool size.\r\n   * \r\n   * @returns Number of BindContent instances in pool\r\n   */\r\n  get poolLength():number {\r\n    return this._bindContentPool.length;\r\n  }\r\n\r\n  /**\r\n   * Sets pool size, truncating if smaller than current size.\r\n   * \r\n   * @param length - New pool length\r\n   * @throws BIND-202 Length is negative\r\n   */\r\n  set poolLength(length: number) {\r\n    if (length < 0) {\r\n      raiseError({\r\n        code: 'BIND-202',\r\n        message: 'Length is negative',\r\n        context: { where: 'BindingNodeFor.setPoolLength', length },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    this._bindContentPool.length = length;\r\n  }\r\n\r\n  /**\r\n   * Returns structured path info for loop with wildcard (lazy-initialized).\r\n   * \r\n   * @returns IStructuredPathInfo for loop elements\r\n   */\r\n  get loopInfo(): IStructuredPathInfo {\r\n    if (typeof this._loopInfo === \"undefined\") {\r\n      const loopPath = this.binding.bindingState.pattern + \".*\";\r\n      this._loopInfo = getStructuredPathInfo(loopPath);\r\n    }\r\n    return this._loopInfo;\r\n  }\r\n\r\n  /**\r\n   * Creates or reuses BindContent from pool for given list index.\r\n   * \r\n   * @param renderer - Renderer instance (unused)\r\n   * @param listIndex - List index for new BindContent\r\n   * @returns Created or reused IBindContent instance\r\n   */\r\n  createBindContent(renderer: IRenderer, listIndex: IListIndex): IBindContent {\r\n    let bindContent: IBindContent;\r\n    if (this._bindContentLastIndex >= 0) {\r\n      bindContent = this._bindContentPool[this._bindContentLastIndex];\r\n      this._bindContentLastIndex--;\r\n      bindContent.assignListIndex(listIndex);\r\n    } else {\r\n      const loopRef = getStatePropertyRef(this.loopInfo, listIndex);\r\n      bindContent = createBindContent(\r\n        this.binding,\r\n        this.id,\r\n        this.binding.engine,\r\n        loopRef\r\n      );\r\n    }\r\n    this._bindContentByListIndex.set(listIndex, bindContent);\r\n    bindContent.activate();\r\n    return bindContent;\r\n  }\r\n\r\n  /**\r\n   * Unmounts and inactivates BindContent (returned to pool later).\r\n   * \r\n   * @param bindContent - BindContent to delete\r\n   */\r\n  deleteBindContent(bindContent: IBindContent): void {\r\n    bindContent.unmount();\r\n    bindContent.inactivate();\r\n  }\r\n\r\n  /**\r\n   * Not implemented. Use applyChange for list updates.\r\n   * \r\n   * @param value - Value (unused)\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  assignValue(value:any) {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented. Use update or applyChange',\r\n      context: { where: 'BindingNodeFor.assignValue' },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Applies list changes using diff detection algorithm.\r\n   * Handles adds, removes, reorders, and overwrites efficiently.\r\n   * \r\n   * @param renderer - Renderer instance for state access\r\n   * @throws BIND-201 ListIndex is null, BindContent not found, ParentNode is null, Last content is null\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    let newBindContents: IBindContent[] = [];\r\n\r\n    // Detect changes: adds, removes, changeIndexes, overwrites\r\n    const newList = renderer.readonlyState[GetByRefSymbol](this.binding.bindingState.ref);\r\n    const newListIndexes = renderer.readonlyState[GetListIndexesByRefSymbol](this.binding.bindingState.ref) ?? [];\r\n    const newListIndexesSet = new Set<IListIndex>(newListIndexes);\r\n    const oldSet = new Set<any>(this._oldList ?? EMPTY_SET);\r\n    const oldListLength = this._oldList?.length ?? 0;\r\n    const removesSet = newListIndexesSet.size === 0 ? this._oldListIndexSet : this._oldListIndexSet.difference(newListIndexesSet);\r\n    const addsSet = this._oldListIndexSet.size === 0 ? newListIndexesSet : newListIndexesSet.difference(this._oldListIndexSet);\r\n    const newListLength = newList?.length ?? 0;\r\n    const changeIndexesSet = new Set<IListIndex>();\r\n    const overwritesSet = new Set<IListIndex>();\r\n\r\n    // Classify updating refs into changeIndexes or overwrites\r\n    const elementsPath = this.binding.bindingState.info.pattern + \".*\";\r\n    for(let i = 0; i < renderer.updatingRefs.length; i++) {\r\n      const updatingRef = renderer.updatingRefs[i];\r\n      if (updatingRef.info.pattern !== elementsPath) continue;\r\n      if (renderer.processedRefs.has(updatingRef)) continue;\r\n      const listIndex = updatingRef.listIndex;\r\n      if (listIndex === null) {\r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'ListIndex is null',\r\n          context: { where: 'BindingNodeFor.applyChange', ref: updatingRef },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n        });\r\n      }\r\n      if (this._oldListIndexSet.has(listIndex)) {\r\n        changeIndexesSet.add(listIndex);\r\n      } else {\r\n        overwritesSet.add(listIndex);\r\n      }\r\n      renderer.processedRefs.add(updatingRef);\r\n    }\r\n    const parentNode = this.node.parentNode ?? raiseError({\r\n      code: 'BIND-201',\r\n      message: 'ParentNode is null',\r\n      context: { where: 'BindingNodeFor.applyChange' },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n    const removeBindContentsSet = new Set<IBindContent>();\r\n    const isAllRemove = (oldListLength === removesSet.size && oldListLength > 0);\r\n\r\n    // Optimization: clear parent node if removing all elements\r\n    let isParentNodeHasOnlyThisNode = false;\r\n    if (isAllRemove) {\r\n      const parentChildNodes = Array.from(parentNode.childNodes);\r\n      const lastContent = this._bindContents.at(-1) ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Last content is null',\r\n        context: { where: 'BindingNodeFor.applyChange' },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n      let firstNode: Node | null = parentChildNodes[0];\r\n      while(firstNode && firstNode.nodeType === Node.TEXT_NODE && firstNode.textContent?.trim() === \"\") {\r\n        firstNode = firstNode.nextSibling;\r\n      }\r\n      let lastNode: Node | null = parentChildNodes.at(-1) ?? null;\r\n      while(lastNode && lastNode.nodeType === Node.TEXT_NODE && lastNode.textContent?.trim() === \"\") {\r\n        lastNode = lastNode.previousSibling;\r\n      }\r\n      if (firstNode === this.node && lastNode === lastContent.getLastNode(parentNode)) {\r\n        isParentNodeHasOnlyThisNode = true;\r\n      }\r\n    }\r\n    if (isAllRemove && isParentNodeHasOnlyThisNode) {\r\n      parentNode.textContent = \"\";\r\n      parentNode.append(this.node);\r\n      for(let i = 0; i < this._bindContents.length; i++) {\r\n        this._bindContents[i].inactivate();\r\n      }\r\n      this._bindContentPool.push(...this._bindContents);\r\n    } else {\r\n      if (removesSet.size > 0) {\r\n        for(const listIndex of removesSet) {\r\n          const bindContent = this._bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'removes' },\r\n              docsUrl: './docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          this.deleteBindContent(bindContent);\r\n          removeBindContentsSet.add(bindContent);\r\n        }\r\n        this._bindContentPool.push(...removeBindContentsSet);\r\n      }\r\n    }\r\n    let lastBindContent = null;\r\n    const firstNode = this.node;\r\n    this.bindContentLastIndex = this.poolLength - 1;\r\n    const isAllAppend = USE_ALL_APPEND && (newListLength === addsSet.size && newListLength > 0);\r\n\r\n    // Optimization: reorder-only path when no adds/removes\r\n    const isReorder = addsSet.size === 0 && removesSet.size === 0 &&\r\n      (changeIndexesSet.size > 0 || overwritesSet.size > 0 );\r\n    if (!isReorder) {\r\n      // Rebuild path: create/reuse BindContents in new order\r\n      const oldIndexByListIndex = new Map<IListIndex, number>();\r\n      for(let i = 0; i < this._oldListIndexes.length; i++) {\r\n        oldIndexByListIndex.set(this._oldListIndexes[i], i);\r\n      }\r\n      const fragmentParentNode = isAllAppend ? document.createDocumentFragment() : parentNode;\r\n      const fragmentFirstNode = isAllAppend ? null : firstNode;\r\n      const changeListIndexes = [];\r\n      for(let i = 0; i < newListIndexes.length; i++) {\r\n        const listIndex = newListIndexes[i];\r\n        const lastNode = lastBindContent?.getLastNode(fragmentParentNode) ?? fragmentFirstNode;\r\n        let bindContent;\r\n        if (addsSet.has(listIndex)) {\r\n          bindContent = this.createBindContent(renderer, listIndex);\r\n          bindContent.mountAfter(fragmentParentNode, lastNode);\r\n          bindContent.applyChange(renderer);\r\n        } else {\r\n          bindContent = this._bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'reuse' },\r\n              docsUrl: './docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          if (lastNode?.nextSibling !== bindContent.firstChildNode) {\r\n            bindContent.mountAfter(fragmentParentNode, lastNode);\r\n          }\r\n          const oldIndex = oldIndexByListIndex.get(listIndex);\r\n          if (typeof oldIndex !== \"undefined\" && oldIndex !== i) {\r\n            changeListIndexes.push(listIndex);\r\n          }\r\n        }\r\n        newBindContents.push(bindContent);\r\n        lastBindContent = bindContent;\r\n      }\r\n      if (isAllAppend) {\r\n        const beforeNode = firstNode.nextSibling;\r\n        parentNode.insertBefore(fragmentParentNode, beforeNode);\r\n      }\r\n      for(const listIndex of changeListIndexes) {\r\n        const bindings = this.binding.bindingsByListIndex.get(listIndex) ?? [];\r\n        for(const binding of bindings) {\r\n          if (renderer.updatedBindings.has(binding)) continue;\r\n          binding.applyChange(renderer);\r\n        }\r\n      }\r\n    } else {\r\n      // Reorder path: only move DOM nodes without recreating\r\n      if (changeIndexesSet.size > 0) {\r\n        const bindContents = Array.from(this._bindContents);\r\n        const changeIndexes = Array.from(changeIndexesSet);\r\n        changeIndexes.sort((a, b) => a.index - b.index);\r\n        for(const listIndex of changeIndexes) {\r\n          const bindContent = this._bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'reorder' },\r\n              docsUrl: '/docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          bindContents[listIndex.index] = bindContent;\r\n          const lastNode = bindContents[listIndex.index - 1]?.getLastNode(parentNode) ?? firstNode;\r\n          bindContent.mountAfter(parentNode, lastNode);\r\n        }\r\n        newBindContents = bindContents;\r\n      }\r\n      if (overwritesSet.size > 0) {\r\n        for (const listIndex of overwritesSet) {\r\n          const bindContent = this._bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'overwrites' },\r\n              docsUrl: './docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          bindContent.applyChange(renderer);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update state for next diff detection\r\n    this.poolLength = this.bindContentLastIndex + 1;\r\n    this._bindContents = newBindContents;\r\n    this._oldList = [...newList];\r\n    this._oldListIndexes = [...newListIndexes];\r\n    this._oldListIndexSet = newListIndexesSet;\r\n  }\r\n\r\n  /**\r\n   * Inactivates all BindContents and resets state.\r\n   */\r\n  inactivate(): void {\r\n    for(let i = 0; i < this._bindContents.length; i++) {\r\n      const bindContent = this._bindContents[i];\r\n      bindContent.unmount();\r\n      bindContent.inactivate();\r\n    }\r\n    this._bindContentPool.push(...this._bindContents);\r\n    this._bindContents = [];\r\n    this._bindContentByListIndex = new WeakMap();\r\n    this._bindContentLastIndex = 0;\r\n    this._oldList = undefined;\r\n    this._oldListIndexes = [];\r\n    this._oldListIndexSet = new Set();\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create BindingNodeFor instances.\r\n * \r\n * @param name - Binding name (list property path)\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeFor with binding, node, and filters\r\n */\r\nexport const createBindingNodeFor: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeFor(binding, node, name, \"\", filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * Checks if element supports bidirectional binding.\r\n * \r\n * @param element - HTML element to check\r\n * @returns true if element is input/textarea/select, false otherwise\r\n */\r\nfunction isTwoWayBindable(element: HTMLElement): boolean {\r\n  return element instanceof HTMLInputElement\r\n    || element instanceof HTMLTextAreaElement\r\n    || element instanceof HTMLSelectElement;\r\n}\r\n\r\n/**\r\n * Default event names for bidirectional binding by property name.\r\n */\r\nconst defaultEventByName: Record<string, string> = {\r\n  value: \"input\",\r\n  valueAsNumber: \"input\",\r\n  valueAsDate: \"input\",\r\n  checked: \"change\",\r\n  selected: \"change\",\r\n};\r\n\r\ntype DefaultPropertyByElementType = {\r\n  [key: string]: Set<string>;\r\n};\r\n\r\n/**\r\n * Bidirectional bindable properties by input type.\r\n */\r\nconst twoWayPropertyByElementType: DefaultPropertyByElementType = {\r\n  radio: new Set([\"checked\"]),\r\n  checkbox: new Set([\"checked\"]),\r\n};\r\n\r\nconst VALUES_SET = new Set([\"value\", \"valueAsNumber\", \"valueAsDate\"]);\r\n\r\nconst BLANK_SET = new Set<string>();\r\n\r\n/**\r\n * Returns bidirectional bindable property set for element.\r\n * \r\n * @param node - DOM node to check\r\n * @returns Set of bindable property names (e.g., \"value\", \"checked\")\r\n */\r\nconst getTwoWayPropertiesHTMLElement = (node: Node): Set<string> =>\r\n  node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement || node instanceof HTMLOptionElement\r\n    ? VALUES_SET\r\n    : node instanceof HTMLInputElement\r\n      ? (twoWayPropertyByElementType[node.type] ?? VALUES_SET)\r\n      : BLANK_SET;\r\n\r\n\r\n/**\r\n * BindingNode for property binding (value, checked, etc.).\r\n * Supports bidirectional binding with event listeners.\r\n * Converts null/undefined/NaN to empty string.\r\n */\r\nclass BindingNodeProperty extends BindingNode {\r\n  /**\r\n   * Returns raw property value from DOM node.\r\n   * \r\n   * @returns Property value\r\n   */\r\n  get value(): any {\r\n    // @ts-ignore\r\n    return this.node[this.name];\r\n  }\r\n  \r\n  /**\r\n   * Returns property value with filters applied.\r\n   * \r\n   * @returns Filtered property value\r\n   */\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for (let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  \r\n  /**\r\n   * Registers event listener for bidirectional binding if:\r\n   * - Element supports two-way binding (input/textarea/select)\r\n   * - Property name is bindable (value, checked, etc.)\r\n   * - Not readonly decorator\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node\r\n   * @param name - Property name (e.g., \"value\", \"checked\")\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n   * @throws BIND-201 Has multiple decorators\r\n   */\r\n  constructor(\r\n    binding: IBinding,\r\n    node: Node,\r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[],\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n\r\n    const isElement = this.node instanceof HTMLElement;\r\n    if (!isElement) return;\r\n    \r\n    if (!isTwoWayBindable(this.node)) return;\r\n    \r\n    const defaultNames = getTwoWayPropertiesHTMLElement(this.node);\r\n    if (!defaultNames.has(this.name)) return;\r\n    \r\n    if (decorates.length > 1) {\r\n      raiseError({\r\n        code: \"BIND-201\",\r\n        message: \"Has multiple decorators\",\r\n        context: { where: \"BindingNodeProperty.constructor\", name: this.name, decoratesCount: decorates.length },\r\n        docsUrl: \"/docs/error-codes.md#bind\",\r\n        severity: \"error\",\r\n      });\r\n    }\r\n    \r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? defaultEventByName[this.name] ?? \"readonly\";\r\n    \r\n    if (eventName === \"readonly\" || eventName === \"ro\") return;\r\n\r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, async () => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      const value = this.filteredValue;\r\n      createUpdater<void>(engine, (updater) => {\r\n        updater.update(loopContext, (state, handler) => {\r\n          binding.updateStateValue(state, handler, value);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Assigns value to property, converting null/undefined/NaN to empty string.\r\n   * \r\n   * @param value - Value to assign to property\r\n   */\r\n  assignValue(value: any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    // @ts-ignore\r\n    this.node[this.name] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create BindingNodeProperty instances.\r\n * \r\n * @param name - Property name (e.g., \"value\", \"checked\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n * @returns Function that creates BindingNodeProperty with binding, node, and filters\r\n */\r\nexport const createBindingNodeProperty: CreateBindingNodeFn =\r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) =>\r\n    (binding: IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      return new BindingNodeProperty(binding, node, name, \"\", filterFns, decorates);\r\n    };\r\n\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeRadio class implements binding processing for radio buttons.\r\n * - Controls checked state by comparing binding value with input element value\r\n * - Supports bidirectional binding (auto-updates state on user selection)\r\n * - Converts null/undefined to empty string for comparison\r\n */\r\nclass BindingNodeRadio extends BindingNode {\r\n  /**\r\n   * Returns raw value attribute of radio input element.\r\n   * \r\n   * @returns Value attribute string\r\n   */\r\n  get value(): any {\r\n    const element = this.node as HTMLInputElement;\r\n    return element.value;\r\n  }\r\n  \r\n  /**\r\n   * Returns value with all filters applied.\r\n   * \r\n   * @returns Filtered value\r\n   */\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for (let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  \r\n  /**\r\n   * Constructor sets up radio button bidirectional binding.\r\n   * - Validates decorates count (max 1)\r\n   * - Registers event listener for state updates (skipped if readonly/ro)\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node (should be HTMLInputElement with type=\"radio\")\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n   * @throws BIND-201 Has multiple decorators\r\n   */\r\n  constructor(\r\n    binding: IBinding,\r\n    node: Node,\r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[],\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n\r\n    const isInputElement = this.node instanceof HTMLInputElement;\r\n    if (!isInputElement) return;\r\n    const inputElement = this.node as HTMLInputElement;\r\n    if (inputElement.type !== \"radio\") return;\r\n    \r\n    if (decorates.length > 1) {\r\n      raiseError({\r\n        code: \"BIND-201\",\r\n        message: \"Has multiple decorators\",\r\n        context: { where: \"BindingNodeRadio.constructor\", name: this.name, decoratesCount: decorates.length },\r\n        docsUrl: \"/docs/error-codes.md#bind\",\r\n        severity: \"error\",\r\n      });\r\n    }\r\n    \r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? \"input\";\r\n    \r\n    if (eventName === \"readonly\" || eventName === \"ro\") return;\r\n    \r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, async (e) => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      const value = this.filteredValue;\r\n      createUpdater<void>(engine, (updater) => {\r\n        updater.update(loopContext, (state, handler) => {\r\n          binding.updateStateValue(state, handler, value);\r\n        });\r\n      });\r\n    });\r\n\r\n  }\r\n  \r\n  /**\r\n   * Sets checked state by comparing binding value with filteredValue.\r\n   * Converts null/undefined to empty string for comparison.\r\n   * \r\n   * @param value - Value from state binding\r\n   */\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined) {\r\n      value = \"\";\r\n    }\r\n    \r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value === this.filteredValue;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate radio button binding node.\r\n * \r\n * @param name - Binding name\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n * @returns Function that creates BindingNodeRadio with binding, node, and filters\r\n */\r\nexport const createBindingNodeRadio: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      return new BindingNodeRadio(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeStyle class implements binding processing for style attributes.\r\n * - Extracts CSS property name (subName) from name and sets value with style.setProperty\r\n * - Converts null/undefined/NaN to empty string\r\n */\r\nclass BindingNodeStyle extends BindingNode {\r\n  /**\r\n   * Sets CSS property value. Converts null/undefined/NaN to empty string.\r\n   * \r\n   * @param value - Value to assign to CSS property\r\n   */\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    \r\n    const element = this.node as HTMLElement;\r\n    element.style.setProperty(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate style attribute binding node.\r\n * \r\n * @param name - Binding name (e.g., \"style.color\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeStyle with binding, node, and filters\r\n */\r\nexport const createBindingNodeStyle: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      const [, subName] = name.split(\".\");\r\n      return new BindingNodeStyle(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n\r\n\r\n","const symbolName = \"component-state-input\";\r\n\r\nexport const AssignStateSymbol: unique symbol = Symbol.for(`${symbolName}.AssignState`);\r\nexport const NotifyRedrawSymbol: unique symbol = Symbol.for(`${symbolName}.NotifyRedraw`);","import { StructiveComponent } from \"./types\";\r\n\r\nconst parentStructiveComponentByStructiveComponent = new WeakMap<StructiveComponent, StructiveComponent>();\r\n\r\nexport function findStructiveParent(el:StructiveComponent): StructiveComponent | null {\r\n  return parentStructiveComponentByStructiveComponent.get(el) ?? null;\r\n}\r\n\r\nexport function registerStructiveComponent(parentComponent: StructiveComponent, component: StructiveComponent): void {\r\n  parentStructiveComponentByStructiveComponent.set(component, parentComponent);\r\n}\r\n\r\nexport function removeStructiveComponent(component: StructiveComponent): void {\r\n  parentStructiveComponentByStructiveComponent.delete(component);\r\n}","import { raiseError } from \"../utils\";\r\n\r\nexport function getCustomTagName(component: HTMLElement): string {\r\n  if (component.tagName.includes('-')) {\r\n    return component.tagName.toLowerCase();\r\n  } else if (component.getAttribute('is')?.includes('-')) {\r\n    return component.getAttribute('is')!.toLowerCase();\r\n  } else {\r\n    raiseError({\r\n      code: 'CE-001',\r\n      message: 'Custom tag name not found',\r\n      context: { where: 'ComponentEngine.customTagName.get' },\r\n      docsUrl: './docs/error-codes.md#ce',\r\n    });\r\n  }\r\n\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { NotifyRedrawSymbol } from \"../../ComponentStateInput/symbols.js\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { registerStructiveComponent, removeStructiveComponent } from \"../../WebComponents/findStructiveParent.js\";\r\nimport { getCustomTagName } from \"../../WebComponents/getCustomTagName.js\";\r\nimport { StructiveComponent } from \"../../WebComponents/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeComponent class implements binding processing to StructiveComponent (custom component).\r\n *\r\n * Responsibilities:\r\n * - Binds parent component state to child component state property\r\n * - Propagates state changes via NotifyRedrawSymbol\r\n * - Manages parent-child component relationships and lifecycle\r\n *\r\n * @throws COMP-401 Cannot determine custom element tag name: When tag name cannot be determined\r\n */\r\nclass BindingNodeComponent extends BindingNode {\r\n  tagName: string;\r\n  \r\n  /**\r\n   * Determines custom element tag name from element's tagName or is attribute.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Custom element node\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name (component state property)\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators\r\n   * @throws COMP-401 Cannot determine custom element tag name\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    \r\n    const element = this.node as HTMLElement;\r\n    if (element.tagName.includes(\"-\")) {\r\n      this.tagName = element.tagName.toLowerCase();\r\n    } \r\n    else if (element.getAttribute(\"is\")?.includes(\"-\")) {\r\n      this.tagName = element.getAttribute(\"is\")!.toLowerCase();\r\n    } \r\n    else {\r\n      raiseError({\r\n        code: 'COMP-401',\r\n        message: 'Cannot determine custom element tag name',\r\n        context: { where: 'BindingNodeComponent.constructor' },\r\n        docsUrl: '/docs/error-codes.md#comp',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends redraw notification to child component after custom element is defined.\r\n   * \r\n   * @param refs - Array of state property references to notify\r\n   */\r\n  _notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    const component = this.node as StructiveComponent;\r\n    const tagName = getCustomTagName(component);\r\n    customElements.whenDefined(tagName).then(() => {\r\n      component.state[NotifyRedrawSymbol](refs);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Filters and propagates only related references to child component.\r\n   * Skips refs that:\r\n   * 1. Match this binding's pattern (already processed by applyChange)\r\n   * 2. Are not in cumulative path set\r\n   * 3. Have mismatched loop indices\r\n   * \r\n   * @param refs - Array of state property references to filter and propagate\r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    const notifyRefs: IStatePropertyRef[] = [];\r\n    const compRef = this.binding.bindingState.ref;\r\n    const listIndex = compRef.listIndex;\r\n    const atIndex = (listIndex?.length ?? 0) - 1;\r\n    \r\n    for(const ref of refs) {\r\n      if (ref.info.pattern === compRef.info.pattern) {\r\n        continue;\r\n      }\r\n      if (!ref.info.cumulativePathSet.has(compRef.info.pattern)) {\r\n        continue;\r\n      }\r\n      if (atIndex >= 0) {\r\n        if (ref.listIndex?.at(atIndex) !== listIndex) {\r\n          continue;\r\n        }\r\n      }\r\n      notifyRefs.push(ref);\r\n    }\r\n    \r\n    if (notifyRefs.length === 0) {\r\n      return;\r\n    }\r\n    this._notifyRedraw(notifyRefs);\r\n  }\r\n\r\n  /**\r\n   * Notifies child component of this binding's state change.\r\n   * \r\n   * @param renderer - Renderer instance\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    this._notifyRedraw([this.binding.bindingState.ref]);\r\n  }\r\n\r\n  /**\r\n   * Registers parent-child component relationship and adds binding to tracking structures.\r\n   */\r\n  activate(): void {\r\n    const engine = this.binding.engine;\r\n    const parentComponent = engine.owner;\r\n    const component = this.node as StructiveComponent;\r\n\r\n    const tagName = getCustomTagName(component);\r\n    customElements.whenDefined(tagName).then(() => {\r\n      parentComponent.registerChildComponent(component);\r\n      component.stateBinding.addBinding(this.binding);\r\n    });\r\n\r\n    registerStructiveComponent(parentComponent, component);\r\n    \r\n    let bindings = engine.bindingsByComponent.get(component);\r\n    if (typeof bindings === \"undefined\") {\r\n      engine.bindingsByComponent.set(component, bindings = new Set<IBinding>());\r\n    }\r\n    bindings.add(this.binding);\r\n  }\r\n\r\n  /**\r\n   * Unregisters component relationships and cleans up binding tracking.\r\n   */\r\n  inactivate(): void {\r\n    const engine = this.binding.engine;\r\n    removeStructiveComponent(this.node as StructiveComponent);\r\n    \r\n    let bindings = engine.bindingsByComponent.get(this.node as StructiveComponent);\r\n    if (typeof bindings !== \"undefined\") {\r\n      bindings.delete(this.binding);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Factory function to generate component binding node.\r\n * \r\n * @param name - Binding name (e.g., \"component.stateProp\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeComponent with binding, node, and filters\r\n */\r\nexport const createBindingNodeComponent: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      const [, subName] = name.split(\".\");\r\n      return new BindingNodeComponent(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","import { createBindingNodeAttribute } from \"../DataBinding/BindingNode/BindingNodeAttribute.js\";\r\nimport { createBindingNodeCheckbox } from \"../DataBinding/BindingNode/BindingNodeCheckbox.js\";\r\nimport { createBindingNodeClassList } from \"../DataBinding/BindingNode/BindingNodeClassList.js\";\r\nimport { createBindingNodeClassName } from \"../DataBinding/BindingNode/BindingNodeClassName.js\";\r\nimport { createBindingNodeEvent } from \"../DataBinding/BindingNode/BindingNodeEvent.js\";\r\nimport { createBindingNodeIf } from \"../DataBinding/BindingNode/BindingNodeIf.js\";\r\nimport { createBindingNodeFor } from \"../DataBinding/BindingNode/BindingNodeFor.js\";\r\nimport { createBindingNodeProperty } from \"../DataBinding/BindingNode/BindingNodeProperty.js\";\r\nimport { createBindingNodeRadio } from \"../DataBinding/BindingNode/BindingNodeRadio.js\";\r\nimport { createBindingNodeStyle } from \"../DataBinding/BindingNode/BindingNodeStyle.js\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn } from \"../DataBinding/BindingNode/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\nimport { createBindingNodeComponent } from \"../DataBinding/BindingNode/BindingNodeComponent.js\";\r\n\r\n/**\r\n * Map of binding node creator functions keyed by property name\r\n */\r\ntype NodePropertyConstructorByName = { [key: string]: CreateBindingNodeFn };\r\n\r\n/**\r\n * Two-level map with comment node flag (0=Element, 1=Comment) as key,\r\n * containing property name maps\r\n */\r\ntype NodePropertyConstructorByNameByIsComment = { [key: number]: NodePropertyConstructorByName };\r\n\r\n/**\r\n * Map defining specific binding node creator functions by combination of\r\n * node type (Element/Comment) and property name\r\n * \r\n * Index 0 (Element): Element-specific bindings\r\n *   - \"class\": classList manipulation (class attribute token list operations)\r\n *   - \"checkbox\": Checkbox checked state binding\r\n *   - \"radio\": Radio button checked state binding\r\n * \r\n * Index 1 (Comment): Comment node-specific bindings\r\n *   - \"if\": Conditional binding (element show/hide)\r\n */\r\nconst nodePropertyConstructorByNameByIsComment: NodePropertyConstructorByNameByIsComment = {\r\n  0: {\r\n    \"class\"   : createBindingNodeClassList,\r\n    \"checkbox\": createBindingNodeCheckbox,\r\n    \"radio\"   : createBindingNodeRadio,\r\n  },\r\n  1: {\r\n    \"if\" : createBindingNodeIf,\r\n  },\r\n};\r\n\r\n/**\r\n * Map of binding node creator functions keyed by property name prefix\r\n */\r\ntype NodePropertyConstructorByFirstName = { [key: string]: CreateBindingNodeFn };\r\n\r\n/**\r\n * Map of binding node creator functions determined by property name prefix\r\n * (first element before dot separator)\r\n * \r\n * Supported patterns:\r\n *   - \"class.xxx\": className binding (set entire class attribute)\r\n *   - \"attr.xxx\": attribute binding (set arbitrary attribute)\r\n *   - \"style.xxx\": style binding (set inline style)\r\n *   - \"state.xxx\": component state binding (pass state to child component)\r\n * \r\n * Examples:\r\n *   - \"class.active\" → BindingNodeClassName (set class attribute to \"active\")\r\n *   - \"attr.src\" → BindingNodeAttribute (set src attribute)\r\n *   - \"style.color\" → BindingNodeStyle (set color style)\r\n *   - \"state.user\" → BindingNodeComponent (pass value to child component's user state)\r\n */\r\nconst nodePropertyConstructorByFirstName: NodePropertyConstructorByFirstName = {\r\n  \"class\": createBindingNodeClassName,\r\n  \"attr\" : createBindingNodeAttribute,\r\n  \"style\": createBindingNodeStyle,\r\n  \"state\": createBindingNodeComponent,\r\n//  \"popover\": PopoverTarget,      // For future extension\r\n//  \"commandfor\": CommandForTarget, // For future extension\r\n};\r\n\r\n/**\r\n * Internal function that returns the appropriate binding node creator function\r\n * (CreateBindingNodeFn) based on target node type (Element/Comment) and property name.\r\n * \r\n * Decision logic (in priority order):\r\n * 1. Exact match by node type and property name (nodePropertyConstructorByNameByIsComment)\r\n *    - Element: \"class\", \"checkbox\", \"radio\"\r\n *    - Comment: \"if\"\r\n * \r\n * 2. Comment node with \"for\" → createBindingNodeFor\r\n * \r\n * 3. Comment node with unknown property → Error\r\n * \r\n * 4. Match by property name prefix (nodePropertyConstructorByFirstName)\r\n *    - \"class.xxx\", \"attr.xxx\", \"style.xxx\", \"state.xxx\"\r\n * \r\n * 5. Element node starting with \"on\" → createBindingNodeEvent\r\n *    - Examples: \"onclick\", \"onchange\", \"onkeydown\"\r\n * \r\n * 6. Others → createBindingNodeProperty (generic property binding)\r\n *    - Examples: \"value\", \"textContent\", \"disabled\", \"innerHTML\"\r\n * \r\n * @param isComment - Whether it's a comment node\r\n * @param isElement - Whether it's an element node\r\n * @param propertyName - Binding property name\r\n * @returns Binding node creator function\r\n * @throws When property name is invalid\r\n */\r\nfunction _getBindingNodeCreator(isComment: boolean, isElement: boolean, propertyName: string): CreateBindingNodeFn {\r\n  // Step 1: Get dedicated creator function by exact match of node type and property name\r\n  const bindingNodeCreatorByName = nodePropertyConstructorByNameByIsComment[isComment ? 1 : 0][propertyName];\r\n  if (typeof bindingNodeCreatorByName !== \"undefined\") {\r\n    return bindingNodeCreatorByName;\r\n  }\r\n\r\n  // Step 2: For comment node with \"for\", use dedicated loop binding\r\n  if (isComment && propertyName === \"for\") {\r\n    return createBindingNodeFor;\r\n  }\r\n\r\n  // Step 3: Error for unsupported properties on comment node\r\n  // (Only \"if\" and \"for\" are allowed on comment nodes)\r\n  if (isComment) {\r\n    raiseError(`getBindingNodeCreator: unknown node property ${propertyName}`);\r\n  }\r\n\r\n  // Step 4: Determine by property name prefix (first part before dot)\r\n  // Example: \"attr.src\" → nameElements[0] = \"attr\"\r\n  const nameElements = propertyName.split(\".\");\r\n  const bindingNodeCreatorByFirstName = nodePropertyConstructorByFirstName[nameElements[0]];\r\n  if (typeof bindingNodeCreatorByFirstName !== \"undefined\") {\r\n    return bindingNodeCreatorByFirstName;\r\n  }\r\n\r\n  // Step 5: For element node starting with \"on\", use event binding\r\n  // Examples: \"onclick\", \"onchange\", \"onsubmit\"\r\n  if (isElement) {\r\n    if (propertyName.startsWith(\"on\")) {\r\n      return createBindingNodeEvent;\r\n    } else {\r\n      // Step 6a: Other element properties use generic property binding\r\n      // Examples: \"value\", \"textContent\", \"disabled\"\r\n      return createBindingNodeProperty;\r\n    }\r\n  } else {\r\n    // Step 6b: For nodes that are neither element nor comment (Text nodes, etc.), use generic binding\r\n    return createBindingNodeProperty;\r\n  }\r\n}\r\n\r\n/**\r\n * Cache for binding node creator functions\r\n * Key format: \"{isComment}\\t{isElement}\\t{propertyName}\"\r\n * \r\n * When the same combination of node type and property name is used multiple times,\r\n * retrieve from cache instead of re-executing decision logic to improve performance\r\n */\r\nconst _cache: { [key: string]: CreateBindingNodeFn } = {};\r\n\r\n/**\r\n * Factory function that retrieves the appropriate binding node creator function\r\n * from node, property name, filter, and decorator information.\r\n * \r\n * Processing flow:\r\n * 1. Determine node type (Comment/Element)\r\n * 2. Generate cache key (\"{isComment}\\t{isElement}\\t{propertyName}\")\r\n * 3. Check cache, if not exists, get via _getBindingNodeCreator and cache it\r\n * 4. Execute obtained creator function with property name, filters, and decorates\r\n * 5. Return actual binding node creator function (CreateBindingNodeByNodeFn)\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * const node = document.querySelector('input');\r\n * const creator = getBindingNodeCreator(\r\n *   node,\r\n *   'value',\r\n *   [{ name: 'trim', options: [] }],\r\n *   ['required']\r\n * );\r\n * // creator is a function like (binding, node, filters) => BindingNodeProperty\r\n * ```\r\n * \r\n * @param node - Target DOM node for binding\r\n * @param propertyName - Binding property name (e.g., \"value\", \"onclick\", \"attr.src\")\r\n * @param filterTexts - Array of input filter metadata\r\n * @param decorates - Array of decorators (e.g., [\"required\", \"trim\"])\r\n * @returns Function that creates actual binding node instance\r\n */\r\nexport function getBindingNodeCreator(\r\n  node        : Node, \r\n  propertyName: string,\r\n  filterTexts : IFilterText[],\r\n  decorates   : string[]\r\n): CreateBindingNodeByNodeFn {\r\n  // Determine node type\r\n  const isComment = node instanceof Comment;\r\n  const isElement = node instanceof Element;\r\n  \r\n  // Generate cache key (concatenate with tab separator)\r\n  const key = isComment + \"\\t\" + isElement + \"\\t\" + propertyName;\r\n  \r\n  // Get from cache, if not exists, determine and save to cache\r\n  const fn = _cache[key] ?? (_cache[key] = _getBindingNodeCreator(isComment, isElement, propertyName));\r\n  \r\n  // Execute obtained creator function with property name, filters, and decorates\r\n  return fn(propertyName, filterTexts, decorates);\r\n}\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { ILoopContext } from \"../../LoopContext/types.js\";\r\nimport { getByRef } from \"../../StateClass/methods/getByRef.js\";\r\nimport { setByRef } from \"../../StateClass/methods/setByRef.js\";\r\nimport { IStateHandler, IStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingState class manages state property access, filtering, and updates for bindings.\r\n * - Supports wildcard paths for array bindings with dynamic index resolution\r\n * - Handles bidirectional binding via assignValue\r\n */\r\nclass BindingState implements IBindingState {\r\n  readonly pattern: string;\r\n  readonly info: IStructuredPathInfo;\r\n  readonly filters: Filters;\r\n  readonly isLoopIndex: boolean = false;\r\n\r\n  private _binding: IBinding;\r\n  private _nullRef: IStatePropertyRef | null = null;\r\n  private _ref: IStatePropertyRef | null = null;\r\n  private _loopContext: ILoopContext | null = null;\r\n\r\n  /**\r\n   * Constructor initializes BindingState for property binding.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param pattern - State property pattern (e.g., \"user.name\", \"items.*.value\")\r\n   * @param filters - Filter functions to apply\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this._binding = binding;\r\n    this.pattern = pattern;\r\n    this.info = getStructuredPathInfo(pattern);\r\n    this.filters = filters;\r\n    this._nullRef = (this.info.wildcardCount === 0) ? getStatePropertyRef(this.info, null) : null;\r\n  }\r\n\r\n  /**\r\n   * Returns list index from state property reference.\r\n   * \r\n   * @returns IListIndex or null\r\n   */\r\n  get listIndex() {\r\n    return this.ref.listIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns state property reference, dynamically resolved for wildcard paths.\r\n   * \r\n   * @returns IStatePropertyRef instance\r\n   * @throws BIND-201 LoopContext is null or ref is null\r\n   */\r\n  get ref() {\r\n    if (this._nullRef === null) {\r\n      if (this._loopContext === null) {\r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'LoopContext is null',\r\n          context: { pattern: this.pattern },\r\n          docsUrl: '/docs/error-codes.md#bind',\r\n          severity: 'error',\r\n        });\r\n      }\r\n      if (this._ref === null) {\r\n        this._ref = getStatePropertyRef(this.info, this._loopContext.listIndex);\r\n      }\r\n      return this._ref;\r\n    } else {\r\n      return this._nullRef ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ref is null',\r\n        context: { pattern: this.pattern },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves raw value from state without applying filters.\r\n   * \r\n   * @param state - State proxy\r\n   * @param handler - State handler\r\n   * @returns Raw value from state\r\n   */\r\n  getValue(state:IStateProxy, handler:IStateHandler): any {\r\n    return getByRef(this._binding.engine.state, this.ref, state, handler);\r\n  }\r\n\r\n  /**\r\n   * Retrieves value from state and applies all filters.\r\n   * \r\n   * @param state - State proxy\r\n   * @param handler - State handler\r\n   * @returns Filtered value\r\n   */\r\n  getFilteredValue(state:IStateProxy, handler:IStateHandler): any {\r\n    let value = getByRef(this._binding.engine.state, this.ref, state, handler);\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Assigns value to state (for bidirectional binding).\r\n   * \r\n   * @param writeState - Writable state proxy\r\n   * @param handler - Writable state handler\r\n   * @param value - Value to assign\r\n   */\r\n  assignValue(writeState: IWritableStateProxy, handler: IWritableStateHandler, value: any) {\r\n    setByRef(this._binding.engine.state, this.ref, value, writeState, handler);\r\n  }\r\n\r\n\r\n  /**\r\n   * Activates binding. Resolves loop context for wildcard bindings.\r\n   * \r\n   * @throws BIND-201 Wildcard last parentPath is null or LoopContext is null\r\n   */\r\n  activate(): void {\r\n    if (this.info.wildcardCount > 0) {\r\n      const lastWildcardPath = this.info.lastWildcardPath ?? \r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'Wildcard last parentPath is null',\r\n          context: { where: 'BindingState.init', pattern: this.pattern },\r\n          docsUrl: '/docs/error-codes.md#bind',\r\n          severity: 'error',\r\n        });\r\n      this._loopContext = this._binding.parentBindContent.currentLoopContext?.find(lastWildcardPath) ?? \r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'LoopContext is null',\r\n          context: { where: 'BindingState.init', lastWildcardPath },\r\n          docsUrl: '/docs/error-codes.md#bind',\r\n          severity: 'error',\r\n        });\r\n    }\r\n    this._binding.engine.saveBinding(this.ref, this._binding);\r\n  }\r\n\r\n  /**\r\n   * Inactivates binding and clears references.\r\n   */\r\n  inactivate() {\r\n    this._binding.engine.removeBinding(this.ref, this._binding);\r\n    this._ref = null;\r\n    this._loopContext = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate BindingState instance.\r\n * \r\n * @param name - State property pattern\r\n * @param filterTexts - Array of filter text definitions\r\n * @returns Function that creates BindingState with binding and filters\r\n */\r\nexport const createBindingState: CreateBindingStateFn = \r\n  (name: string, filterTexts: IFilterText[]) => \r\n    (binding:IBinding, filters:FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      return new BindingState(binding, name, filterFns);\r\n    }\r\n\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { ILoopContext } from \"../../LoopContext/types.js\";\r\nimport { IStateHandler, IStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingStateIndex manages binding state for loop index values ($1, $2, ...).\r\n * - Extracts index from loop context, supports filtering\r\n * - Read-only (assignValue not implemented)\r\n */\r\nclass BindingStateIndex implements IBindingState {\r\n  readonly filters: Filters;\r\n\r\n  private _binding: IBinding;\r\n  private _indexNumber: number;\r\n  private _loopContext: ILoopContext | null = null;\r\n\r\n  /**\r\n   * Constructor initializes BindingStateIndex for loop index binding.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param pattern - Index pattern string (e.g., \"$1\", \"$2\")\r\n   * @param filters - Filter functions to apply\r\n   * @throws BIND-202 Pattern is not a number\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this._binding = binding;\r\n    const indexNumber = Number(pattern.slice(1));\r\n    if (isNaN(indexNumber)) {\r\n      raiseError({\r\n        code: 'BIND-202',\r\n        message: 'Pattern is not a number',\r\n        context: { where: 'BindingStateIndex.constructor', pattern },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    this._indexNumber = indexNumber;\r\n    this.filters = filters;\r\n  }\r\n\r\n  /**\r\n   * Not implemented for index binding.\r\n   * \r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  get pattern(): string {\r\n    return raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingStateIndex.pattern' },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  /**\r\n   * Not implemented for index binding.\r\n   * \r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  get info() {\r\n    return raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingStateIndex.info' },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns list index from current loop context.\r\n   * \r\n   * @returns IListIndex instance\r\n   * @throws LIST-201 listIndex is null\r\n   */\r\n  get listIndex() {\r\n    return this._loopContext?.listIndex ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: { where: 'BindingStateIndex.listIndex' },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns state property reference from loop context.\r\n   * \r\n   * @returns IStatePropertyRef instance\r\n   * @throws STATE-202 ref is null\r\n   */\r\n  get ref() {\r\n    return this._loopContext?.ref ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'ref is null',\r\n      context: { where: 'BindingStateIndex.ref' },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Always returns true for index binding.\r\n   * \r\n   * @returns true\r\n   */\r\n  get isLoopIndex() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns raw index value from list index.\r\n   * \r\n   * @param state - State proxy (unused)\r\n   * @param handler - State handler (unused)\r\n   * @returns Index number\r\n   * @throws LIST-201 listIndex is null\r\n   */\r\n  getValue(state: IStateProxy, handler: IStateHandler) {\r\n    return this.listIndex?.index ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: { where: 'BindingStateIndex.getValue' },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns filtered index value.\r\n   * \r\n   * @param state - State proxy (unused)\r\n   * @param handler - State handler (unused)\r\n   * @returns Filtered index value\r\n   * @throws LIST-201 listIndex is null\r\n   */\r\n  getFilteredValue(state: IStateProxy, handler: IStateHandler) {\r\n    let value = this.listIndex?.index ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: { where: 'BindingStateIndex.getFilteredValue' },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n\r\n  /**\r\n   * Not implemented (index is read-only).\r\n   * \r\n   * @param writeState - Writable state proxy (unused)\r\n   * @param handler - Writable state handler (unused)\r\n   * @param value - Value to assign (unused)\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  assignValue(writeState:IWritableStateProxy, handler:IWritableStateHandler, value:any): void {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingStateIndex.assignValue' },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Activates binding. Resolves loop context and registers to bindingsByListIndex.\r\n   * \r\n   * @throws BIND-201 LoopContext is null or binding for list is null\r\n   */\r\n  activate(): void {\r\n    const loopContext = this._binding.parentBindContent.currentLoopContext ??\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'LoopContext is null',\r\n        context: { where: 'BindingStateIndex.init' },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n    const loopContexts = loopContext.serialize();\r\n    this._loopContext = loopContexts[this._indexNumber - 1] ??\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Current loopContext is null',\r\n        context: { where: 'BindingStateIndex.init', indexNumber: this._indexNumber },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n    const bindingForList = this._loopContext.bindContent.parentBinding;\r\n    if (bindingForList == null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Binding for list is null',\r\n        context: { where: 'BindingStateIndex.init' },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    const bindings = bindingForList.bindingsByListIndex.get(this.listIndex);\r\n    if (typeof bindings === \"undefined\") {\r\n      bindingForList.bindingsByListIndex.set(this.listIndex, new Set([this._binding]));\r\n    } else {\r\n      bindings.add(this._binding);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inactivates binding and clears loop context reference.\r\n   */\r\n  inactivate(): void {\r\n    this._loopContext = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate BindingStateIndex instance.\r\n * \r\n * @param name - Index pattern string (e.g., \"$1\", \"$2\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @returns Function that creates BindingStateIndex with binding and filters\r\n */\r\nexport const createBindingStateIndex: CreateBindingStateFn = \r\n  (name: string, filterTexts: IFilterText[]) => \r\n    (binding:IBinding, filters:FilterWithOptions) => {\r\n      const filterFns = createFilters(filters, filterTexts);\r\n      return new BindingStateIndex(binding, name, filterFns);\r\n    }\r\n\r\n","import { createBindingState } from \"../DataBinding/BindingState/BindingState.js\";\r\nimport { createBindingStateIndex } from \"../DataBinding/BindingState/BindingStateIndex.js\";\r\nimport { CreateBindingStateByStateFn } from \"../DataBinding/BindingState/types\";\r\nimport { IFilterText } from \"./types\";\r\n\r\n/**\r\n * Regular expression to identify index references within loop context\r\n * Pattern: \"$\" + digit (e.g., \"$1\", \"$2\", \"$3\")\r\n * \r\n * Hierarchy structure (1-based, from outer to inner):\r\n * - \"$1\": Index of outermost loop\r\n * - \"$2\": Index of one level inner loop\r\n * - \"$3\": Index of further inner loop\r\n * \r\n * Usage example (nested loops):\r\n * ```\r\n * <ul data-bind=\"for:categories\">              ← $1\r\n *   <li>\r\n *     <ul data-bind=\"for:categories.*.items\">  ← $2 (child list is property of parent list element)\r\n *       <li data-bind=\"text:$1\">...            ← categories index\r\n *       <li data-bind=\"text:$2\">...            ← items index\r\n *     </ul>\r\n *   </li>\r\n * </ul>\r\n * ```\r\n * \r\n * Note: In nested loops, child list must be defined as property of parent list element\r\n * (e.g., categories.*.items means categories[i].items)\r\n */\r\nconst ereg = new RegExp(/^\\$\\d+$/);\r\n\r\n/**\r\n * Factory function that returns the appropriate binding state creator function\r\n * (CreateBindingStateByStateFn) from target state property name and filter information.\r\n *\r\n * Decision logic:\r\n * 1. Check if property name matches \"$digit\" pattern with regex\r\n *    - If matches: Use createBindingStateIndex\r\n *      Loop index binding (e.g., $1, $2 inside for statement)\r\n *    - If not matches: Use createBindingState\r\n *      Normal state property binding (e.g., user.name)\r\n * \r\n * 2. Execute creator function with filter information\r\n * \r\n * 3. Return function that creates actual binding state instance\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Normal property binding\r\n * const creator1 = getBindingStateCreator('user.name', []);\r\n * // creator1 generates normal BindingState\r\n * \r\n * // Outermost loop index binding\r\n * const creator2 = getBindingStateCreator('$1', []);\r\n * // creator2 generates BindingStateIndex (accesses outermost loop index value)\r\n * \r\n * // Inner loop index in nested loops\r\n * const creator3 = getBindingStateCreator('$2', []);\r\n * // creator3 accesses index of one level inner loop\r\n * ```\r\n * \r\n * @param name - Target state property name (e.g., \"user.name\", \"$1\", \"$2\")\r\n * @param filterTexts - Array of output filter metadata (node→state direction)\r\n * @returns Function that creates actual binding state instance\r\n */\r\nexport function getBindingStateCreator(\r\n  name       : string, \r\n  filterTexts: IFilterText[]\r\n): CreateBindingStateByStateFn {\r\n  // Check if property name matches \"$digit\" pattern\r\n  if (ereg.test(name)) {\r\n    // Return creator function for loop index binding\r\n    // \"$1\" → Outermost loop index (1-based)\r\n    // \"$2\" → One level inner loop index\r\n    // \"$3\" → Further inner loop index\r\n    // ...and so on, proceeding inward\r\n    return createBindingStateIndex(name, filterTexts);\r\n  } else {\r\n    // Return standard binding state creator function for normal property names\r\n    // Examples: \"user.name\", \"items\", \"isVisible\"\r\n    return createBindingState(name, filterTexts);\r\n  }\r\n}","import { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\n/**\r\n * Creates cache key from node (internal function).\r\n * \r\n * Key composition:\r\n * - Constructor name (e.g., \"Comment\", \"HTMLDivElement\", \"SVGCircleElement\")\r\n * - Tab character (\"\\t\")\r\n * - For comment nodes: character at textContent[2] (\":\" or \"|\")\r\n * - For other nodes: empty string\r\n * \r\n * Examples:\r\n * - Comment(\"@@:user.name\") → \"Comment\\t:\"\r\n * - Comment(\"@@|123\") → \"Comment\\t|\"\r\n * - HTMLDivElement → \"HTMLDivElement\\t\"\r\n * - SVGCircleElement → \"SVGCircleElement\\t\"\r\n * \r\n * @param node - Node to generate key from\r\n * @returns Cache key string\r\n */\r\nconst createNodeKey = (node: Node): string => \r\n  node.constructor.name + \"\\t\" + ((node instanceof Comment) ? (node.textContent?.[2] ?? \"\") : \"\");\r\n\r\n/**\r\n * Cache of NodeType values keyed by node key\r\n * When the same type of node is determined multiple times, skip re-determination to improve performance\r\n */\r\ntype NodeTypeByNodeKey = {\r\n  [nodeKey: string]: NodeType;\r\n};\r\n\r\nconst nodeTypeByNodeKey: NodeTypeByNodeKey = {};\r\n\r\n/**\r\n * Internal function that actually determines NodeType from node.\r\n * \r\n * Decision logic (in priority order):\r\n * 1. Comment and textContent[2] === \":\" → \"Text\"\r\n *    - Example: \"@@:user.name\" → Text content binding\r\n * \r\n * 2. HTMLElement → \"HTMLElement\"\r\n *    - Example: <div>, <input>, <span>, etc.\r\n * \r\n * 3. Comment and textContent[2] === \"|\" → \"Template\"\r\n *    - Example: \"@@|123\" → Template reference binding\r\n * \r\n * 4. SVGElement → \"SVGElement\"\r\n *    - Example: <circle>, <path>, <rect>, etc.\r\n * \r\n * 5. Others → Error\r\n * \r\n * Note: Why HTMLElement check comes before SVGElement\r\n * → Checking HTMLElement first allows faster processing of more common cases\r\n * \r\n * @param node - Node to determine\r\n * @returns Node type\r\n * @throws When node type is unknown\r\n */\r\nconst getNodeTypeByNode = (node: Node): NodeType =>\r\n  (node instanceof Comment && node.textContent?.[2] === \":\") ? \"Text\" : \r\n  (node instanceof HTMLElement) ? \"HTMLElement\" :\r\n  (node instanceof Comment && node.textContent?.[2] === \"|\") ? \"Template\" : \r\n  (node instanceof SVGElement) ? \"SVGElement\" : \r\n  raiseError({\r\n    code: 'BND-001',\r\n    message: `Unknown NodeType: ${node.nodeType}`,\r\n    context: { \r\n      where: 'getNodeType.getNodeTypeByNode',\r\n      nodeType: node.nodeType,\r\n      nodeName: node.nodeName,\r\n      nodeConstructor: node.constructor.name\r\n    },\r\n    docsUrl: './docs/error-codes.md#bnd'\r\n  });\r\n\r\n/**\r\n * Utility function that determines node type (\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\")\r\n * and uses cache for performance optimization.\r\n *\r\n * Node type determination criteria:\r\n * 1. Text: Comment node with textContent[2] === \":\"\r\n *    - Comment starting with \"@@:\" → Text content binding\r\n *    - Example: <!--@@:user.name--> → \"Text\"\r\n * \r\n * 2. Template: Comment node with textContent[2] === \"|\"\r\n *    - Comment starting with \"@@|\" → Template reference binding\r\n *    - Example: <!--@@|123--> → \"Template\"\r\n * \r\n * 3. HTMLElement: Regular HTML element\r\n *    - Example: <div>, <input>, <span> → \"HTMLElement\"\r\n * \r\n * 4. SVGElement: SVG element\r\n *    - Example: <circle>, <path>, <rect> → \"SVGElement\"\r\n * \r\n * Cache mechanism:\r\n * - Generate key from node (constructor name + comment type)\r\n * - Same key nodes return from cache on second and subsequent calls\r\n * - Performance improvement (especially when processing large number of nodes)\r\n * \r\n * Processing flow:\r\n * 1. Generate cache key from node (or get from argument)\r\n * 2. Check cache\r\n * 3. Cache hit → Return saved value\r\n * 4. Cache miss → Determine with getNodeTypeByNode, save to cache, then return\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Text binding comment\r\n * const comment1 = document.createComment(\"@@:user.name\");\r\n * getNodeType(comment1); // → \"Text\"\r\n * \r\n * // Template reference comment\r\n * const comment2 = document.createComment(\"@@|123\");\r\n * getNodeType(comment2); // → \"Template\"\r\n * \r\n * // HTML element\r\n * const div = document.createElement('div');\r\n * getNodeType(div); // → \"HTMLElement\"\r\n * \r\n * // SVG element\r\n * const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n * getNodeType(circle); // → \"SVGElement\"\r\n * ```\r\n * \r\n * @param node - Node to determine\r\n * @param nodeKey - Node key for cache (auto-generated if omitted)\r\n * @returns Node type (NodeType)\r\n */\r\nexport function getNodeType(\r\n  node   : Node, \r\n  nodeKey: string = createNodeKey(node)\r\n): NodeType {\r\n  // Check cache, if not exists, determine and save to cache\r\n  return nodeTypeByNodeKey[nodeKey] ?? (nodeTypeByNodeKey[nodeKey] = getNodeTypeByNode(node));\r\n}\r\n","import { IFilterText, IBindText } from \"./types\";\r\n\r\n/**\r\n * Helper function to trim whitespace from string\r\n */\r\nconst trim = (s: string): string => s.trim();\r\n\r\n/**\r\n * Helper function to check if string is not empty\r\n */\r\nconst has = (s: string): boolean => s.length > 0;\r\n\r\n/**\r\n * Regular expression to detect URL-encoded strings\r\n * Matches strings enclosed in \"#...#\" format\r\n */\r\nconst re = new RegExp(/^#(.*)#$/);\r\n\r\n/**\r\n * Internal function to decode filter option values.\r\n * URL-decodes if enclosed in \"#...#\", otherwise returns as-is.\r\n * \r\n * Usage examples:\r\n * - \"#Hello%20World#\" → \"Hello World\" (URL decode)\r\n * - \"100\" → \"100\" (as-is)\r\n * - \"true\" → \"true\" (as-is)\r\n * \r\n * @param s - String to decode\r\n * @returns Decoded string\r\n */\r\nconst decode = (s: string): string => {\r\n  const m = re.exec(s);\r\n  return m ? decodeURIComponent(m[1]) : s;\r\n};\r\n\r\n/**\r\n * Internal function to parse filter part.\r\n * \r\n * Parse format: \"filterName,option1,option2,...\"\r\n * \r\n * Processing flow:\r\n * 1. Split by comma\r\n * 2. Extract first element as filter name, rest as options\r\n * 3. Decode each option (URL decode if \"#...#\" format)\r\n * 4. Return as IFilterText object\r\n * \r\n * Usage examples:\r\n * - \"eq,100\" → { name: \"eq\", options: [\"100\"] }\r\n * - \"default,#Hello%20World#\" → { name: \"default\", options: [\"Hello World\"] }\r\n * - \"trim\" → { name: \"trim\", options: [] }\r\n * \r\n * @param text - Filter definition string\r\n * @returns Parsed filter information\r\n */\r\nconst parseFilter = (text: string): IFilterText => {\r\n  // Split by comma, first is filter name, rest are options\r\n  const [name, ...options] = text.split(\",\").map(trim);\r\n  return { name, options: options.map(decode) };\r\n};\r\n\r\n/**\r\n * Type definition for property parse result\r\n */\r\ntype ReturnParseStateProperty = { property: string, filters: IFilterText[] };\r\n\r\n/**\r\n * Internal function to parse property expression.\r\n * \r\n * Parse format: \"propertyName|filter1|filter2|...\"\r\n * \r\n * Processing flow:\r\n * 1. Split by pipe (|)\r\n * 2. Extract first element as property name\r\n * 3. Parse remaining elements as filters (parseFilter)\r\n * 4. Return object with property name and filter array\r\n * \r\n * Usage examples:\r\n * - \"value\" → { property: \"value\", filters: [] }\r\n * - \"value|trim\" → { property: \"value\", filters: [{ name: \"trim\", options: [] }] }\r\n * - \"value|eq,100|falsey\" → { property: \"value\", filters: [{ name: \"eq\", options: [\"100\"] }, { name: \"falsey\", options: [] }] }\r\n * \r\n * @param text - Property expression string\r\n * @returns Property name and filter array\r\n */\r\nconst parseProperty = (text: string): ReturnParseStateProperty => {\r\n  // Split by pipe, first is property name, rest are filters\r\n  const [property, ...filterTexts] = text.split(\"|\").map(trim);\r\n  return { property, filters: filterTexts.map(parseFilter) };\r\n};\r\n\r\n/**\r\n * Internal function to parse single binding expression.\r\n * \r\n * Parse format: \"nodeProperty:stateProperty@decorator1,decorator2\"\r\n * \r\n * Syntax structure:\r\n * - Colon (:): Separates node property and state property\r\n * - At-mark (@): Separates binding expression and decorators\r\n * - Pipe (|): Separates property and filters\r\n * - Comma (,): Separates decorators or filter options\r\n * \r\n * Processing flow:\r\n * 1. Split by \"@\" to separate binding expression and decorator expression\r\n * 2. Convert decorator expression to array by comma separation\r\n * 3. Split binding expression by \":\" into node property and state property\r\n * 4. Parse each property with parseProperty (extract property name and filters)\r\n * 5. Return as IBindText object\r\n * \r\n * Filter directionality:\r\n * - inputFilterTexts: State→Node direction (applied during display)\r\n * - outputFilterTexts: Node→State direction (applied during input)\r\n * \r\n * Usage examples:e examples:\r\n * ```typescript\r\n * // Basic form\r\n * \"textContent:user.name\"\r\n * → { nodeProperty: \"textContent\", stateProperty: \"user.name\", \r\n *     inputFilterTexts: [], outputFilterTexts: [], decorates: [] }\r\n * \r\n * // With filter\r\n * \"value:amount|currency,USD\"\r\n * → { nodeProperty: \"value\", stateProperty: \"amount\",\r\n *     inputFilterTexts: [{ name: \"currency\", options: [\"USD\"] }],\r\n *     outputFilterTexts: [], decorates: [] }\r\n * \r\n * // With decorator\r\n * \"value:email@required,trim\"\r\n * → { nodeProperty: \"value\", stateProperty: \"email\",\r\n *     inputFilterTexts: [], outputFilterTexts: [],\r\n *     decorates: [\"required\", \"trim\"] }\r\n * \r\n * // Combined (bidirectional filters + decorator)\r\n * \"value|trim:email|lowercase@required\"\r\n * → { nodeProperty: \"value\", stateProperty: \"email\",\r\n *     inputFilterTexts: [{ name: \"trim\", options: [] }],\r\n *     outputFilterTexts: [{ name: \"lowercase\", options: [] }],\r\n *     decorates: [\"required\"] }\r\n * ```\r\n * \r\n * @param expression - Binding expression string\r\n * @returns Parsed binding information\r\n */\r\nconst parseExpression = (expression: string): IBindText => {\r\n  // Step 1: Split by \"@\" to separate binding expression and decorator expression\r\n  const [bindExpression, decoratesExpression = null] = expression.split(\"@\").map(trim);\r\n  \r\n  // Step 2: Convert decorator expression to array by comma (empty array if not exists)\r\n  const decorates = decoratesExpression ? decoratesExpression.split(\",\").map(trim) : [];\r\n  \r\n  // Step 3: Split binding expression by \":\" into node property and state property\r\n  const [nodePropertyText, statePropertyText] = bindExpression.split(\":\").map(trim);\r\n  \r\n  // Step 4: Parse each property text to extract property name and filters\r\n  // Node property filters = inputFilterTexts (state→node direction)\r\n  const { property: nodeProperty, filters: inputFilterTexts } = parseProperty(nodePropertyText);\r\n  \r\n  // State property filters = outputFilterTexts (node→state direction)\r\n  const { property: stateProperty, filters: outputFilterTexts } = parseProperty(statePropertyText);\r\n  \r\n  // Step 5: Return as structured binding information\r\n  return { nodeProperty, stateProperty, inputFilterTexts, outputFilterTexts, decorates };\r\n};\r\n\r\n/**\r\n * Internal function to parse entire bind text (containing multiple binding expressions).\r\n * \r\n * Parse format: \"expr1;expr2;expr3\" (semicolon-separated)\r\n * \r\n * Processing flow:\r\n * 1. Split by semicolon (;)\r\n * 2. Trim each element\r\n * 3. Filter out empty strings (filter(has))\r\n * 4. Parse each expression with parseExpression\r\n * 5. Return as IBindText array\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Single binding\r\n * \"textContent:user.name\"\r\n * → [{ nodeProperty: \"textContent\", stateProperty: \"user.name\", ... }]\r\n * \r\n * // Multiple bindings\r\n * \"value:email;class:active\"\r\n * → [\r\n *     { nodeProperty: \"value\", stateProperty: \"email\", ... },\r\n *     { nodeProperty: \"class\", stateProperty: \"active\", ... }\r\n *   ]\r\n * \r\n * // With empty expressions (automatically filtered out)\r\n * \"value:name; ;class:active\"\r\n * → [\r\n *     { nodeProperty: \"value\", stateProperty: \"name\", ... },\r\n *     { nodeProperty: \"class\", stateProperty: \"active\", ... }\r\n *   ]\r\n * ```\r\n * \r\n * @param text - Entire bind text\r\n * @returns Array of parsed binding information\r\n */\r\nconst parseExpressions = (text: string): IBindText[] => {\r\n  // Split by semicolon → trim → filter empty → parse each expression\r\n  return text.split(\";\").map(trim).filter(has).map(s => parseExpression(s));\r\n};\r\n\r\n/**\r\n * Cache for parse results\r\n * When same bind text is parsed multiple times, skip re-parsing to improve performance\r\n */\r\nconst cache: { [key: string]: IBindText[] } = {};\r\n\r\n/**\r\n * Main utility function that parses bind text (string obtained from data-bind attribute or comment)\r\n * and converts it to structured binding information (IBindText[]).\r\n *\r\n * Supported syntax:\r\n * - Basic form: \"nodeProperty:stateProperty\"\r\n * - With filters: \"nodeProperty|filter1,opt1:stateProperty|filter2\"\r\n * - With decorators: \"nodeProperty:stateProperty@decorator1,decorator2\"\r\n * - Multiple bindings: \"expr1;expr2;expr3\" (semicolon-separated)\r\n * - Encoded options: \"filter,#encoded%20value#\"\r\n * \r\n * Syntax elements:\r\n * - `:` (colon): Separates node property and state property\r\n * - `|` (pipe): Separates property and filters\r\n * - `,` (comma): Separates filter options or decorators\r\n * - `@` (at-mark): Separates binding expression and decorators\r\n * - `;` (semicolon): Separates multiple binding expressions\r\n * - `#...#`: Encloses URL-encoded values\r\n * \r\n * Performance optimization:\r\n * - Caches parse results (prevents re-parsing of same text)\r\n * - Returns empty array immediately for empty string\r\n * \r\n * Processing flow:\r\n * 1. Check if input is empty string → return empty array if empty\r\n * 2. Check cache → return from cache if hit\r\n * 3. Cache miss → parse with parseExpressions\r\n * 4. Save result to cache\r\n * 5. Return parse result\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Basic binding\r\n * parseBindText(\"textContent:user.name\");\r\n * // → [{ nodeProperty: \"textContent\", stateProperty: \"user.name\", \r\n * //      inputFilterTexts: [], outputFilterTexts: [], decorates: [] }]\r\n * \r\n * // With filter\r\n * parseBindText(\"value:amount|currency,USD,2\");\r\n * // → [{ nodeProperty: \"value\", stateProperty: \"amount\",\r\n * //      inputFilterTexts: [{ name: \"currency\", options: [\"USD\", \"2\"] }],\r\n * //      outputFilterTexts: [], decorates: [] }]\r\n * \r\n * // With decorator\r\n * parseBindText(\"value:email@required,trim\");\r\n * // → [{ nodeProperty: \"value\", stateProperty: \"email\",\r\n * //      inputFilterTexts: [], outputFilterTexts: [],\r\n * //      decorates: [\"required\", \"trim\"] }]\r\n * \r\n * // Multiple bindings\r\n * parseBindText(\"value:name;class:active\");\r\n * // → [\r\n * //   { nodeProperty: \"value\", stateProperty: \"name\", ... },\r\n * //   { nodeProperty: \"class\", stateProperty: \"active\", ... }\r\n * // ]\r\n * \r\n * // Bidirectional filters\r\n * parseBindText(\"value|trim:data.text|uppercase\");\r\n * // → [{ nodeProperty: \"value\", stateProperty: \"data.text\",\r\n * //      inputFilterTexts: [{ name: \"trim\", options: [] }],\r\n * //      outputFilterTexts: [{ name: \"uppercase\", options: [] }],\r\n * //      decorates: [] }]\r\n * \r\n * // Empty string\r\n * parseBindText(\"\");\r\n * // → []\r\n * ```\r\n * \r\n * @param text - Bind text (data-bind attribute value or comment content)\r\n * @returns Array of structured binding information\r\n */\r\nexport function parseBindText(\r\n  text: string\r\n): IBindText[] {\r\n  // Return empty array immediately for empty string (performance optimization)\r\n  if (text.trim() === \"\") {\r\n    return [];\r\n  }\r\n  \r\n  // Check cache, if not exists, parse and save to cache\r\n  return cache[text] ?? (cache[text] = parseExpressions(text));\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\n/**\r\n * Constant for data-bind attribute name\r\n */\r\nconst DATASET_BIND_PROPERTY = 'data-bind';\r\n\r\n/**\r\n * Internal function to remove data-bind attribute from Element node.\r\n * Commonly used for both HTMLElement and SVGElement.\r\n * \r\n * Processing flow:\r\n * 1. Cast node to Element type\r\n * 2. Remove data-bind attribute with removeAttribute\r\n * \r\n * @param node - Target node\r\n */\r\nconst removeAttributeFromElement = (node: Node): void => {\r\n  const element = node as Element;\r\n  element.removeAttribute(DATASET_BIND_PROPERTY);\r\n}\r\n\r\n/**\r\n * Type definition for map of attribute removal functions per node type.\r\n * Holds removal function (or undefined) corresponding to each node type.\r\n */\r\ntype RemoveAttributeByNodeType = {\r\n  [key in NodeType]: ((node: Node) => void) | undefined;\r\n}\r\n\r\n/**\r\n * Map of attribute removal functions per node type.\r\n * \r\n * Removal targets:\r\n * - HTMLElement: Remove data-bind attribute\r\n * - SVGElement: Remove data-bind attribute\r\n * \r\n * Non-removal targets:\r\n * - Text: undefined (no attributes)\r\n * - Template: undefined (template itself is not a removal target)\r\n */\r\nconst removeAttributeByNodeType: RemoveAttributeByNodeType = {\r\n  HTMLElement: removeAttributeFromElement,\r\n  SVGElement: removeAttributeFromElement,\r\n  Text: undefined,\r\n  Template: undefined,\r\n}\r\n\r\n/**\r\n * Utility function to remove data-bind attribute from specified node.\r\n *\r\n * Executes appropriate removal processing based on node type.\r\n * - HTMLElement, SVGElement: Remove data-bind attribute\r\n * - Text, Template: Do nothing (no attributes or not a removal target)\r\n * \r\n * By using optional chaining (?.),\r\n * nothing is executed if undefined, processing safely.\r\n * \r\n * Processing flow:\r\n * 1. Get removal function corresponding to nodeType from removeAttributeByNodeType\r\n * 2. Execute only if function exists (HTMLElement, SVGElement)\r\n * 3. Do nothing if function is undefined (Text, Template)\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // For HTMLElement\r\n * const div = document.createElement('div');\r\n * div.setAttribute('data-bind', 'textContent:user.name');\r\n * removeDataBindAttribute(div, 'HTMLElement');\r\n * // → data-bind attribute is removed\r\n * \r\n * // For SVGElement\r\n * const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n * svg.setAttribute('data-bind', 'class:active');\r\n * removeDataBindAttribute(svg, 'SVGElement');\r\n * // → data-bind attribute is removed\r\n * \r\n * // For Text node\r\n * const text = document.createTextNode('Hello');\r\n * removeDataBindAttribute(text, 'Text');\r\n * // → Do nothing (no attributes)\r\n * \r\n * // For Template\r\n * const template = document.createElement('template');\r\n * removeDataBindAttribute(template, 'Template');\r\n * // → Do nothing (not a removal target)\r\n * ```\r\n * \r\n * @param node - Target node\r\n * @param nodeType - Node type (\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\")\r\n */\r\nexport function removeDataBindAttribute(\r\n  node: Node,\r\n  nodeType: NodeType\r\n): void {\r\n  // Execute removal function corresponding to node type (do nothing if not exists)\r\n  return removeAttributeByNodeType[nodeType]?.(node);\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\n/**\r\n * Internal function to replace comment node with empty text node.\r\n * \r\n * Used when replacing binding comment nodes (<!-- @@:textContent:value --> etc.)\r\n * with actual text nodes for display.\r\n * \r\n * Processing flow:\r\n * 1. Create new text node with empty string\r\n * 2. Replace original comment node with parent node's replaceChild\r\n * 3. Return newly created text node\r\n * \r\n * Note: If parent node doesn't exist, replaceChild is not executed,\r\n *       but the new text node is still returned\r\n * \r\n * @param node - Comment node to replace\r\n * @returns Newly created text node\r\n */\r\nconst replaceTextNodeText = (node: Node): Node => {\r\n  // Step 1: Create empty text node\r\n  const textNode = document.createTextNode(\"\");\r\n  \r\n  // Step 2: Replace comment node in parent node\r\n  node.parentNode?.replaceChild(textNode, node);\r\n  \r\n  // Step 3: Return new text node\r\n  return textNode;\r\n}\r\n\r\n/**\r\n * Type definition for map of text node replacement functions per node type.\r\n * Holds replacement function (or undefined) corresponding to each node type.\r\n */\r\ntype ReplaceTextNodeFn = {\r\n  [key in NodeType]: ((node: Node) => Node) | undefined;\r\n}\r\n\r\n/**\r\n * Map of text node replacement functions per node type.\r\n * \r\n * Replacement target:\r\n * - Text: Replace comment node with empty text node\r\n *   (NodeType is \"Text\", but actually processes Comment node)\r\n * \r\n * Non-replacement targets:\r\n * - HTMLElement: undefined (Element nodes don't need replacement)\r\n * - Template: undefined (Template nodes don't need replacement)\r\n * - SVGElement: undefined (SVGElement nodes don't need replacement)\r\n * \r\n * Note: NodeType \"Text\" actually refers to comment nodes representing\r\n *       text content bindings (in BindingBuilder context)\r\n */\r\nconst replaceTextNodeFn: ReplaceTextNodeFn = {\r\n  Text: replaceTextNodeText,\r\n  HTMLElement: undefined,\r\n  Template: undefined,\r\n  SVGElement: undefined\r\n}\r\n\r\n/**\r\n * Utility function to replace binding comment nodes with actual display nodes.\r\n *\r\n * Used when converting text content bindings (<!-- @@:textContent:value --> etc.)\r\n * to actual DOM nodes.\r\n * \r\n * Processing by node type:\r\n * - Text (actually comment node): Replace with empty text node\r\n * - HTMLElement, SVGElement, Template: Return original node without modification\r\n * \r\n * By combining optional chaining (?.) and nullish coalescing operator (??),\r\n * - If replacement function exists: Execute function and return new node\r\n * - If replacement function is undefined: Return original node as-is\r\n * \r\n * Processing flow:\r\n * 1. Get replacement function corresponding to nodeType from replaceTextNodeFn\r\n * 2. If function exists (Text): Execute to replace comment node\r\n * 3. If function is undefined (others): Return original node\r\n * 4. Return replaced (or original) node\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // For Text (actually comment node)\r\n * const comment = document.createComment(\"@@:textContent:user.name\");\r\n * const parent = document.createElement('div');\r\n * parent.appendChild(comment);\r\n * \r\n * const textNode = replaceTextNodeFromComment(comment, 'Text');\r\n * // → Empty text node is created and comment node is replaced\r\n * // parent.childNodes[0] === textNode (empty Text node)\r\n * \r\n * // For HTMLElement\r\n * const div = document.createElement('div');\r\n * div.setAttribute('data-bind', 'textContent:value');\r\n * \r\n * const result = replaceTextNodeFromComment(div, 'HTMLElement');\r\n * // → Original div node is returned as-is (no replacement)\r\n * // result === div\r\n * \r\n * // For SVGElement\r\n * const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n * const result = replaceTextNodeFromComment(svg, 'SVGElement');\r\n * // → Original svg node is returned as-is (no replacement)\r\n * \r\n * // For Template\r\n * const template = document.createElement('template');\r\n * const result = replaceTextNodeFromComment(template, 'Template');\r\n * // → Original template node is returned as-is (no replacement)\r\n * ```\r\n * \r\n * @param node - Target node (comment node or Element node)\r\n * @param nodeType - Node type (\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\")\r\n * @returns Replaced node (for Text) or original node (for others)\r\n */\r\nexport function replaceTextNodeFromComment(\r\n  node: Node,\r\n  nodeType: NodeType\r\n): Node {\r\n  // Execute replacement function corresponding to node type (return original node if not exists)\r\n  return replaceTextNodeFn[nodeType]?.(node) ?? node;\r\n}\r\n","import { getAbsoluteNodePath } from \"./getAbsoluteNodePath.js\";\r\nimport { getBindingNodeCreator } from \"./getBindingNodeCreator.js\";\r\nimport { getBindingStateCreator } from \"./getBindingStateCreator.js\";\r\nimport { getDataBindText } from \"./getDataBindText.js\";\r\nimport { getNodeType } from \"./getNodeType.js\";\r\nimport { parseBindText } from \"./parseBindText.js\";\r\nimport { removeDataBindAttribute } from \"./removeDataBindAttribute.js\";\r\nimport { replaceTextNodeFromComment } from \"./replaceTextNodeFromComment.js\";\r\nimport { IBindingCreator, IBindText, IDataBindAttributes, NodePath, NodeType } from \"./types\";\r\n\r\n/**\r\n * DataBindAttributes class extracts and analyzes binding information from DOM nodes,\r\n * managing all necessary data (node type, path, bind texts, creators) for binding generation.\r\n *\r\n * Main processing flow:\r\n * 1. Determine node type (HTMLElement/SVGElement/Text/Template)\r\n * 2. Extract binding expression from data-bind attribute or comment\r\n * 3. Replace comment nodes with Text nodes (restore template preprocessing)\r\n * 4. Remove processed data-bind attributes (prevent duplicate processing)\r\n * 5. Calculate absolute node path (index array from parent)\r\n * 6. Parse binding expression into structured metadata (properties, filters, decorates)\r\n * 7. Generate factory function pairs for each bind text:\r\n *    - createBindingNode: Creates runtime BindingNode instance\r\n *    - createBindingState: Creates runtime BindingState instance\r\n *\r\n * This centralizes binding definition management in templates and streamlines\r\n * subsequent binding construction processes.\r\n */\r\nclass DataBindAttributes implements IDataBindAttributes {\r\n  /** Node type classification */\r\n  readonly nodeType: NodeType;\r\n  \r\n  /** Absolute path from template root (index array) */\r\n  readonly nodePath: NodePath;\r\n  \r\n  /** Array of parsed binding expressions */\r\n  readonly bindTexts: IBindText[];\r\n  \r\n  /** Map from bind text to factory function pairs */\r\n  readonly creatorByText: Map<IBindText, IBindingCreator> = new Map();\r\n\r\n  /**\r\n   * Constructor that initializes DataBindAttributes by analyzing the provided node.\r\n   * Extracts binding information, processes the DOM, and generates factory functions.\r\n   * \r\n   * @param node - DOM node to extract binding information from\r\n   */\r\n  constructor(node: Node) {\r\n    // Step 1: Determine node type\r\n    this.nodeType = getNodeType(node);\r\n\r\n    // Step 2: Extract binding expression from data-bind attribute or comment\r\n    const text = getDataBindText(this.nodeType, node);\r\n\r\n    // Step 3: Replace comment nodes with Text nodes\r\n    // (Restores Text nodes that were converted to comments during template preprocessing)\r\n    // Note: Directly modifies template.content\r\n    node = replaceTextNodeFromComment(node, this.nodeType);\r\n\r\n    // Step 4: Remove data-bind attribute (no longer needed after parsing, prevents duplicate processing)\r\n    removeDataBindAttribute(node, this.nodeType);\r\n\r\n    // Step 5: Calculate absolute node path (index array from parent nodes)\r\n    this.nodePath = getAbsoluteNodePath(node);\r\n\r\n    // Step 6: Parse binding expression into structured metadata\r\n    // (Array of IBindText containing nodeProperty, stateProperty, filters, decorates)\r\n    this.bindTexts = parseBindText(text);\r\n\r\n    // Step 7: Create factory function pairs for runtime instance generation for each bind text\r\n    for(let i = 0; i < this.bindTexts.length; i++) {\r\n      const bindText = this.bindTexts[i];\r\n      \r\n      // Generate factory function pair:\r\n      // - createBindingNode: Factory for BindingNode subclass (Attribute/Event/For/If, etc.)\r\n      // - createBindingState: Factory for BindingState subclass (normal/Index/Component, etc.)\r\n      const creator: IBindingCreator = {\r\n        createBindingNode : getBindingNodeCreator(\r\n          node, \r\n          bindText.nodeProperty,\r\n          bindText.inputFilterTexts,\r\n          bindText.decorates\r\n        ),\r\n        createBindingState: getBindingStateCreator(\r\n          bindText.stateProperty,\r\n          bindText.outputFilterTexts\r\n        ),\r\n      }\r\n      \r\n      // Associate bind text with factory function pair\r\n      this.creatorByText.set(bindText, creator);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Factory function that creates a DataBindAttributes instance from the specified node.\r\n * Called for each data-bind target node during template compilation.\r\n * \r\n * @param node - DOM node to extract binding information from\r\n * @returns IDataBindAttributes object containing binding metadata\r\n */\r\nexport function createDataBindAttributes(node: Node): IDataBindAttributes {\r\n  return new DataBindAttributes(node);\r\n}","import { COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\n/**\r\n * Cache comment mark lengths (performance optimization)\r\n */\r\nconst COMMENT_EMBED_MARK_LEN = COMMENT_EMBED_MARK.length;\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * Utility function that retrieves data-bind text (binding definition string) for each node type.\r\n * Extracts binding expressions appropriately based on how mustache syntax or comment bindings\r\n * were transformed during template preprocessing.\r\n *\r\n * Processing by node type:\r\n * 1. Text: Text node restored from comment\r\n *    - Get text after COMMENT_EMBED_MARK (e.g., \"@@:\")\r\n *    - Add \"textContent:\" prefix to create binding expression\r\n *    - Example: \"@@:user.name\" → \"textContent:user.name\"\r\n * \r\n * 2. HTMLElement: Regular HTML element\r\n *    - Get data-bind attribute value as-is\r\n *    - Example: <div data-bind=\"class:active\"> → \"class:active\"\r\n * \r\n * 3. Template: Template reference comment\r\n *    - Extract template ID after COMMENT_TEMPLATE_MARK (e.g., \"@@|\")\r\n *    - Get template by ID and return its data-bind attribute value\r\n *    - Example: \"@@|123 if:isVisible\" → data-bind attribute of template 123\r\n * \r\n * 4. SVGElement: SVG element\r\n *    - Get data-bind attribute value as-is (same as HTML element)\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Text node (converted from mustache syntax)\r\n * const text = document.createTextNode(\"@@:user.name\");\r\n * getDataBindText(\"Text\", text); // → \"textContent:user.name\"\r\n * \r\n * // HTML element\r\n * const div = document.createElement(\"div\");\r\n * div.setAttribute(\"data-bind\", \"class:active\");\r\n * getDataBindText(\"HTMLElement\", div); // → \"class:active\"\r\n * \r\n * // Template reference comment\r\n * const comment = document.createComment(\"@@|123 if:isVisible\");\r\n * getDataBindText(\"Template\", comment); // → data-bind value of template 123\r\n * ```\r\n * \r\n * @param nodeType - Node type\r\n * @param node - Target node\r\n * @returns Binding definition string (may be empty string)\r\n */\r\nexport function getDataBindText(nodeType: NodeType, node: Node): string {\r\n  switch (nodeType) {\r\n    case \"Text\": {\r\n      // Case 1: Text node (converted from mustache syntax)\r\n      // Get text after comment mark (e.g., \"@@:\") and trim\r\n      // Add \"textContent:\" prefix to create binding expression\r\n      const text = node.textContent?.slice(COMMENT_EMBED_MARK_LEN).trim() ?? \"\";\r\n      return \"textContent:\" + text;\r\n    }\r\n    case \"HTMLElement\": {\r\n      // Case 2: HTMLElement (regular HTML element)\r\n      // Return data-bind attribute value as-is\r\n      // Return empty string if attribute doesn't exist\r\n      return (node as HTMLElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"Template\": {\r\n      // Case 3: Template (template reference comment node)\r\n      // Comment text format: \"@@|123 if:isVisible\" format\r\n      // Step 1: Get text after comment mark\r\n      const text = node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN).trim();\r\n      \r\n      // Step 2: Split by space and get first element as template ID\r\n      // Example: \"123 if:isVisible\" → idText = \"123\"\r\n      const [idText, ] = text?.split(' ', 2) ?? [];\r\n      const id = Number(idText);\r\n      \r\n      // Step 3: Get template element by ID\r\n      const template = getTemplateById(id);\r\n      \r\n      // Step 4: Return data-bind attribute value of template\r\n      // Binding definition that template itself has (e.g., \"if:isVisible\", \"for:items\")\r\n      return template.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"SVGElement\": {\r\n      // Case 4: SVGElement (SVG element)\r\n      // Return data-bind attribute value as-is, same as HTML element\r\n      return (node as SVGElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    default:\r\n      // Other node types (normally unreachable)\r\n      // Return empty string\r\n      return \"\";\r\n  }\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * Utility function that traces the index from parent node to root for the specified node,\r\n * and returns it as an absolute path (NodePath).\r\n *\r\n * Processing flow:\r\n * 1. Start from current node and loop while parent node exists\r\n * 2. Get index of current node within parent's childNodes\r\n * 3. Prepend index to array (build in reverse order)\r\n * 4. Move to parent node and repeat\r\n * 5. Return index array when root node is reached\r\n *\r\n * Example: Given the following DOM tree structure:\r\n * ```\r\n * root\r\n *   ├─ child[0]\r\n *   ├─ child[1]\r\n *   │   ├─ grandchild[0]\r\n *   │   ├─ grandchild[1]\r\n *   │   └─ grandchild[2] ← Specify this node\r\n *   └─ child[2]\r\n * ```\r\n * Returns `[1, 2]` (index 1 in parent, index 2 within that)\r\n *\r\n * This absolute path is used to locate the same node from template later.\r\n * (Forms a pair with resolveNodeFromPath function)\r\n *\r\n * @param node - Target DOM node to get absolute path for\r\n * @returns Index array from root to this node (NodePath)\r\n */\r\nexport function getAbsoluteNodePath(node: Node): NodePath {\r\n  // Array to store result (indexes arranged from root to leaf)\r\n  let routeIndexes: NodePath = [];\r\n  \r\n  // Loop while parent node exists (until reaching root)\r\n  while (node.parentNode !== null) {\r\n    // Convert parent node's childNodes to array\r\n    const childNodes = Array.from(node.parentNode.childNodes) as Node[];\r\n    \r\n    // Get index of current node within parent's childNodes and prepend to array\r\n    // Prepending maintains root→leaf order\r\n    routeIndexes = [childNodes.indexOf(node), ...routeIndexes];\r\n    \r\n    // Move to parent node for next iteration\r\n    node = node.parentNode;\r\n  }\r\n  \r\n  // Return index array from root\r\n  return routeIndexes;\r\n}","import { DATA_BIND_ATTRIBUTE, COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK } from \"../constants.js\";\r\n\r\n/**\r\n * Internal function to determine if a comment node is a binding target.\r\n * \r\n * Decision criteria:\r\n * - Must be a Comment node\r\n * - Text starts with \"@@:\" (COMMENT_EMBED_MARK) → Text content binding\r\n * - Or starts with \"@@|\" (COMMENT_TEMPLATE_MARK) → Template reference binding\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * const comment1 = document.createComment(\"@@:user.name\");\r\n * isCommentNode(comment1); // → true (text binding)\r\n * \r\n * const comment2 = document.createComment(\"@@|123 if:isVisible\");\r\n * isCommentNode(comment2); // → true (template reference)\r\n * \r\n * const comment3 = document.createComment(\"regular comment\");\r\n * isCommentNode(comment3); // → false\r\n * ```\r\n * \r\n * @param node - Node to check\r\n * @returns true if binding target comment node\r\n */\r\nfunction isCommentNode(node: Node): boolean {\r\n  return node instanceof Comment && (\r\n    (node.textContent?.indexOf(COMMENT_EMBED_MARK) === 0) || \r\n    (node.textContent?.indexOf(COMMENT_TEMPLATE_MARK) === 0)\r\n  );\r\n} \r\n\r\n/**\r\n * Utility function that retrieves all \"elements with data-bind attribute\" or\r\n * \"comment nodes starting with specific marks (@@: or @@|)\" from DOM tree below specified node.\r\n *\r\n * Search targets:\r\n * 1. Element (element nodes)\r\n *    - Extract only those with data-bind attribute\r\n *    - Example: <div data-bind=\"class:active\">\r\n * \r\n * 2. Comment (comment nodes)\r\n *    - Starting with \"@@:\" (text content binding)\r\n *    - Starting with \"@@|\" (template reference binding)\r\n * \r\n * Processing flow:\r\n * 1. Create TreeWalker (SHOW_ELEMENT | SHOW_COMMENT flags)\r\n * 2. Custom filter ACCEPTs only matching nodes\r\n *    - Element: Check for data-bind attribute\r\n *    - Comment: Check with isCommentNode\r\n * 3. Efficiently traverse tree with nextNode()\r\n * 4. Add matching nodes to array\r\n * 5. Return array of all nodes\r\n * \r\n * Performance:\r\n * - Achieves efficient DOM tree traversal using TreeWalker\r\n * - Skips unnecessary nodes with custom filter\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * const fragment = document.createDocumentFragment();\r\n * const div = document.createElement('div');\r\n * div.setAttribute('data-bind', 'class:active');\r\n * const comment = document.createComment('@@:user.name');\r\n * fragment.appendChild(div);\r\n * fragment.appendChild(comment);\r\n * \r\n * const nodes = getNodesHavingDataBind(fragment);\r\n * // nodes = [div, comment] (elements with data-bind and binding comments)\r\n * ```\r\n * \r\n * @param root - Root node for search (typically DocumentFragment or Element)\r\n * @returns Array of nodes matching criteria\r\n */\r\nexport function getNodesHavingDataBind(root: Node): Node[] {\r\n  // Array to store results\r\n  const nodes: Node[] = [];\r\n  \r\n  // Create TreeWalker (target element and comment nodes)\r\n  const walker = document.createTreeWalker(\r\n    root, \r\n    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, \r\n    {\r\n      // Custom filter: Determine ACCEPT/SKIP for each node\r\n      acceptNode(node: Node) {\r\n        // Case: Element\r\n        if (node instanceof Element) {\r\n          // ACCEPT only if has data-bind attribute, otherwise SKIP\r\n          return node.hasAttribute(DATA_BIND_ATTRIBUTE) \r\n            ? NodeFilter.FILTER_ACCEPT \r\n            : NodeFilter.FILTER_SKIP;\r\n        } else {\r\n          // Case: Comment\r\n          // Check with isCommentNode if starts with \"@@:\" or \"@@|\"\r\n          return isCommentNode(node) \r\n            ? NodeFilter.FILTER_ACCEPT \r\n            : NodeFilter.FILTER_SKIP;\r\n        }\r\n      }\r\n    }\r\n  );\r\n  \r\n  // Move to next node with TreeWalker and add matching nodes to array\r\n  while (walker.nextNode()) {\r\n    nodes.push(walker.currentNode);\r\n  }\r\n  \r\n  // Return array of binding target nodes\r\n  return nodes;\r\n}\r\n\r\n","import { createDataBindAttributes } from \"./createDataBindAttributes.js\";\r\nimport { getNodesHavingDataBind } from \"./getNodesHavingDataBind.js\";\r\nimport { IDataBindAttributes } from \"./types\";\r\n\r\n/**\r\n * Cache of binding attribute lists per template ID.\r\n * When a template is registered, stores all binding information within that template.\r\n */\r\nconst listDataBindAttributesById: { [key: number]: IDataBindAttributes[] } = {};\r\n\r\n/**\r\n * Cache of \"for\" binding stateProperty sets per template ID.\r\n * Used to identify state paths related to loops (lists).\r\n * \r\n * Example: \"for:items\" → \"items\" is added to listPathsSetById[id]\r\n */\r\nconst listPathsSetById: { [key: number]: Set<string> } = {};\r\n\r\n/**\r\n * Cache of all binding stateProperty sets per template ID.\r\n * Tracks all state paths referenced within the template.\r\n * \r\n * Example: \"textContent:user.name\", \"value:email\" → \"user.name\", \"email\" are added to pathsSetById[id]\r\n */\r\nconst pathsSetById: { [key: number]: Set<string> } = {};\r\n\r\n/**\r\n * Internal utility function that extracts data-bind target nodes from template's DocumentFragment\r\n * and converts them to IDataBindAttributes array.\r\n * \r\n * Processing flow:\r\n * 1. Extract nodes with bindings using getNodesHavingDataBind\r\n * 2. Convert each node to attribute information using createDataBindAttributes\r\n * 3. Return as IDataBindAttributes array\r\n * \r\n * @param content - Template's DocumentFragment\r\n * @returns Array of binding attribute information\r\n */\r\nfunction getDataBindAttributesFromTemplate(content: DocumentFragment): IDataBindAttributes[] {\r\n  // Step 1: Get all nodes with bindings\r\n  const nodes = getNodesHavingDataBind(content);\r\n  \r\n  // Step 2: Convert each node to attribute information\r\n  return nodes.map(node => createDataBindAttributes(node));\r\n}\r\n\r\n/**\r\n * Parses and registers binding information (data-bind attributes and comments) within a template,\r\n * building and caching attribute lists and state path sets per template ID.\r\n *\r\n * Main features:\r\n * 1. Detects and converts all binding nodes within the template\r\n * 2. Registers all binding stateProperty values to pathsSetById\r\n * 3. Also registers \"for\" binding stateProperty values to listPathsSetById\r\n * 4. Caches parse results in listDataBindAttributesById\r\n * \r\n * rootId parameter:\r\n * - When templates are nested, specify the root template's ID\r\n * - State path sets are managed collectively by root ID\r\n * - If omitted, id is used as rootId\r\n * \r\n * Processing flow:\r\n * 1. Extract binding information using getDataBindAttributesFromTemplate\r\n * 2. Get paths and listPaths Sets corresponding to rootId (create new if first time)\r\n * 3. Traverse each binding attribute:\r\n *    a. Add each bindText's stateProperty to paths\r\n *    b. If nodeProperty is \"for\", also add to listPaths\r\n * 4. Save parse result to listDataBindAttributesById[id] and return\r\n * \r\n * Usage example:e example:\r\n * ```typescript\r\n * // Template HTML:\r\n * // <div data-bind=\"textContent:user.name\"></div>\r\n * // <ul>\r\n * //   <!-- @@:for:items -->\r\n * //   <li data-bind=\"textContent:name\"></li>\r\n * //   <!-- @@:end -->\r\n * // </ul>\r\n * \r\n * const template = document.getElementById('myTemplate');\r\n * const attributes = registerDataBindAttributes(1, template.content);\r\n * \r\n * // Result:\r\n * // listDataBindAttributesById[1] = [\r\n * //   { bindTexts: [{ nodeProperty: \"textContent\", stateProperty: \"user.name\", ... }], ... },\r\n * //   { bindTexts: [{ nodeProperty: \"for\", stateProperty: \"items\", ... }], ... },\r\n * //   { bindTexts: [{ nodeProperty: \"textContent\", stateProperty: \"name\", ... }], ... }\r\n * // ]\r\n * // pathsSetById[1] = Set { \"user.name\", \"items\", \"name\" }\r\n * // listPathsSetById[1] = Set { \"items\" }\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @param content - Template's DocumentFragment\r\n * @param rootId - Root template ID (defaults to id if omitted)\r\n * @returns Parsed binding attribute list\r\n */\r\nexport function registerDataBindAttributes(\r\n  id: number,\r\n  content: DocumentFragment,\r\n  rootId: number = id\r\n): IDataBindAttributes[] {\r\n  // Step 1: Extract all binding information from template\r\n  const dataBindAttributes = getDataBindAttributesFromTemplate(content);\r\n  \r\n  // Step 2: Get state path sets corresponding to rootId (create new if first time)\r\n  const paths = pathsSetById[rootId] ?? (pathsSetById[rootId] = new Set<string>());\r\n  const listPaths = listPathsSetById[rootId] ?? (listPathsSetById[rootId] = new Set<string>());\r\n  \r\n  // Step 3: Traverse each binding attribute and register state paths\r\n  for (let i = 0; i < dataBindAttributes.length; i++) {\r\n    const attribute = dataBindAttributes[i];\r\n    \r\n    // Process stateProperty of each binding text\r\n    for (let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      \r\n      // Add stateProperty of all bindings to paths\r\n      paths.add(bindText.stateProperty);\r\n      \r\n      // If \"for\" binding (loop), also add to listPaths\r\n      if (bindText.nodeProperty === \"for\") {\r\n        listPaths.add(bindText.stateProperty);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Step 4: Save parse result to cache and return\r\n  return listDataBindAttributesById[id] = dataBindAttributes;\r\n}\r\n\r\n/**\r\n * Gets registered binding attribute list from template ID.\r\n * \r\n * Used to retrieve binding information of templates\r\n * registered with registerDataBindAttributes.\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * registerDataBindAttributes(1, template.content);\r\n * const attributes = getDataBindAttributesById(1);\r\n * // → [{ bindTexts: [...], nodeType: \"Element\", nodePath: [...], ... }]\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @returns Binding attribute list\r\n */\r\nexport const getDataBindAttributesById = (id: number): IDataBindAttributes[] => {\r\n  return listDataBindAttributesById[id];\r\n}\r\n\r\n/**\r\n * Gets \"for\" binding (loop) stateProperty set from template ID.\r\n * \r\n * Used to identify state paths related to loops.\r\n * Returns empty array if not registered.\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * // Assuming template contains <!-- @@:for:items -->\r\n * registerDataBindAttributes(1, template.content);\r\n * const listPaths = getListPathsSetById(1);\r\n * // → Set { \"items\" }\r\n * \r\n * // Monitor loop state changes\r\n * if (listPaths.has(\"items\")) {\r\n *   // Process assuming items is an array\r\n * }\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @returns State path set of \"for\" bindings (empty array if not registered)\r\n */\r\nexport const getListPathsSetById = (id: number): Set<string> => {\r\n  return listPathsSetById[id] ?? [];\r\n};\r\n\r\n/**\r\n * Gets all binding stateProperty set from template ID.\r\n * \r\n * Used to track all state paths referenced within the template.\r\n * Returns empty array if not registered.\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * // Assuming template has following bindings:\r\n * // - textContent:user.name\r\n * // - value:email\r\n * // - for:items\r\n * registerDataBindAttributes(1, template.content);\r\n * const allPaths = getPathsSetById(1);\r\n * // → Set { \"user.name\", \"email\", \"items\" }\r\n * \r\n * // Monitor state changes\r\n * if (allPaths.has(\"user.name\")) {\r\n *   // Process user.name change\r\n * }\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @returns State path set of all bindings (empty array if not registered)\r\n */\r\nexport const getPathsSetById = (id: number): Set<string> => {\r\n  return pathsSetById[id] ?? [];\r\n};","/**\r\n * HTMLTemplateElement を ID で登録・取得するための管理モジュール。\r\n *\r\n * 役割:\r\n * - registerTemplate: 指定 ID でテンプレートを登録（空テキスト除去と data-bind 解析を実行）\r\n * - getTemplateById: 指定 ID のテンプレートを取得（未登録時はエラー）\r\n *\r\n * Throws（getTemplateById）:\r\n * - TMP-001 Template not found: 未登録のテンプレート ID を要求\r\n */\r\nimport { registerDataBindAttributes } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { removeEmptyTextNodes } from \"./removeEmptyTextNodes.js\";\r\n\r\nconst templateById:Record<number, HTMLTemplateElement> = {};\r\n\r\n/**\r\n * テンプレートを ID で登録し、内部インデックスと data-bind 情報を構築する。\r\n *\r\n * @param id       テンプレート ID\r\n * @param template HTMLTemplateElement\r\n * @param rootId   ルートテンプレート ID（ネスト解析用）\r\n * @returns       登録した ID\r\n */\r\nexport function registerTemplate(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number\r\n): number {\r\n  removeEmptyTextNodes(template.content);\r\n  registerDataBindAttributes(id, template.content, rootId);  \r\n  templateById[id] = template;\r\n  return id;\r\n}\r\n\r\n/**\r\n * 登録済みテンプレートを取得する。\r\n *\r\n * @throws TMP-001 Template not found\r\n */\r\nexport function getTemplateById(id: number): HTMLTemplateElement {\r\n  return templateById[id] ?? raiseError({\r\n    code: \"TMP-001\",\r\n    message: `Template not found: ${id}`,\r\n    context: { where: 'registerTemplate.getTemplateById', templateId: id },\r\n    docsUrl: \"./docs/error-codes.md#tmp\",\r\n  });\r\n}","/**\r\n * removeEmptyTextNodes.ts\r\n *\r\n * DocumentFragment内の空テキストノードを削除するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - content（DocumentFragment）の直下にある空白のみのテキストノードを検出し、削除する\r\n *\r\n * 設計ポイント:\r\n * - childNodesをArray.fromで配列化し、forEachで全ノードを走査\r\n * - nodeTypeがTEXT_NODEかつ、nodeValueが空白のみの場合にremoveChildで削除\r\n * - テンプレート処理やクリーンなDOM生成時に利用\r\n */\r\nexport function removeEmptyTextNodes(content:DocumentFragment):void {\r\n  Array.from(content.childNodes).forEach(node => {\r\n    if (node.nodeType === Node.TEXT_NODE && !(node.nodeValue ?? \"\").trim()) {\r\n      content.removeChild(node);\r\n    }\r\n  });  \r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../Updater/types\";\r\nimport { CreateBindingNodeByNodeFn, IBindingNode } from \"./BindingNode/types\";\r\nimport { CreateBindingStateByStateFn, IBindingState } from \"./BindingState/types\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\n\r\n/**\r\n * Coordinates BindingNode (DOM operations) and BindingState (state management) to achieve reactive binding.\r\n * \r\n * Optimizations:\r\n * - Duplicate update prevention via updatedBindings set\r\n * - Single binding optimization: Add non-dynamic single ref to processedRefs\r\n * - WeakMap cache for loop index bindings\r\n */\r\nclass Binding implements IBinding {\r\n  readonly parentBindContent: IBindContent;\r\n  readonly engine: IComponentEngine;\r\n  readonly node: Node;\r\n  readonly bindingNode: IBindingNode;\r\n  readonly bindingState: IBindingState;\r\n  readonly bindingsByListIndex: WeakMap<IListIndex, Set<IBinding>> = new WeakMap();\r\n\r\n  private _isActive: boolean = false;\r\n  \r\n  /**\r\n   * Initialize binding with factories for BindingNode and BindingState.\r\n   * Call activate() after construction to enable.\r\n   * \r\n   * @param parentBindContent - Parent BindContent instance\r\n   * @param node - DOM node to bind\r\n   * @param engine - Component engine instance\r\n   * @param createBindingNode - Factory function to create BindingNode\r\n   * @param createBindingState - Factory function to create BindingState\r\n   */\r\n  constructor(\r\n    parentBindContent: IBindContent,\r\n    node: Node,\r\n    engine: IComponentEngine,\r\n    createBindingNode: CreateBindingNodeByNodeFn, \r\n    createBindingState: CreateBindingStateByStateFn,\r\n  ) {\r\n    this.parentBindContent = parentBindContent\r\n    this.node = node;\r\n    this.engine = engine\r\n    this.bindingNode = createBindingNode(this, node, engine.inputFilters);\r\n    this.bindingState = createBindingState(this, engine.outputFilters);\r\n  }\r\n\r\n  /**\r\n   * Returns child BindContent managed by structural control bindings (for, if, etc.)\r\n   * \r\n   * @returns Array of child BindContent instances (empty for non-structural bindings)\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return this.bindingNode.bindContents;\r\n  }\r\n\r\n  /**\r\n   * Returns whether binding is currently active.\r\n   * \r\n   * @returns true if binding is active, false otherwise\r\n   */\r\n  get isActive(): boolean {\r\n    return this._isActive;\r\n  }\r\n\r\n  /**\r\n   * Update state value for bidirectional binding (used by input, checkbox, etc.)\r\n   * \r\n   * @param writeState - Writable state proxy\r\n   * @param handler - State update handler\r\n   * @param value - Value to assign to state\r\n   */\r\n  updateStateValue(writeState:IWritableStateProxy, handler: IWritableStateHandler, value: any) {\r\n    return this.bindingState.assignValue(writeState, handler, value);\r\n  }\r\n\r\n  /**\r\n   * Notify BindingNode to redraw if its ref matches any in the provided refs array.\r\n   * \r\n   * @param refs - Array of state property references that require redraw\r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]) {\r\n    this.bindingNode.notifyRedraw(refs);\r\n  }\r\n\r\n  /**\r\n   * Apply state changes to DOM with duplicate update prevention.\r\n   * Optimization: Mark single binding refs as processed to avoid redundant checks.\r\n   * \r\n   * @param renderer - Renderer instance managing update cycle\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this)) return;\r\n    renderer.updatedBindings.add(this);\r\n    this.bindingNode.applyChange(renderer);\r\n    \r\n    const ref = this.bindingState.ref;\r\n    if (!this.bindingState.isLoopIndex && !this.engine.pathManager.dynamicDependencies.has(ref.info.pattern)) {\r\n      const bindings = this.engine.getBindings(ref);\r\n      if (bindings.length === 1) {\r\n        renderer.processedRefs.add(ref);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Activate binding: subscribe to state and render to DOM. Not idempotent. */\r\n  activate(): void {\r\n    this._isActive = true;\r\n    this.bindingState.activate();\r\n    this.bindingNode.activate();\r\n  }\r\n  \r\n  /** Inactivate binding: unsubscribe from state and cleanup resources. Idempotent. */\r\n  inactivate(): void {\r\n    if (this.isActive) {\r\n      this.bindingNode.inactivate();\r\n      this.bindingState.inactivate();\r\n      this._isActive = false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create Binding instance. Call activate() after creation.\r\n * \r\n * @param parentBindContent - Parent BindContent instance\r\n * @param node - DOM node to bind\r\n * @param engine - Component engine instance\r\n * @param createBindingNode - Factory function to create BindingNode\r\n * @param createBindingState - Factory function to create BindingState\r\n * @returns New Binding instance\r\n */\r\nexport function createBinding(\r\n  parentBindContent: IBindContent,\r\n  node: Node, \r\n  engine: IComponentEngine, \r\n  createBindingNode: CreateBindingNodeByNodeFn, \r\n  createBindingState: CreateBindingStateByStateFn\r\n): IBinding {\r\n  return new Binding(\r\n    parentBindContent, \r\n    node, \r\n    engine, \r\n    createBindingNode, \r\n    createBindingState\r\n  );\r\n}","/**\r\n * createLoopContext.ts\r\n *\r\n * ループバインディング（for等）で利用するLoopContext（ループコンテキスト）管理クラスとファクトリ関数の実装です。\r\n *\r\n * 主な役割:\r\n * - ループごとのプロパティパス・インデックス・BindContentを紐付けて管理\r\n * - 親ループコンテキストの探索やキャッシュ、インデックスの再割り当て・クリアなどを提供\r\n * - ループ階層をたどるwalk/serializeや、名前でのfind検索も可能\r\n *\r\n * 設計ポイント:\r\n * - WeakRefでlistIndexを保持し、GCフレンドリーな設計\r\n * - parentLoopContextで親ループを遅延探索・キャッシュし、効率的な親子関係管理を実現\r\n * - findで名前からループコンテキストを高速検索（キャッシュ付き）\r\n * - walk/serializeでループ階層をたどる処理を簡潔に記述可能\r\n * - createLoopContextファクトリで一貫した生成・管理が可能\r\n */\r\nimport { IBindContent } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { ILoopContext } from \"./types\";\r\n\r\nclass LoopContext implements ILoopContext {\r\n  #ref: IStatePropertyRef | null;\r\n  #info: IStructuredPathInfo;\r\n  #bindContent : IBindContent;\r\n  constructor(\r\n    ref: IStatePropertyRef,\r\n    bindContent: IBindContent\r\n  ) {\r\n    this.#ref = ref;\r\n    this.#info = ref.info;\r\n    this.#bindContent = bindContent;\r\n  }\r\n  get ref(): IStatePropertyRef {\r\n    return this.#ref ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'ref is null',\r\n      context: { where: 'LoopContext.ref', path: this.#info.pattern },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n  get path(): string {\r\n    return this.ref.info.pattern;\r\n  }\r\n  get info(): IStructuredPathInfo {\r\n    return this.ref.info;\r\n  }\r\n  get listIndex(): IListIndex {\r\n    return this.ref.listIndex ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is required',\r\n      context: { where: 'LoopContext.listIndex', path: this.#info.pattern },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    this.#ref = getStatePropertyRef(this.#info, listIndex);\r\n    // 構造は変わらないので、#parentLoopContext、#cacheはクリアする必要はない\r\n  }\r\n  clearListIndex():void {\r\n    this.#ref = null;\r\n  }\r\n  get bindContent(): IBindContent {\r\n    return this.#bindContent;\r\n  }\r\n\r\n  #parentLoopContext: ILoopContext | null | undefined;\r\n  get parentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#parentLoopContext === \"undefined\") {\r\n      let currentBindContent: IBindContent | null = this.bindContent;\r\n      while(currentBindContent !== null) {\r\n        if (currentBindContent.loopContext !== null && currentBindContent.loopContext !== this) {\r\n          this.#parentLoopContext = currentBindContent.loopContext;\r\n          break;\r\n        }\r\n        currentBindContent = currentBindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      if (typeof this.#parentLoopContext === \"undefined\") this.#parentLoopContext = null;\r\n    }\r\n    return this.#parentLoopContext;\r\n  }\r\n\r\n  #cache:Record<string, ILoopContext | null> = {};\r\n  find(name: string): ILoopContext | null {\r\n    let loopContext = this.#cache[name];\r\n    if (typeof loopContext === \"undefined\") {\r\n      let currentLoopContext: ILoopContext | null = this;\r\n      while(currentLoopContext !== null) {\r\n        if (currentLoopContext.path === name) break;\r\n        currentLoopContext = currentLoopContext.parentLoopContext;\r\n      }\r\n      loopContext = this.#cache[name] = currentLoopContext;\r\n    }\r\n    return loopContext;\r\n  }\r\n\r\n  walk(callback: (loopContext: ILoopContext) => void): void {\r\n    let currentLoopContext: ILoopContext | null = this;\r\n    while(currentLoopContext !== null) {\r\n      callback(currentLoopContext);\r\n      currentLoopContext = currentLoopContext.parentLoopContext;\r\n    }\r\n  }\r\n\r\n  serialize(): ILoopContext[] {\r\n    const results: ILoopContext[] = [];\r\n    this.walk((loopContext) => {\r\n      results.unshift(loopContext);\r\n    });\r\n    return results;\r\n  }\r\n\r\n}\r\n\r\n// 生成されたあと、IBindContentのloopContextに登録される\r\n// IBindContentにずっと保持される\r\nexport function createLoopContext(\r\n  ref: IStatePropertyRef,\r\n  bindContent: IBindContent\r\n): ILoopContext {\r\n  return new LoopContext(ref, bindContent);\r\n}","import { resolveNodeFromPath } from \"../BindingBuilder/resolveNodeFromPath.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createBinding } from \"./Binding.js\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\nimport { createLoopContext } from \"../LoopContext/createLoopContext.js\";\r\nimport { getDataBindAttributesById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { hasLazyLoadComponents, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IRenderer } from \"../Updater/types.js\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types.js\";\r\nimport { BindingNode } from \"./BindingNode/BindingNode.js\";\r\n\r\n/**\r\n * Internal helper function to generate DocumentFragment from template ID.\r\n * Automatically loads lazy-load components if present.\r\n * \r\n * @param id - Registered template ID\r\n * @returns DocumentFragment with copied template content\r\n * @throws BIND-101 Template not found\r\n */\r\nfunction createContent(id: number): DocumentFragment {\r\n  const template = getTemplateById(id) ?? \r\n    raiseError({\r\n      code: \"BIND-101\",\r\n      message: `Template not found: ${id}`,\r\n      context: { where: 'BindContent.createContent', templateId: id },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n  \r\n  const fragment = document.importNode(template.content, true);\r\n  \r\n  if (hasLazyLoadComponents()) {\r\n    const lazyLoadElements = fragment.querySelectorAll(\":not(:defined)\");\r\n    for(let i = 0; i < lazyLoadElements.length; i++) {\r\n      const tagName = lazyLoadElements[i].tagName.toLowerCase();\r\n      loadLazyLoadComponent(tagName);\r\n    }\r\n  }\r\n  \r\n  return fragment;\r\n}\r\n\r\n/**\r\n * Internal function to construct IBinding array from data-bind information within template.\r\n * Uses factory functions to generate appropriate binding types.\r\n *\r\n * @param bindContent - Parent BindContent\r\n * @param id - Template ID\r\n * @param engine - Component engine\r\n * @param content - Fragment copied from template\r\n * @returns Array of generated IBinding\r\n * @throws BIND-101 Data-bind is not set\r\n * @throws BIND-102 Node not found\r\n * @throws BIND-103 Creator not found\r\n */\r\nfunction createBindings(\r\n  bindContent: IBindContent, \r\n  id         : number, \r\n  engine     : IComponentEngine, \r\n  content    : DocumentFragment\r\n): IBinding[] {\r\n  const attributes = getDataBindAttributesById(id) ?? \r\n    raiseError({\r\n      code: \"BIND-101\",\r\n      message: \"Data-bind is not set\",\r\n      context: { where: 'BindContent.createBindings', templateId: id },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n  \r\n  const bindings: IBinding[] = [];\r\n  \r\n  for(let i = 0; i < attributes.length; i++) {\r\n    const attribute = attributes[i];\r\n    \r\n    const node = resolveNodeFromPath(content, attribute.nodePath) ?? \r\n      raiseError({\r\n        code: \"BIND-102\",\r\n        message: `Node not found: ${attribute.nodePath}`,\r\n        context: { where: 'BindContent.createBindings', templateId: id, nodePath: attribute.nodePath },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n    \r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      \r\n      const creator = attribute.creatorByText.get(bindText) ??\r\n        raiseError({\r\n          code: \"BIND-103\",\r\n          message: `Creator not found: ${bindText}`,\r\n          context: { where: 'BindContent.createBindings', templateId: id, bindText },\r\n          docsUrl: \"./docs/error-codes.md#bind\",\r\n        });\r\n      \r\n      \r\n      // Generate Binding instance (includes BindingNode and BindingState)\r\n      const binding = createBinding(\r\n        bindContent, \r\n        node, \r\n        engine, \r\n        creator.createBindingNode, \r\n        creator.createBindingState\r\n      );\r\n      \r\n      \r\n      // Add to array\r\n      bindings.push(binding);\r\n    }\r\n  }\r\n  \r\n  \r\n  // Step 4: Return generated IBinding array\r\n  return bindings;\r\n}\r\n\r\n/**\r\n * BindContent class manages DOM fragments generated from templates and their binding information.\r\n * Supports hierarchical structure, loops, and lifecycle management.\r\n *\r\n * @throws BIND-101 Template not found (in createContent)\r\n * @throws BIND-101/102/103 data-bind info issues (in createBindings)\r\n * @throws BIND-104 Child bindContent not found (getLastNode)\r\n * @throws BIND-201 LoopContext is null (assignListIndex)\r\n */\r\nclass BindContent implements IBindContent {\r\n  parentBinding: IBinding | null;\r\n  readonly loopContext: ILoopContext | null;\r\n  readonly id: number;\r\n  readonly firstChildNode: Node | null;\r\n  readonly lastChildNode: Node | null;\r\n  readonly fragment: DocumentFragment;\r\n  readonly childNodes: Node[];\r\n  readonly bindings: IBinding[] = [];\r\n\r\n  private _engine: IComponentEngine | undefined;\r\n  private _isActive: boolean = false;\r\n  private _currentLoopContext: ILoopContext | null | undefined;\r\n  \r\n  /**\r\n   * Recursively retrieves the last node, including those under trailing bindings.\r\n   * Used for determining DOM insertion position in BindingNodeFor.\r\n   *\r\n   * @param parentNode - Parent node for validation\r\n   * @returns Last node or null if parent-child relationship broken\r\n   * @throws BIND-104 Child bindContent not found\r\n   */\r\n  getLastNode(parentNode: Node): Node | null {\r\n    const lastBinding = this.bindings[this.bindings.length - 1];\r\n    const lastChildNode = this.lastChildNode;\r\n    if (typeof lastBinding !== \"undefined\" && lastBinding.node === lastChildNode) {\r\n      if (lastBinding.bindContents.length > 0) {\r\n        const childBindContent = lastBinding.bindContents.at(-1) ?? raiseError({\r\n          code: \"BIND-104\",\r\n          message: \"Child bindContent not found\",\r\n          context: { where: 'BindContent.getLastNode', templateId: this.id },\r\n          docsUrl: \"./docs/error-codes.md#bind\",\r\n        });\r\n        const lastNode = childBindContent.getLastNode(parentNode);\r\n        if (lastNode !== null) {\r\n          return lastNode;\r\n        }\r\n      }\r\n    }\r\n    if (parentNode !== lastChildNode?.parentNode) {\r\n      return null;\r\n    }\r\n    return lastChildNode;\r\n  }\r\n\r\n  /**\r\n   * Getter to retrieve current loop context with caching.\r\n   * Traverses parent direction on first access, cached thereafter.\r\n   * \r\n   * @returns Current ILoopContext or null if not in loop\r\n   */\r\n  get currentLoopContext(): ILoopContext | null {\r\n    if (typeof this._currentLoopContext === \"undefined\") {\r\n      let bindContent: IBindContent | null = this;\r\n      while(bindContent !== null) {\r\n        if (bindContent.loopContext !== null) break; ;\r\n        bindContent = bindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      this._currentLoopContext = bindContent?.loopContext ?? null;\r\n    }\r\n    return this._currentLoopContext;\r\n  }\r\n  /**\r\n   * Constructor initializes BindContent from template ID.\r\n   * Generates LoopContext if loopRef has listIndex.\r\n   * Call activate() after construction to enable bindings.\r\n   * \r\n   * @param parentBinding - Parent IBinding (null if root)\r\n   * @param id - Template ID\r\n   * @param engine - Component engine instance\r\n   * @param loopRef - StatePropertyRef for loop context\r\n   * @throws BIND-101 Template not found or data-bind not set\r\n   * @throws BIND-102 Node not found in template\r\n   * @throws BIND-103 Creator not found for bindText\r\n   */\r\n  constructor(\r\n    parentBinding: IBinding | null,\r\n    id: number, \r\n    engine: IComponentEngine, \r\n    loopRef: IStatePropertyRef,\r\n  ) {\r\n    this.parentBinding = parentBinding;\r\n    this.id = id;\r\n    this.fragment = createContent(id);\r\n    this.childNodes = Array.from(this.fragment.childNodes);\r\n    this.firstChildNode = this.childNodes[0] ?? null;\r\n    this.lastChildNode = this.childNodes[this.childNodes.length - 1] ?? null;\r\n    this._engine = engine;\r\n    this.loopContext = (loopRef.listIndex !== null) ? createLoopContext(loopRef, this) : null;\r\n    const bindings = createBindings(\r\n      this, \r\n      id, \r\n      engine, \r\n      this.fragment\r\n    );\r\n    this.bindings = bindings;\r\n  }\r\n\r\n  /**\r\n   * Returns whether BindContent is currently active.\r\n   * \r\n   * @returns true if active, false otherwise\r\n   */\r\n  get isActive(): boolean {\r\n    return this._isActive;\r\n  }\r\n\r\n  /**\r\n   * Mounts childNodes to end of parent node (appendChild).\r\n   * Not idempotent - caller must avoid duplicate mounts.\r\n   * \r\n   * @param parentNode - Parent node for mount destination\r\n   */\r\n  mount(parentNode: Node) {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.appendChild(this.childNodes[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mounts childNodes immediately before specified node (insertBefore).\r\n   * If beforeNode is null, appends to end.\r\n   * \r\n   * @param parentNode - Parent node for mount destination\r\n   * @param beforeNode - Reference node for insertion position (null = append to end)\r\n   */\r\n  mountBefore(parentNode: Node, beforeNode: Node | null) {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mounts childNodes immediately after specified node.\r\n   * \r\n   * @param parentNode - Parent node for mount destination\r\n   * @param afterNode - Reference node for insertion position (null = prepend to start)\r\n   */\r\n  mountAfter(parentNode: Node, afterNode: Node | null) {\r\n    const beforeNode = afterNode?.nextSibling ?? null;\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unmounts (detaches) childNodes from DOM.\r\n   * Clears currentLoopContext cache.\r\n   */\r\n  unmount() {\r\n    this._currentLoopContext = undefined;\r\n    \r\n    const parentNode = this.childNodes[0]?.parentNode ?? null;\r\n    if (parentNode === null) {\r\n      return; \r\n    }\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.removeChild(this.childNodes[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reassigns ListIndex within loop.\r\n   * Used when reordering array elements in BindingNodeFor.\r\n   * \r\n   * @param listIndex - New list index to assign\r\n   * @throws BIND-201 LoopContext is null\r\n   */\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    if (this.loopContext == null) raiseError({\r\n      code: \"BIND-201\",\r\n      message: \"LoopContext is null\",\r\n      context: { where: 'BindContent.assignListIndex', templateId: this.id },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n    this.loopContext.assignListIndex(listIndex);\r\n  }\r\n\r\n  /**\r\n   * Applies changes to all bindings.\r\n   * Called from Renderer, prevents duplicate updates.\r\n   * \r\n   * @param renderer - Renderer instance managing update cycle\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    const parentNode = this.childNodes[0]?.parentNode ?? null;\r\n    if (parentNode === null) {\r\n      return; \r\n    }\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      const binding = this.bindings[i];\r\n      if (renderer.updatedBindings.has(binding)) continue;\r\n      binding.applyChange(renderer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates all bindings in this BindContent.\r\n   * Subscribes to state and renders to DOM.\r\n   */\r\n  activate(): void {\r\n    this._isActive = true;\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      this.bindings[i].activate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inactivates all bindings and clears loop context.\r\n   * Unsubscribes from state and cleans up resources.\r\n   */\r\n  inactivate(): void {\r\n    this._isActive = false;\r\n    this.loopContext?.clearListIndex();\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      this.bindings[i].inactivate();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate BindContent instance.\r\n * Call activate() after creation to enable bindings.\r\n * \r\n * @param parentBinding - Parent IBinding (null if root)\r\n * @param id - Template ID\r\n * @param engine - Component engine instance\r\n * @param loopRef - StatePropertyRef for loop context\r\n * @returns Generated IBindContent instance\r\n * @throws BIND-101 Template not found or data-bind not set\r\n * @throws BIND-102 Node not found in template\r\n * @throws BIND-103 Creator not found for bindText\r\n */\r\nexport function createBindContent(\r\n  parentBinding: IBinding | null,\r\n  id: number, \r\n  engine: IComponentEngine, \r\n  loopRef: IStatePropertyRef,\r\n):IBindContent {\r\n  const bindContent = new BindContent(\r\n    parentBinding, \r\n    id, \r\n    engine, \r\n    loopRef,\r\n  );\r\n  return bindContent;\r\n}\r\n","/**\r\n * loadFromImportMap\r\n *\r\n * importmap のエイリアスを走査し、ルート/コンポーネントを自動登録する。\r\n * - @routes/*: entryRoute でルーティング登録（/root → / に正規化）\r\n * - @components/*: SFC を読み込み、ComponentClass を生成して registerComponentClass\r\n * - #lazy サフィックスが付与されている場合は遅延ロード用に保持\r\n *\r\n * 戻り値: Promise<void>\r\n * Throws: 重大な例外は基本なし（見つからないエイリアスは warn として扱う）\r\n */\r\nimport { entryRoute } from \"../Router/Router\";\r\nimport { raiseError } from \"../utils\";\r\nimport { createComponentClass } from \"./createComponentClass\";\r\nimport { loadImportmap } from \"./loadImportmap\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent\";\r\nimport { registerComponentClass } from \"./registerComponentClass\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nconst ROUTES_KEY = \"@routes/\";\r\nconst COMPONENTS_KEY = \"@components/\";\r\nconst LAZY_LOAD_SUFFIX = \"#lazy\";\r\nconst LAZY_LOAD_SUFFIX_LEN = LAZY_LOAD_SUFFIX.length;\r\n\r\nconst lazyLoadComponentAliasByTagName: Record<string, string> = {};\r\n\r\nexport async function loadFromImportMap(): Promise<void> {\r\n  const importmap = loadImportmap();\r\n  if (importmap.imports) {\r\n    const loadAliasByTagName: Map<string, string> = new Map();\r\n    for (const [alias, value] of Object.entries(importmap.imports)) {\r\n      let tagName, isLazyLoad;\r\n      if (alias.startsWith(ROUTES_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // remove the prefix '@routes' and the suffix '#lazy' if it exists\r\n        const path = alias.slice(ROUTES_KEY.length - 1, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined); \r\n        const pathWithoutParams = path.replace(/:[^\\s/]+/g, \"\"); // remove the params\r\n        tagName = \"routes\" + pathWithoutParams.replace(/\\//g, \"-\"); // replace '/' with '-'\r\n        entryRoute(tagName, path === \"/root\" ? \"/\" : path); // routing\r\n      } if (alias.startsWith(COMPONENTS_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // remove the prefix '@components/' and the suffix '#lazy' if it exists\r\n        tagName = alias.slice(COMPONENTS_KEY.length, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined);\r\n      }\r\n      if (!tagName) {\r\n        continue;\r\n      }\r\n      if (isLazyLoad) {\r\n        // Lazy Load用のコンポーネントのエイリアスを格納\r\n        lazyLoadComponentAliasByTagName[tagName] = alias;\r\n        continue; // Lazy Loadの場合はここでスキップ\r\n      }\r\n      loadAliasByTagName.set(tagName, alias);\r\n    }\r\n    for (const [tagName, alias] of loadAliasByTagName.entries()) {\r\n      // 非Lazy Loadのコンポーネントはここで登録\r\n      const componentData = await loadSingleFileComponent(alias);\r\n      const componentClass = createComponentClass(componentData);\r\n      registerComponentClass(tagName, componentClass);\r\n    }\r\n  }\r\n}\r\n\r\nexport function hasLazyLoadComponents(): boolean {\r\n  return Object.keys(lazyLoadComponentAliasByTagName).length > 0;\r\n}\r\n\r\nexport function isLazyLoadComponent(tagName: string): boolean {\r\n  return lazyLoadComponentAliasByTagName.hasOwnProperty(tagName);\r\n}\r\n\r\nexport function loadLazyLoadComponent(tagName: string): void {\r\n  const alias = lazyLoadComponentAliasByTagName[tagName];\r\n  if (!alias) {\r\n    // 警告として扱うが、構造化メタ情報を付加\r\n    const err = {\r\n      code: \"IMP-201\",\r\n      message: `Alias not found for tagName: ${tagName}`,\r\n      context: { where: 'loadFromImportMap.loadLazyLoadComponent', tagName },\r\n      docsUrl: \"./docs/error-codes.md#imp\",\r\n      severity: \"warn\" as const,\r\n    };\r\n    // 既存挙動は warn + return のため、throw はせず console.warn にメタを付与\r\n    console.warn(err.message, { code: err.code, context: err.context, docsUrl: err.docsUrl, severity: err.severity });\r\n    return;\r\n  }\r\n  delete lazyLoadComponentAliasByTagName[tagName]; // 一度ロードしたら削除\r\n  queueMicrotask(async () => {\r\n    const componentData = await loadSingleFileComponent(alias);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  });\r\n}\r\n","import { raiseError } from \"../utils.js\";\r\nimport { IComponentConfig } from \"../WebComponents/types\";\r\nimport { canHaveShadowRoot } from \"./canHaveShadowRoot.js\";\r\n\r\n/**\r\n * Traverses up the DOM tree to find the nearest parent ShadowRoot.\r\n * Returns undefined if no ShadowRoot is found in the ancestor chain.\r\n *\r\n * @param parentNode - The starting node to traverse from\r\n * @returns The nearest parent ShadowRoot, or undefined if none exists\r\n */\r\nfunction getParentShadowRoot(parentNode: Node | null): ShadowRoot|undefined{\r\n  let node: Node | null = parentNode;\r\n  while(node) {\r\n    if (node instanceof ShadowRoot) {\r\n      return node;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n}\r\n\r\n/**\r\n * Light DOM mode: Adds styles to the parent ShadowRoot or document without using Shadow DOM.\r\n * Prevents duplicate stylesheet additions.\r\n *\r\n * @param element    - Target HTMLElement\r\n * @param styleSheet - CSSStyleSheet to apply\r\n */\r\nfunction attachStyleInLightMode(element: HTMLElement, styleSheet: CSSStyleSheet): void {\r\n  const shadowRootOrDocument = getParentShadowRoot(element.parentNode) || document;\r\n  const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n  if (!styleSheets.includes(styleSheet)) {\r\n    shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, styleSheet];\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a ShadowRoot and applies the stylesheet.\r\n * Skips creation if a ShadowRoot already exists.\r\n *\r\n * @param element    - Target HTMLElement\r\n * @param styleSheet - CSSStyleSheet to apply\r\n */\r\nfunction createShadowRootWithStyle(element: HTMLElement, styleSheet: CSSStyleSheet): void {\r\n  if (!element.shadowRoot) {\r\n    const shadowRoot = element.attachShadow({ mode: 'open' });\r\n    shadowRoot.adoptedStyleSheets = [styleSheet];\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to attach Shadow DOM to the specified HTMLElement and apply a stylesheet.\r\n *\r\n * - config.shadowDomMode=\"auto\": Creates ShadowRoot only for elements that support Shadow DOM, falls back to Light DOM for unsupported elements\r\n *   - Autonomous custom elements: Always creates ShadowRoot\r\n *   - Built-in element extensions: Determined by canHaveShadowRoot; creates ShadowRoot if supported, falls back to Light DOM otherwise\r\n * - config.shadowDomMode=\"force\": Forcefully creates ShadowRoot without validation (throws exception if unsupported)\r\n * - config.shadowDomMode=\"none\": Does not use Shadow DOM; adds styles to parent ShadowRoot or document\r\n * - Prevents duplicate additions if the same stylesheet is already included\r\n *\r\n * @param element - Target HTMLElement\r\n * @param config - Component configuration\r\n * @param styleSheet - CSSStyleSheet to apply\r\n * @throws DOMException if shadowDomMode is \"force\" and element doesn't support Shadow DOM\r\n */\r\nexport function attachShadow(element: HTMLElement, config: IComponentConfig, styleSheet: CSSStyleSheet): void {\r\n  if (config.shadowDomMode === \"none\") {\r\n    attachStyleInLightMode(element, styleSheet);\r\n  } else if (config.shadowDomMode === \"force\") {\r\n    createShadowRootWithStyle(element, styleSheet);\r\n  } else {\r\n    // Auto mode: Creates ShadowRoot only for elements that support Shadow DOM, falls back to Light DOM for unsupported elements\r\n    if (config.extends === null || canHaveShadowRoot(config.extends)) {\r\n      // Autonomous custom element or Shadow DOM-supported built-in element extension\r\n      createShadowRootWithStyle(element, styleSheet);\r\n    } else {\r\n      // Shadow DOM-unsupported built-in element extension → Falls back to Light DOM\r\n      attachStyleInLightMode(element, styleSheet);\r\n    }\r\n  }\r\n}","/**\r\n * Utility function to determine whether an element with the specified tag name can have a ShadowRoot.\r\n *\r\n * - Creates an element with the specified tag name and checks if the attachShadow method exists\r\n * - Returns false for invalid tag names or elements that don't support attachShadow\r\n *\r\n * @param tagName - Tag name of the element to check (e.g., \"div\", \"span\", \"input\")\r\n * @returns true if the element can have a ShadowRoot, false otherwise\r\n */\r\nexport function canHaveShadowRoot(tagName: string): boolean {\r\n  try {\r\n    // Temporarily create an element\r\n    const element = document.createElement(tagName);\r\n    // Check if the `attachShadow` method exists and is callable\r\n    if (typeof element.attachShadow !== \"function\") {\r\n      return false;\r\n    }\r\n    // Attempt to attach a ShadowRoot temporarily\r\n    const shadowRoot = element.attachShadow({ mode: 'open' });\r\n    return true;\r\n  } catch {\r\n    // Return false if an invalid tag name or other error occurs\r\n    return false;\r\n  }\r\n}\r\n","import { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { StructiveComponent } from \"../WebComponents/types\";\r\nimport { IComponentStateBinding } from \"./types\";\r\n\r\n/**\r\n * ComponentStateBinding\r\n *\r\n * Purpose:\r\n * - Associates parent component state paths with child component sub-paths in a one-to-one relationship,\r\n *   enabling bidirectional path conversion and referencing (parent->child/child->parent).\r\n *\r\n * Constraints:\r\n * - Parent path/child path is 1:1 only (duplicate registration results in STATE-303)\r\n * - Performs path conversion with longest match, concatenating lower segments as-is\r\n */\r\nclass ComponentStateBinding implements IComponentStateBinding {\r\n  childPaths: Set<string> = new Set<string>();\r\n  parentPaths: Set<string> = new Set<string>();\r\n  bindingByParentPath: Map<string, IBinding> = new Map();\r\n  bindingByChildPath: Map<string, IBinding> = new Map();\r\n\r\n  private _childPathByParentPath: Map<string, string> = new Map();\r\n  private _parentPathByChildPath: Map<string, string> = new Map();\r\n  private _bindings: WeakSet<IBinding> = new WeakSet();\r\n\r\n  /**\r\n   * Adds a binding to establish parent-child path mapping.\r\n   * Validates that paths are not already mapped and registers the binding.\r\n   * \r\n   * @param binding - IBinding instance to register\r\n   * @throws STATE-303 Parent path already has a child path or child path already has a parent path\r\n   */\r\n  addBinding(binding: IBinding): void {\r\n    if (this._bindings.has(binding)) {\r\n      return; // Skip if binding is already added\r\n    }\r\n    const parentPath = binding.bindingState.pattern;\r\n    const childPath = binding.bindingNode.subName;\r\n    if (this._childPathByParentPath.has(parentPath)) {\r\n      raiseError({\r\n        code: \"STATE-303\",\r\n        message: `Parent path \"${parentPath}\" already has a child path`,\r\n        context: { parentPath, existingChildPath: this._childPathByParentPath.get(parentPath) },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    if (this._parentPathByChildPath.has(childPath)) {\r\n      raiseError({\r\n        code: \"STATE-303\",\r\n        message: `Child path \"${childPath}\" already has a parent path`,\r\n        context: { childPath, existingParentPath: this._parentPathByChildPath.get(childPath) },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    this._childPathByParentPath.set(parentPath, childPath);\r\n    this._parentPathByChildPath.set(childPath, parentPath);\r\n    this.parentPaths.add(parentPath);\r\n    this.childPaths.add(childPath);\r\n    this.bindingByParentPath.set(parentPath, binding);\r\n    this.bindingByChildPath.set(childPath, binding);\r\n    this._bindings.add(binding);\r\n  }\r\n  \r\n  /**\r\n   * Gets the child path mapped to the given parent path.\r\n   * Returns undefined if no mapping exists.\r\n   * \r\n   * @param parentPath - Parent component state path\r\n   * @returns Child path string or undefined\r\n   */\r\n  getChildPath(parentPath: string): string | undefined {\r\n    return this._childPathByParentPath.get(parentPath);\r\n  }\r\n\r\n  /**\r\n   * Gets the parent path mapped to the given child path.\r\n   * Returns undefined if no mapping exists.\r\n   * \r\n   * @param childPath - Child component state path\r\n   * @returns Parent path string or undefined\r\n   */\r\n  getParentPath(childPath: string): string | undefined {\r\n    return this._parentPathByChildPath.get(childPath);\r\n  }\r\n\r\n  /**\r\n   * Converts a child path to its corresponding parent path.\r\n   * Uses longest match algorithm and concatenates remaining segments.\r\n   * Throws error if no matching parent path is found.\r\n   * \r\n   * @param childPath - Child component state path\r\n   * @returns Corresponding parent path string\r\n   * @throws STATE-302 No parent path found for child path\r\n   */\r\n  toParentPathFromChildPath(childPath: string): string {\r\n    // Child to parent: Find longest matching entry in childPaths, concatenate remaining segments to parent\r\n    const childPathInfo = getStructuredPathInfo(childPath);\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No parent path found for child path \"${childPath}\"`,\r\n        context: { childPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = childPath.slice(longestMatchPath.length); // include the dot\r\n    const matchParentPath = this._parentPathByChildPath.get(longestMatchPath);\r\n    if (typeof matchParentPath === \"undefined\") {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No parent path found for child path \"${childPath}\"`,\r\n        context: { childPath, longestMatchPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    return matchParentPath + remainPath;\r\n  }\r\n\r\n  /**\r\n   * Converts a parent path to its corresponding child path.\r\n   * Uses longest match algorithm and concatenates remaining segments.\r\n   * Throws error if no matching child path is found.\r\n   * \r\n   * @param parentPath - Parent component state path\r\n   * @returns Corresponding child path string\r\n   * @throws STATE-302 No child path found for parent path\r\n   */\r\n  toChildPathFromParentPath(parentPath: string): string {\r\n    // Parent to child: Find longest matching entry in parentPaths, concatenate remaining segments to child\r\n    const parentPathInfo = getStructuredPathInfo(parentPath);\r\n    const matchPaths = parentPathInfo.cumulativePathSet.intersection(this.parentPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No child path found for parent path \"${parentPath}\"`,\r\n        context: { parentPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = parentPath.slice(longestMatchPath.length); // include the dot\r\n    const matchChildPath = this._childPathByParentPath.get(longestMatchPath);\r\n    if (typeof matchChildPath === \"undefined\") {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No child path found for parent path \"${parentPath}\"`,\r\n        context: { parentPath, longestMatchPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    return matchChildPath + remainPath;\r\n  }\r\n\r\n  /**\r\n   * Checks if the given child path has a registered mapping.\r\n   * Returns the longest matching child path, or null if no match exists.\r\n   * \r\n   * @param childPathInfo - Structured path information for child path\r\n   * @returns Longest matching child path string or null\r\n   */\r\n  startsWithByChildPath(childPathInfo: IStructuredPathInfo): string | null {\r\n    if (this.childPaths.size === 0) {\r\n      return null;\r\n    }\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      return null;\r\n    } else {\r\n      const matches = Array.from(matchPaths);\r\n      const longestMatchPath = matches[matches.length - 1];\r\n      return longestMatchPath;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Binds parent and child components by collecting and registering all bindings\r\n   * from parent to child component.\r\n   * \r\n   * @param parentComponent - Parent StructiveComponent instance\r\n   * @param childComponent - Child StructiveComponent instance\r\n   */\r\n  bind(parentComponent: StructiveComponent, childComponent: StructiveComponent): void {\r\n    // bindParentComponent\r\n    const bindings = parentComponent.getBindingsFromChild(childComponent);\r\n    for (const binding of bindings ?? []) {\r\n      this.addBinding(binding);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a component state binding instance for managing parent-child state mappings.\r\n * \r\n * @returns IComponentStateBinding instance\r\n */\r\nexport function createComponentStateBinding(): IComponentStateBinding {\r\n  return new ComponentStateBinding();\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { SetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { createUpdater } from \"../Updater/Updater\";\r\nimport { raiseError } from \"../utils\";\r\nimport { AssignStateSymbol, NotifyRedrawSymbol } from \"./symbols\";\r\nimport { IComponentStateInput, IComponentStateInputHandler } from \"./types\";\r\n\r\n/**\r\n * Handler class for ComponentStateInput proxy.\r\n * Manages state property access, assignment, and redraw notifications\r\n * by coordinating with the component engine and state binding.\r\n */\r\nclass ComponentStateInputHandler implements IComponentStateInputHandler {\r\n  private _componentStateBinding: IComponentStateBinding;\r\n  private _engine: IComponentEngine;\r\n  /**\r\n   * Constructor initializes component state input handler.\r\n   * \r\n   * @param engine - Component engine instance\r\n   * @param componentStateBinding - State binding configuration for path mapping\r\n   */\r\n  constructor(engine:IComponentEngine, componentStateBinding: IComponentStateBinding) {\r\n    this._componentStateBinding = componentStateBinding;\r\n    this._engine = engine;\r\n  }\r\n\r\n  /**\r\n   * Assigns multiple state properties from an object synchronously.\r\n   * \r\n   * @param object - Key-value pairs of state properties to assign\r\n   */\r\n  assignState(object: any): void {\r\n    // Synchronous processing\r\n    createUpdater<void>(this._engine, (updater) => {\r\n      updater.update(null, (stateProxy, handler) => {\r\n        for(const [key, value] of Object.entries(object)) {\r\n          const childPathInfo = getStructuredPathInfo(key);\r\n          const childRef = getStatePropertyRef(childPathInfo, null);\r\n          stateProxy[SetByRefSymbol](childRef, value);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notifies the component to redraw based on parent state property changes.\r\n   * Translates parent paths to child paths and enqueues update references.\r\n   * \r\n   * @param refs - Array of parent state property references that have changed\r\n   * @throws LIST-201 ListIndex not found for parent ref\r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    createUpdater<void>(this._engine, (updater) => {\r\n      for(const parentPathRef of refs) {\r\n        let childPath;\r\n        try {\r\n          childPath = this._componentStateBinding.toChildPathFromParentPath(parentPathRef.info.pattern);\r\n        } catch(e) {\r\n          // Ignore non-target paths\r\n          continue;\r\n        }\r\n        const childPathInfo = getStructuredPathInfo(childPath);\r\n        const atIndex = childPathInfo.wildcardCount - 1;\r\n        const childListIndex = (atIndex >= 0) ? (parentPathRef.listIndex?.at(atIndex) ?? null) : null;\r\n        if (atIndex >= 0 && childListIndex === null) {\r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found for parent ref: ${parentPathRef.info.pattern}`,\r\n            context: {\r\n              where: 'ComponentStateInput.notifyRedraw',\r\n              parentPattern: parentPathRef.info.pattern,\r\n              childPattern: childPathInfo.pattern,\r\n            },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n          });\r\n        }\r\n        const childRef = getStatePropertyRef(childPathInfo, childListIndex);\r\n        const value = this._engine.getPropertyValue(childRef);\r\n        // Add to state update queue based on ref information\r\n        updater.enqueueRef(childRef);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Proxy get trap for accessing state properties and symbol-based methods.\r\n   * \r\n   * @param target - Proxy target object\r\n   * @param prop - Property key being accessed\r\n   * @param receiver - Proxy receiver\r\n   * @returns Property value or bound method\r\n   * @throws Error if property is not supported\r\n   */\r\n  get(target:any, prop:PropertyKey, receiver:IComponentStateInput) {\r\n    if (prop === AssignStateSymbol) {\r\n      return this.assignState.bind(this);\r\n    } else if (prop === NotifyRedrawSymbol) {\r\n      return this.notifyRedraw.bind(this);\r\n    } else if (typeof prop === \"string\") {\r\n      const ref = getStatePropertyRef(getStructuredPathInfo(prop), null);\r\n      return this._engine.getPropertyValue(ref);\r\n    }\r\n    raiseError(`Property \"${String(prop)}\" is not supported in ComponentStateInput.`);\r\n  }\r\n\r\n  /**\r\n   * Proxy set trap for updating state properties.\r\n   * \r\n   * @param target - Proxy target object\r\n   * @param prop - Property key being set\r\n   * @param value - New value to assign\r\n   * @param receiver - Proxy receiver\r\n   * @returns true if set operation succeeded\r\n   * @throws Error if property is not supported\r\n   */\r\n  set(target:any, prop:PropertyKey, value:any, receiver:IComponentStateInput): boolean {\r\n    if (typeof prop === \"string\") {\r\n      const ref = getStatePropertyRef(getStructuredPathInfo(prop), null);\r\n      this._engine.setPropertyValue(ref, value);\r\n      return true;\r\n    }\r\n    raiseError(`Property \"${String(prop)}\" is not supported in ComponentStateInput.`);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a component state input proxy for managing parent-child state bindings.\r\n * \r\n * @param engine - Component engine instance\r\n * @param componentStateBinding - State binding configuration for parent-child path mapping\r\n * @returns Proxied component state input interface\r\n */\r\nexport function createComponentStateInput(\r\n  engine: IComponentEngine,\r\n  componentStateBinding: IComponentStateBinding\r\n): IComponentStateInput {\r\n  const handler = new ComponentStateInputHandler(engine, componentStateBinding);\r\n  return new Proxy({}, handler) as IComponentStateInput;\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IComponentStateOutput } from \"./types\";\r\n\r\n/**\r\n * Implementation of component state output that bridges child and parent component states.\r\n * Translates child component state operations to parent component state operations\r\n * using path mapping from the component state binding.\r\n */\r\nclass ComponentStateOutput implements IComponentStateOutput {\r\n  private _binding: IComponentStateBinding;\r\n  private _childEngine: IComponentEngine;\r\n  private _parentPaths: Set<string> = new Set<string>();\r\n  /**\r\n   * Constructor initializes component state output.\r\n   * \r\n   * @param binding - Component state binding for path mapping\r\n   * @param childEngine - Child component engine\r\n   */\r\n  constructor(binding: IComponentStateBinding, childEngine: IComponentEngine) {\r\n    this._binding = binding;\r\n    this._childEngine = childEngine;\r\n  }\r\n\r\n  /**\r\n   * Gets the value of a child state property by delegating to the parent component.\r\n   * Translates the child path to parent path and retrieves the value from parent engine.\r\n   * \r\n   * @param ref - Child state property reference\r\n   * @returns The value from the parent component state\r\n   * @throws CSO-101 No child path found for path\r\n   * @throws CSO-102 No binding found for child path\r\n   */\r\n  get(ref: IStatePropertyRef): any {\r\n    const childPath = this._binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError({\r\n        code: 'CSO-101',\r\n        message: `No child path found for path \"${ref.info.toString()}\".`,\r\n        context: { where: 'ComponentStateOutput.get', path: ref.info.pattern },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentBinding = this._binding.bindingByChildPath.get(childPath);\r\n    if (typeof parentBinding === \"undefined\") {\r\n      raiseError({\r\n        code: 'CSO-102',\r\n        message: `No binding found for child path \"${childPath}\".`,\r\n        context: { where: 'ComponentStateOutput.get', childPath },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentPath = this._binding.toParentPathFromChildPath(ref.info.pattern);\r\n    const parentInfo = getStructuredPathInfo(parentPath);\r\n    const parentRef = getStatePropertyRef(parentInfo, ref.listIndex ?? parentBinding.bindingState.listIndex);\r\n    if (!this._parentPaths.has(parentRef.info.pattern)) {\r\n      const isList = this._childEngine.pathManager.lists.has(ref.info.pattern);\r\n      parentBinding.engine.pathManager.addPath(parentRef.info.pattern, isList);\r\n      this._parentPaths.add(parentRef.info.pattern);\r\n    }\r\n    return parentBinding.engine.getPropertyValue(parentRef);\r\n  }\r\n\r\n  /**\r\n   * Sets the value of a child state property by delegating to the parent component.\r\n   * Translates the child path to parent path and sets the value in parent engine.\r\n   * \r\n   * @param ref - Child state property reference\r\n   * @param value - New value to set\r\n   * @returns true if the operation succeeded\r\n   * @throws CSO-101 No child path found for path\r\n   * @throws CSO-102 No binding found for child path\r\n   */\r\n  set(ref: IStatePropertyRef, value: any): boolean {\r\n    const childPath = this._binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError({\r\n        code: 'CSO-101',\r\n        message: `No child path found for path \"${ref.info.toString()}\".`,\r\n        context: { where: 'ComponentStateOutput.set', path: ref.info.pattern },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentBinding = this._binding.bindingByChildPath.get(childPath);\r\n    if (typeof parentBinding === \"undefined\") {\r\n      raiseError({\r\n        code: 'CSO-102',\r\n        message: `No binding found for child path \"${childPath}\".`,\r\n        context: { where: 'ComponentStateOutput.set', childPath },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentPath = this._binding.toParentPathFromChildPath(ref.info.pattern);\r\n    const parentInfo = getStructuredPathInfo(parentPath);\r\n    const parentRef = getStatePropertyRef(parentInfo, ref.listIndex ?? parentBinding.bindingState.listIndex);\r\n    if (!this._parentPaths.has(parentRef.info.pattern)) {\r\n      const isList = this._childEngine.pathManager.lists.has(ref.info.pattern);\r\n      parentBinding.engine.pathManager.addPath(parentRef.info.pattern, isList);\r\n      this._parentPaths.add(parentRef.info.pattern);\r\n    }\r\n    parentBinding.engine.setPropertyValue(parentRef, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if a given path pattern is handled by this state output.\r\n   * \r\n   * @param pathInfo - Structured path information to check\r\n   * @returns true if the path matches a child path in the binding\r\n   */\r\n  startsWith(pathInfo: IStructuredPathInfo): boolean {\r\n    return this._binding.startsWithByChildPath(pathInfo) !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets list indexes for a child state property by delegating to the parent component.\r\n   * Translates the child path to parent path and retrieves list indexes from parent engine.\r\n   * \r\n   * @param ref - Child state property reference\r\n   * @returns Array of list indexes or null if not a list\r\n   * @throws CSO-101 No child path found for path\r\n   * @throws CSO-102 No binding found for child path\r\n   */\r\n  getListIndexes(ref: IStatePropertyRef): IListIndex[] | null {\r\n    const childPath = this._binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError({\r\n        code: 'CSO-101',\r\n        message: `No child path found for path \"${ref.info.toString()}\".`,\r\n        context: { where: 'ComponentStateOutput.getListIndexes', path: ref.info.pattern },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentBinding = this._binding.bindingByChildPath.get(childPath);\r\n    if (typeof parentBinding === \"undefined\") {\r\n      raiseError({\r\n        code: 'CSO-102',\r\n        message: `No binding found for child path \"${childPath}\".`,\r\n        context: { where: 'ComponentStateOutput.getListIndexes', childPath },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this._binding.toParentPathFromChildPath(ref.info.pattern));\r\n    const parentRef = getStatePropertyRef(parentPathInfo, ref.listIndex);\r\n    if (!this._parentPaths.has(parentRef.info.pattern)) {\r\n      const isList = this._childEngine.pathManager.lists.has(ref.info.pattern);\r\n      parentBinding.engine.pathManager.addPath(parentRef.info.pattern, isList);\r\n      this._parentPaths.add(parentRef.info.pattern);\r\n    }\r\n    return parentBinding.engine.getListIndexes(parentRef);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a component state output instance for bridging child and parent component states.\r\n * \r\n * @param binding - Component state binding for path mapping between child and parent\r\n * @param childEngine - Child component engine for accessing child state metadata\r\n * @returns Component state output interface\r\n */\r\nexport function createComponentStateOutput(binding: IComponentStateBinding, childEngine: IComponentEngine): IComponentStateOutput {\r\n  return new ComponentStateOutput(binding, childEngine);\r\n}","import { createBindContent } from \"../DataBinding/BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { IState, IStructiveState } from \"../StateClass/types\";\r\nimport { ComponentType, IComponentConfig, IComponentStatic, StructiveComponent } from \"../WebComponents/types\";\r\nimport { attachShadow } from \"./attachShadow.js\";\r\nimport { IComponentEngine, ICacheEntry, IVersionRevision, IPropertyRefMetadata } from \"./types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, GetListIndexesByRefSymbol, SetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols.js\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types.js\";\r\nimport { createComponentStateBinding } from \"../ComponentStateBinding/createComponentStateBinding.js\";\r\nimport { createComponentStateInput } from \"../ComponentStateInput/createComponentStateInput.js\";\r\nimport { createComponentStateOutput } from \"../ComponentStateOutput/createComponentStateOutput.js\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { IComponentStateOutput } from \"../ComponentStateOutput/types.js\";\r\nimport { AssignStateSymbol } from \"../ComponentStateInput/symbols.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { createUpdater } from \"../Updater/Updater.js\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef.js\";\r\nimport { RESERVED_WORD_SET } from \"../constants.js\";\r\nimport { addPathNode } from \"../PathTree/PathNode.js\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types.js\";\r\nimport { getCustomTagName } from \"../WebComponents/getCustomTagName.js\";\r\n\r\n/**\r\n * ComponentEngine integrates state, dependencies, bindings, lifecycle, and rendering\r\n * for Structive components as the core engine.\r\n *\r\n * Key Responsibilities:\r\n * - State instance and proxy generation/management\r\n * - Template/stylesheet/filter/binding management\r\n * - Dependency graph (PathTree) construction and maintenance\r\n * - Binding and list information storage/retrieval\r\n * - Lifecycle (connected/disconnected) processing\r\n * - Shadow DOM application or block mode placeholder management\r\n * - State property get/set operations\r\n * - Binding addition, existence checking, and list management\r\n *\r\n * Error Codes:\r\n * - BIND-201: bindContent not initialized yet / Block parent node is not set\r\n * - STATE-202: Failed to parse state from dataset\r\n *\r\n * Design Notes:\r\n * - Provides async initialization via readyResolvers\r\n * - Achieves efficient rendering through batch updates with Updater\r\n */\r\n\r\nclass ComponentEngine implements IComponentEngine {\r\n  // ===== Readonly fields (Core component resources) =====\r\n  /** Component type: 'autonomous' or 'builtin' */\r\n  readonly type: ComponentType = 'autonomous';\r\n  /** Component configuration */\r\n  readonly config: IComponentConfig;\r\n\r\n  /** HTMLTemplateElement for component rendering */\r\n  readonly template: HTMLTemplateElement;\r\n  /** CSSStyleSheet for component styling */\r\n  readonly styleSheet: CSSStyleSheet;\r\n  /** State class constructor */\r\n  readonly stateClass: IStructiveState;\r\n  /** State instance */\r\n  readonly state: IState;\r\n  /** Input filter functions */\r\n  readonly inputFilters: FilterWithOptions;\r\n  /** Output filter functions */\r\n  readonly outputFilters: FilterWithOptions;\r\n  /** Base HTML element class */\r\n  readonly baseClass: typeof HTMLElement = HTMLElement;\r\n  /** Owner component instance */\r\n  readonly owner: StructiveComponent;\r\n\r\n  /** Path manager for dependency tracking */\r\n  readonly pathManager: IPathManager;\r\n  /** Promise resolvers for async initialization */\r\n  readonly readyResolvers: PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n\r\n  /** State input proxy for parent-to-child communication */\r\n  readonly stateInput: IComponentStateInput;\r\n  /** State output proxy for child-to-parent communication */\r\n  readonly stateOutput: IComponentStateOutput;\r\n  /** State binding for parent-child relationship */\r\n  readonly stateBinding: IComponentStateBinding;\r\n\r\n  /** Map of child components to their bindings */\r\n  readonly bindingsByComponent: WeakMap<StructiveComponent, Set<IBinding>> = new WeakMap();\r\n  /** Set of child Structive components */\r\n  readonly structiveChildComponents: Set<StructiveComponent> = new Set();\r\n  /** Version and revision tracking by path */\r\n  readonly versionRevisionByPath: Map<string, IVersionRevision> = new Map();\r\n\r\n  // ===== Private fields (Internal state) =====\r\n  /** Bind content instance (initialized in setup()) */\r\n  private _bindContent: IBindContent | null = null;\r\n  /** Block mode placeholder comment node */\r\n  private _blockPlaceholder: Comment | null = null;\r\n  /** Block mode placeholder parent node */\r\n  private _blockParentNode: Node | null = null;\r\n  /** Flag to ignore disconnectedCallback during replaceWith */\r\n  private _ignoreDissconnectedCallback: boolean = false;\r\n  /** Current version number for change tracking */\r\n  private _currentVersion: number = 0;\r\n  /** WeakMap storing binding metadata by property reference */\r\n  private _propertyRefMetadataByRef: WeakMap<IStatePropertyRef, IPropertyRefMetadata> = new WeakMap();\r\n\r\n  /**\r\n   * Constructs a new ComponentEngine instance.\r\n   * Initializes all readonly fields and creates state management infrastructure.\r\n   * \r\n   * @param config - Component configuration\r\n   * @param owner - Owner component instance\r\n   */\r\n  constructor(config: IComponentConfig, owner: StructiveComponent) {\r\n    this.config = config;\r\n    // Set type to 'builtin' if extending native elements\r\n    if (this.config.extends) {\r\n      this.type = 'builtin';\r\n    }\r\n    const componentClass = owner.constructor as IComponentStatic;\r\n    this.template = componentClass.template;\r\n    this.styleSheet = componentClass.styleSheet;\r\n    this.stateClass = componentClass.stateClass;\r\n    this.state = new this.stateClass();\r\n    this.inputFilters = componentClass.inputFilters;\r\n    this.outputFilters = componentClass.outputFilters;\r\n    this.owner = owner;\r\n    this.stateBinding = createComponentStateBinding();\r\n    this.stateInput = createComponentStateInput(this, this.stateBinding);\r\n    this.stateOutput = createComponentStateOutput(this.stateBinding, this);\r\n    this.pathManager = componentClass.pathManager;\r\n  }\r\n\r\n  // ===== Getters =====\r\n  /**\r\n   * Gets the bind content instance.\r\n   * Throws BIND-201 if accessed before setup() is called.\r\n   * \r\n   * @returns IBindContent instance\r\n   * @throws BIND-201 bindContent not initialized yet\r\n   */\r\n  get bindContent(): IBindContent {\r\n    if (this._bindContent === null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'bindContent not initialized yet',\r\n        context: { where: 'ComponentEngine.bindContent.get', componentId: (this.owner.constructor as IComponentStatic).id },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    return this._bindContent;\r\n  }\r\n\r\n  /**\r\n   * Gets the current version number for change tracking.\r\n   * \r\n   * @returns Current version number\r\n   */\r\n  get currentVersion(): number {\r\n    return this._currentVersion;\r\n  }\r\n\r\n  // ===== Public methods =====\r\n  /**\r\n   * Increments and returns the version number.\r\n   * Used for invalidating caches when state changes.\r\n   * \r\n   * @returns New version number\r\n   */\r\n  versionUp(): number {\r\n    return ++this._currentVersion;\r\n  }\r\n\r\n  /**\r\n   * Sets up the component engine.\r\n   * Registers all state properties to PathManager and creates bindContent.\r\n   * Must be called after construction and before connectedCallback.\r\n   */\r\n  setup(): void {\r\n    // Register all instantiated state object properties to PathManager\r\n    // TODO: Should traverse prototype chain for inherited properties\r\n    for(const path in this.state) {\r\n      if (RESERVED_WORD_SET.has(path) || this.pathManager.alls.has(path)) {\r\n        continue;\r\n      }\r\n      this.pathManager.alls.add(path);\r\n      addPathNode(this.pathManager.rootNode, path);\r\n    }\r\n    const componentClass = this.owner.constructor as IComponentStatic;\r\n    const rootRef = getStatePropertyRef(getStructuredPathInfo(''), null);\r\n    // Create bindContent (may modify stateArrayPropertyNamePatterns)\r\n    this._bindContent = createBindContent(null, componentClass.id, this, rootRef);\r\n  }\r\n\r\n  /**\r\n   * Handles component connection to DOM.\r\n   * - Attaches Shadow DOM or sets up block mode placeholder\r\n   * - Mounts bindContent\r\n   * - Initializes state from data-state attribute if present\r\n   * - Performs initial render\r\n   * - Calls state's connectedCallback if defined\r\n   * \r\n   * Why not do this in setup():\r\n   * - setup() is called at component instantiation\r\n   * - connectedCallback() is called when connected to DOM\r\n   * - State initialization and rendering must be redone if reconnected after disconnect\r\n   * \r\n   * @throws BIND-201 Block parent node is not set\r\n   * @throws STATE-202 Failed to parse state from dataset\r\n   */\r\n  async connectedCallback(): Promise<void> {\r\n    if (this.config.enableWebComponents) {\r\n      attachShadow(this.owner, this.config, this.styleSheet);\r\n    } else {\r\n      // Block mode: Replace component with placeholder\r\n      this._blockParentNode = this.owner.parentNode;\r\n      this._blockPlaceholder = document.createComment(\"Structive block placeholder\");\r\n      try {\r\n        // Set flag to ignore disconnectedCallback triggered by replaceWith\r\n        this._ignoreDissconnectedCallback = true;\r\n        this.owner.replaceWith(this._blockPlaceholder);\r\n      } finally {\r\n        this._ignoreDissconnectedCallback = false;\r\n      }\r\n    }\r\n\r\n    if (this.config.enableWebComponents) {\r\n      // Mount bind content to Shadow DOM\r\n      this.bindContent.mount(this.owner.shadowRoot ?? this.owner);\r\n    } else {\r\n      // Mount bind content after block placeholder\r\n      const parentNode = this._blockParentNode ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Block parent node is not set',\r\n        context: { where: 'ComponentEngine.connectedCallback', mode: 'block' },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n      this.bindContent.mountAfter(parentNode, this._blockPlaceholder);\r\n    }\r\n\r\n    // Initialize component state from data-state attribute if present\r\n    if (this.owner.dataset.state) {\r\n      try {\r\n        const json = JSON.parse(this.owner.dataset.state);\r\n        this.stateInput[AssignStateSymbol](json);\r\n      } catch(e) {\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'Failed to parse state from dataset',\r\n          context: { where: 'ComponentEngine.connectedCallback', datasetState: this.owner.dataset.state },\r\n          docsUrl: './docs/error-codes.md#state',\r\n          cause: e as any,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Perform initial render\r\n    createUpdater<void>(this, (updater) => {\r\n      updater.initialRender((renderer) => {\r\n        this.bindContent.activate();\r\n        renderer.createReadonlyState( (readonlyState, readonlyHandler) => {\r\n          this.bindContent.applyChange(renderer);\r\n        } );\r\n      });\r\n    });\r\n\r\n    // Call state's connectedCallback if implemented\r\n    if (this.pathManager.hasConnectedCallback) {\r\n      const resultPromise = createUpdater<Promise<void>>(this, async (updater) => {\r\n        return updater.update(null, async (stateProxy, handler) => {\r\n          stateProxy[ConnectedCallbackSymbol]();\r\n        });\r\n      });\r\n      if (resultPromise instanceof Promise) {\r\n        await resultPromise;\r\n      }\r\n    }\r\n    this.readyResolvers.resolve();\r\n  }\r\n\r\n  /**\r\n   * Handles component disconnection from DOM.\r\n   * - Calls state's disconnectedCallback if defined\r\n   * - Unregisters from parent component\r\n   * - Removes block placeholder if in block mode\r\n   * - Inactivates and unmounts bindContent\r\n   */\r\n  async disconnectedCallback(): Promise<void> {\r\n    // Ignore if flag is set (during replaceWith in connectedCallback)\r\n    if (this._ignoreDissconnectedCallback) return;\r\n\r\n    try {\r\n      // Call state's disconnectedCallback if implemented (synchronous)\r\n      if (this.pathManager.hasDisconnectedCallback) {\r\n        createUpdater<void>(this, (updater) => {\r\n          updater.update(null, (stateProxy, handler) => {\r\n            stateProxy[DisconnectedCallbackSymbol]();\r\n          });\r\n        });\r\n      }\r\n    } finally {\r\n      // Unregister from parent component\r\n      this.owner.parentStructiveComponent?.unregisterChildComponent(this.owner);\r\n      if (!this.config.enableWebComponents) {\r\n        this._blockPlaceholder?.remove();\r\n        this._blockPlaceholder = null;\r\n        this._blockParentNode = null;\r\n      }\r\n      // Inactivate state and unmount (bindContent.unmount is called within inactivate)\r\n      createUpdater<void>(this, (updater) => {\r\n        updater.initialRender((renderer) => {\r\n          this.bindContent.inactivate();\r\n        });\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Gets list indexes for a property reference.\r\n   * Delegates to stateOutput if the path matches parent-child binding.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Array of list indexes or null if not a list\r\n   */\r\n  getListIndexes(ref: IStatePropertyRef): IListIndex[] | null {\r\n    if (this.stateOutput.startsWith(ref.info)) {\r\n      return this.stateOutput.getListIndexes(ref);\r\n    }\r\n    let value: IListIndex[] | null = null;\r\n    // Synchronous operation\r\n    createUpdater<any>(this, (updater) => {\r\n      value = updater.createReadonlyState<IListIndex[] | null>((stateProxy, handler) => {\r\n        return stateProxy[GetListIndexesByRefSymbol](ref);\r\n      });\r\n    });\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Gets a property value by reference.\r\n   * Uses readonly state proxy to access the value synchronously.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Property value\r\n   */\r\n  getPropertyValue(ref: IStatePropertyRef): any {\r\n    let value;\r\n    // Synchronous operation\r\n    createUpdater<any>(this, (updater) => {\r\n      value = updater.createReadonlyState<any>((stateProxy, handler) => {\r\n        return stateProxy[GetByRefSymbol](ref);\r\n      });\r\n    });\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Sets a property value by reference.\r\n   * Uses writable state proxy to set the value synchronously.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param value - New value to set\r\n   */\r\n  setPropertyValue(ref: IStatePropertyRef, value: any): void {\r\n    // Synchronous operation\r\n    createUpdater<void>(this, (updater) => {\r\n      updater.update(null, (stateProxy, handler) => {\r\n        stateProxy[SetByRefSymbol](ref, value);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Registers a child Structive component.\r\n   * Used for parent-child relationship tracking.\r\n   * \r\n   * @param component - Child StructiveComponent instance to register\r\n   */\r\n  registerChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.add(component);\r\n  }\r\n\r\n  /**\r\n   * Unregisters a child Structive component.\r\n   * Called when child is disconnected or destroyed.\r\n   * \r\n   * @param component - Child StructiveComponent instance to unregister\r\n   */\r\n  unregisterChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.delete(component);\r\n  }\r\n\r\n  /**\r\n   * Gets the cache entry for a property reference.\r\n   * Returns null if no cache exists.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Cache entry or null\r\n   */\r\n  getCacheEntry(ref: IStatePropertyRef): ICacheEntry | null {\r\n    return this._propertyRefMetadataByRef.get(ref)?.cacheEntry ?? null;\r\n  }\r\n\r\n  /**\r\n   * Sets the cache entry for a property reference.\r\n   * Creates a new PropertyRefMetadata if it doesn't exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param entry - Cache entry to set\r\n   */\r\n  setCacheEntry(ref: IStatePropertyRef, entry: ICacheEntry): void {\r\n    let metadata = this._propertyRefMetadataByRef.get(ref);\r\n    if (typeof metadata === \"undefined\") {\r\n      this._propertyRefMetadataByRef.set(ref, { bindings: [], cacheEntry: entry });\r\n    } else {\r\n      metadata.cacheEntry = entry;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets all bindings associated with a property reference.\r\n   * Returns empty array if no bindings exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Array of IBinding instances\r\n   */\r\n  getBindings(ref: IStatePropertyRef): IBinding[] {\r\n    return this._propertyRefMetadataByRef.get(ref)?.bindings ?? [];\r\n  }\r\n\r\n  /**\r\n   * Saves a binding for a property reference.\r\n   * Creates a new PropertyRefMetadata if it doesn't exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param binding - IBinding instance to save\r\n   */\r\n  saveBinding(ref: IStatePropertyRef, binding: IBinding): void {\r\n    const metadata = this._propertyRefMetadataByRef.get(ref);\r\n    if (typeof metadata === \"undefined\") {\r\n      this._propertyRefMetadataByRef.set(ref, { bindings: [binding], cacheEntry: null });\r\n    } else {\r\n      metadata.bindings.push(binding);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a binding from a property reference.\r\n   * Does nothing if the binding doesn't exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param binding - IBinding instance to remove\r\n   */\r\n  removeBinding(ref: IStatePropertyRef, binding: IBinding): void {\r\n    const metadata = this._propertyRefMetadataByRef.get(ref);\r\n    if (typeof metadata !== \"undefined\") {\r\n      const index = metadata.bindings.indexOf(binding);\r\n      if (index >= 0) {\r\n        metadata.bindings.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n * Factory function to create a ComponentEngine instance.\r\n * \r\n * @param config - Component configuration\r\n * @param component - Owner component instance\r\n * @returns A new ComponentEngine instance\r\n */\r\nexport function createComponentEngine(config: IComponentConfig, component: StructiveComponent): IComponentEngine {\r\n  return new ComponentEngine(config, component);\r\n}","/**\r\n * replaceMustacheWithTemplateTag.ts\r\n *\r\n * Mustache構文（{{if:条件}}, {{for:式}}, {{endif}}, {{endfor}}, {{elseif:条件}}, {{else}} など）を\r\n * <template>タグやコメントノードに変換するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - HTML文字列内のMustache構文を正規表現で検出し、<template data-bind=\"...\">やコメントノードに変換\r\n * - if/for/endif/endfor/elseif/elseなどの制御構文をネスト対応で<template>タグに変換\r\n * - 通常の埋め込み式（{{expr}}）はコメントノード（<!--embed:expr-->）に変換\r\n *\r\n * 設計ポイント:\r\n * - stackでネスト構造を管理し、endif/endfor/elseif/elseの対応関係を厳密にチェック\r\n * - 不正なネストや対応しない構文にはraiseErrorで例外を発生\r\n * - elseif/elseはnot条件のtemplateを自動生成し、条件分岐を表現\r\n * - コメントノードへの変換で埋め込み式の安全なDOM挿入を実現\r\n */\r\nimport { COMMENT_EMBED_MARK } from \"../constants.js\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst MUSTACHE_REGEXP = /\\{\\{([^\\}]+)\\}\\}/g;\r\nconst MUSTACHE_TYPES:Set<string> = new Set(['if', 'for', 'endif', 'endfor', 'elseif', 'else']);\r\n\r\ntype MustacheType = 'if' | 'for' | 'endif' | 'endfor' | 'elseif' | 'else';\r\ntype MustacheInfo = {\r\n  type: MustacheType;\r\n  remain: string; // after first ':'\r\n  expr: string;\r\n}\r\n\r\nexport function replaceMustacheWithTemplateTag(html: string): string {\r\n  const stack:MustacheInfo[] = [];\r\n  return html.replaceAll(MUSTACHE_REGEXP, (match, expr) => {\r\n    expr = expr.trim();\r\n    const [ type ] = expr.split(':');\r\n    if (!MUSTACHE_TYPES.has(type)) {\r\n      // embed\r\n      return `<!--${COMMENT_EMBED_MARK}${expr}-->`;\r\n    }\r\n    const remain = expr.slice(type.length + 1).trim();\r\n    const currentInfo:MustacheInfo = { type, expr, remain };\r\n    if (type === 'if' || type === 'for') {\r\n      stack.push(currentInfo);\r\n      return `<template data-bind=\"${expr}\">`;\r\n    } else if (type === 'endif') {\r\n      const endTags = [];\r\n      do {\r\n        const info = stack.pop() ?? raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Endif without if',\r\n          context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n        if (info.type === 'if') {\r\n          endTags.push('</template>');\r\n          break;\r\n        } else if (info.type === 'elseif') {\r\n          endTags.push('</template>');\r\n        } else {\r\n          raiseError({\r\n            code: 'TMP-102',\r\n            message: 'Endif without if',\r\n            context: { where: 'replaceMustacheWithTemplateTag', got: info.type, expr },\r\n            docsUrl: './docs/error-codes.md#tmp',\r\n          });\r\n        }\r\n      } while(true);\r\n      return endTags.join('');\r\n    } else if (type === 'endfor') {\r\n      const info = stack.pop() ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Endfor without for',\r\n        context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      if (info.type === 'for') {\r\n        return '</template>';\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Endfor without for',\r\n          context: { where: 'replaceMustacheWithTemplateTag', got: info.type, expr },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n    } else if (type === 'elseif') {\r\n      const lastInfo = stack.at(-1) ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Elseif without if',\r\n        context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      if (lastInfo.type === 'if' || lastInfo.type === 'elseif') {\r\n        stack.push(currentInfo);\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\"><template data-bind=\"if:${remain}\">`;\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Elseif without if',\r\n          context: { where: 'replaceMustacheWithTemplateTag', got: lastInfo.type, expr },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n    } else if (type === 'else') {\r\n      const lastInfo = stack.at(-1) ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Else without if',\r\n        context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      if (lastInfo.type === 'if') {\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\">`;\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Else without if',\r\n          context: { where: 'replaceMustacheWithTemplateTag', got: lastInfo.type, expr },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n    } else {\r\n      raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Unknown type',\r\n        context: { where: 'replaceMustacheWithTemplateTag', type, expr },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n\r\n\r\n","/**\r\n * replaceTemplateTagWithComment.ts\r\n *\r\n * <template>タグをコメントノードに置換し、テンプレートを再帰的に登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定したHTMLTemplateElementをコメントノード（<!--template:id-->）に置換\r\n * - SVG内のtemplateタグは通常のtemplate要素に変換し、属性や子ノードを引き継ぐ\r\n * - テンプレート内の入れ子templateも再帰的に置換・登録\r\n * - registerTemplateでテンプレートをID付きで管理\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの階層構造を維持しつつ、DOM上はコメントノードでマーク\r\n * - SVG対応や属性引き継ぎなど、汎用的なテンプレート処理に対応\r\n * - generateIdでユニークIDを割り当て、テンプレート管理を一元化\r\n */\r\nimport { COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { config } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { registerTemplate } from \"./registerTemplate.js\";\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\nexport function replaceTemplateTagWithComment(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number = id\r\n):number {\r\n  // テンプレートの親ノードが存在する場合は、テンプレートをコメントノードに置き換える\r\n\r\n  // デバッグ時、bindTextの内容をコメントに含める\r\n  const bindText = template.getAttribute(DATA_BIND_ATTRIBUTE);\r\n  const bindTextForDebug = config.debug ? (bindText ?? \"\") : \"\";\r\n  template.parentNode?.replaceChild(document.createComment(`${COMMENT_TEMPLATE_MARK}${id} ${bindTextForDebug}`), template);\r\n  if (template.namespaceURI === SVG_NS) {\r\n    // SVGタグ内のtemplateタグを想定\r\n    const newTemplate = document.createElement(\"template\");\r\n    const childNodes = Array.from(template.childNodes);\r\n    for(let i = 0; i < childNodes.length; i++) {\r\n      const childNode = childNodes[i];\r\n      newTemplate.content.appendChild(childNode);\r\n    }\r\n    newTemplate.setAttribute(DATA_BIND_ATTRIBUTE, bindText ?? \"\");\r\n    template = newTemplate;\r\n  }\r\n  template.content.querySelectorAll(\"template\").forEach(template => {\r\n    replaceTemplateTagWithComment(generateId(), template, rootId);\r\n  });\r\n  registerTemplate(id, template, rootId);\r\n  return id;\r\n}\r\n","/**\r\n * registerHtml.ts\r\n *\r\n * HTML文字列をテンプレートとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定IDでHTMLテンプレートを生成し、data-id属性を付与\r\n * - Mustache構文（{{ }})をテンプレートタグに変換（replaceMustacheWithTemplateTagを利用）\r\n * - テンプレートタグをコメントに置換（replaceTemplateTagWithCommentを利用）\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの動的生成・管理や、構文変換による柔軟なテンプレート処理に対応\r\n * - テンプレートはdocument.createElement(\"template\")で生成し、data-idで識別\r\n */\r\nimport { replaceMustacheWithTemplateTag } from \"./replaceMustacheWithTemplateTag.js\";\r\nimport { replaceTemplateTagWithComment } from \"./replaceTemplateTagWithComment.js\";\r\n\r\nexport function registerHtml(id: number, html:string) {\r\n  const template = document.createElement(\"template\");\r\n  template.dataset.id = id.toString();\r\n  template.innerHTML = replaceMustacheWithTemplateTag(html);\r\n  replaceTemplateTagWithComment(id, template);\r\n}","/**\r\n * createAccessorFunctions.ts\r\n *\r\n * Stateプロパティのパス情報（IStructuredPathInfo）から、動的なgetter/setter関数を生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス情報とgetter集合から、最適なアクセサ関数（get/set）を動的に生成\r\n * - ワイルドカード（*）やネストしたプロパティパスにも対応\r\n * - パスやセグメントのバリデーションも実施\r\n *\r\n * 設計ポイント:\r\n * - matchPathsから最長一致のgetterパスを探索し、そこからの相対パスでアクセサを構築\r\n * - パスが一致しない場合はinfo.pathSegmentsから直接アクセサを生成\r\n * - new Functionで高速なgetter/setterを動的生成\r\n * - パスやセグメント名は正規表現で厳密にチェックし、安全性を担保\r\n */\r\nimport { getStructuredPathInfo } from \"./getStructuredPathInfo\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IAccessorFunctions, IStructuredPathInfo } from \"./types\";\r\n\r\nconst checkSegmentRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\nconst checkPathRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*(\\.[a-zA-Z_$][0-9a-zA-Z_$]*|\\.\\*)*$/;\r\n\r\nexport function createAccessorFunctions(info: IStructuredPathInfo, getters: Set<string>): IAccessorFunctions {\r\n  const matchPaths = new Set(info.cumulativePaths).intersection(getters);\r\n  let len = -1;\r\n  let matchPath = '';\r\n  for(const curPath of matchPaths) {\r\n    const pathSegments = curPath.split('.');\r\n    if (pathSegments.length === 1) {\r\n      continue;\r\n    }\r\n    if (pathSegments.length > len) {\r\n      len = pathSegments.length;\r\n      matchPath = curPath;\r\n    }\r\n  }\r\n  if (matchPath.length > 0) {\r\n    if (!checkPathRegexp.test(matchPath)) {\r\n      raiseError({\r\n        code: \"STATE-202\",\r\n        message: `Invalid path: ${matchPath}`,\r\n        context: { matchPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchInfo = getStructuredPathInfo(matchPath);\r\n    const segments = [];\r\n    let count = matchInfo.wildcardCount;\r\n    for(let i = matchInfo.pathSegments.length; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          raiseError({\r\n            code: \"STATE-202\",\r\n            message: `Invalid segment name: ${segment}`,\r\n            context: { segment, matchPath },\r\n            docsUrl: \"./docs/error-codes.md#state\",\r\n          });\r\n        }\r\n        segments.push(\".\" + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    const getterFuncText = `return this[\"${matchPath}\"]${path};`;\r\n    const setterFuncText = `this[\"${matchPath}\"]${path} = value;`;\r\n    //console.log('path/getter/setter:', info.pattern, getterFuncText, setterFuncText);\r\n    return {\r\n      get : new Function('', getterFuncText) as ()=> any,\r\n      set : new Function('value', setterFuncText) as (value: any) => void,\r\n    }\r\n  } else {\r\n    const segments = [];\r\n    let count = 0;\r\n    for(let i = 0; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          raiseError({\r\n            code: \"STATE-202\",\r\n            message: `Invalid segment name: ${segment}`,\r\n            context: { segment },\r\n            docsUrl: \"./docs/error-codes.md#state\",\r\n          });\r\n        }\r\n        segments.push((segments.length > 0 ? \".\" : \"\") + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    const getterFuncText = `return this.${path};`;\r\n    const setterFuncText = `this.${path} = value;`;\r\n    //console.log('path/getter/setter:', info.pattern, getterFuncText, setterFuncText);\r\n    return {\r\n      get : new Function('', getterFuncText) as ()=> any,\r\n      set : new Function('value', setterFuncText) as (value: any) => void,\r\n    }\r\n  }\r\n\r\n}\r\n","import { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes\";\r\nimport { CONNECTED_CALLBACK_FUNC_NAME, DISCONNECTED_CALLBACK_FUNC_NAME, RESERVED_WORD_SET, UPDATED_CALLBACK_FUNC_NAME } from \"../constants\";\r\nimport { addPathNode, createRootNode } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { Constructor } from \"../types\";\r\nimport { StructiveComponentClass } from \"../WebComponents/types\";\r\nimport { Dependencies, IPathManager } from \"./types\";\r\n\r\nclass PathManager implements IPathManager {\r\n  alls: Set<string> = new Set<string>();\r\n  lists: Set<string> = new Set<string>();\r\n  elements: Set<string> = new Set<string>();\r\n  funcs: Set<string> = new Set<string>();\r\n  getters: Set<string> = new Set<string>();\r\n  onlyGetters: Set<string> = new Set<string>();\r\n  setters: Set<string> = new Set<string>();\r\n  getterSetters: Set<string> = new Set<string>();\r\n  optimizes: Set<string> = new Set<string>();\r\n  staticDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  dynamicDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  rootNode: IPathNode = createRootNode();\r\n  hasConnectedCallback: boolean = false;\r\n  hasDisconnectedCallback: boolean = false;\r\n  hasUpdatedCallback: boolean = false;\r\n  #id: number;\r\n  #stateClass: Constructor<any>;\r\n\r\n  constructor(componentClass: StructiveComponentClass) {\r\n    this.#id = componentClass.id;\r\n    this.#stateClass = componentClass.stateClass;\r\n    const alls = getPathsSetById(this.#id);\r\n    const listsFromAlls = new Set<string>();\r\n    for(const path of alls) {\r\n      const info = getStructuredPathInfo(path);\r\n      this.alls = this.alls.union(info.cumulativePathSet);\r\n      // Check all paths in cumulativePathSet for wildcards\r\n      for(const cumulativePath of info.cumulativePathSet) {\r\n        const cumulativeInfo = getStructuredPathInfo(cumulativePath);\r\n        if (cumulativeInfo.lastSegment === \"*\") {\r\n          listsFromAlls.add(cumulativeInfo.parentPath!);\r\n        }\r\n      }\r\n    }\r\n    const lists = getListPathsSetById(this.#id);\r\n    this.lists = this.lists.union(lists).union(listsFromAlls);\r\n    for(const listPath of this.lists) {\r\n      const elementPath = listPath + \".*\";\r\n      this.elements.add(elementPath);\r\n    }\r\n    let currentProto = this.#stateClass.prototype;\r\n    while (currentProto && currentProto !== Object.prototype) {\r\n      const getters = Object.getOwnPropertyDescriptors(currentProto);\r\n      if (getters) {\r\n        for (const [key, desc] of Object.entries(getters)) {\r\n          if (RESERVED_WORD_SET.has(key)) {\r\n            continue;\r\n          }\r\n          if (typeof desc.value === \"function\") {\r\n            this.funcs.add(key);\r\n            if (key === CONNECTED_CALLBACK_FUNC_NAME) {\r\n              this.hasConnectedCallback = true;\r\n            }\r\n            if (key === DISCONNECTED_CALLBACK_FUNC_NAME) {\r\n              this.hasDisconnectedCallback = true;\r\n            }\r\n            if (key === UPDATED_CALLBACK_FUNC_NAME) {\r\n              this.hasUpdatedCallback = true;\r\n            }\r\n            continue;\r\n          }\r\n          const hasGetter = (desc as PropertyDescriptor).get !== undefined;\r\n          const hasSetter = (desc as PropertyDescriptor).set !== undefined;\r\n          const info = getStructuredPathInfo(key);\r\n          this.alls = this.alls.union(info.cumulativePathSet);\r\n          if (hasGetter) {\r\n            this.getters.add(key);\r\n          }\r\n          if (hasSetter) {\r\n            this.setters.add(key);\r\n          }\r\n          if (hasGetter && !hasSetter) {\r\n            this.onlyGetters.add(key);\r\n          }\r\n          if (hasGetter && hasSetter) {\r\n            this.getterSetters.add(key);\r\n          }\r\n        }\r\n      }\r\n      currentProto = Object.getPrototypeOf(currentProto);\r\n    }\r\n    // 最適化対象のパスを決定し、最適化する\r\n    for(const path of this.alls) {\r\n      if (this.getters.has(path)) {\r\n        continue;\r\n      }\r\n      if (this.setters.has(path)) {\r\n        continue;\r\n      }\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.pathSegments.length === 1) {\r\n        continue;\r\n      }\r\n      const funcs = createAccessorFunctions(info, this.getters);\r\n      Object.defineProperty(this.#stateClass.prototype, path, {\r\n        get: funcs.get,\r\n        set: funcs.set,\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n      this.optimizes.add(path);\r\n    }\r\n    // 静的依存関係の設定\r\n    for(const path of this.alls) {\r\n      addPathNode(this.rootNode, path);\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.parentPath) {\r\n        this.staticDependencies.get(info.parentPath)?.add(path) ?? \r\n          this.staticDependencies.set(info.parentPath, new Set([path]));\r\n      }\r\n    }\r\n  }\r\n  \r\n  addPath(addPath: string, isList: boolean = false): void {\r\n    const info = getStructuredPathInfo(addPath);\r\n    if (isList && !this.lists.has(addPath)) {\r\n      this.lists.add(addPath);\r\n      const elementPath = addPath + \".*\";\r\n      this.elements.add(elementPath);\r\n    } else if (info.lastSegment === \"*\") {\r\n      this.elements.add(addPath);\r\n      this.lists.add(info.parentPath!);\r\n    }\r\n    for(const path of info.cumulativePathSet) {\r\n      if (this.alls.has(path)) continue;\r\n      this.alls.add(path);\r\n      addPathNode(this.rootNode, path);\r\n      const pathInfo = getStructuredPathInfo(path);\r\n      if (pathInfo.lastSegment === \"*\") {\r\n        this.elements.add(path);\r\n        this.lists.add(pathInfo.parentPath!);\r\n      }      \r\n      if (pathInfo.pathSegments.length > 1) {\r\n        const funcs = createAccessorFunctions(pathInfo, this.getters);\r\n        Object.defineProperty(this.#stateClass.prototype, path, {\r\n          get: funcs.get,\r\n          set: funcs.set,\r\n          enumerable: true,\r\n          configurable: true,\r\n        });\r\n        this.optimizes.add(path);\r\n      }\r\n\r\n      if (pathInfo.parentPath) {\r\n        this.staticDependencies.get(pathInfo.parentPath)?.add(path) ?? \r\n          this.staticDependencies.set(pathInfo.parentPath, new Set([path]));\r\n      }\r\n    }\r\n  }\r\n  #dynamicDependencyKeys = new Set<string>();\r\n  addDynamicDependency(target: string, source: string) {\r\n    const key = source + \"=>\" + target;\r\n    if (this.#dynamicDependencyKeys.has(key)) {\r\n      return;\r\n    }\r\n    if (!this.alls.has(source)) {\r\n      this.addPath(source)\r\n    }\r\n    this.#dynamicDependencyKeys.add(key);\r\n    this.dynamicDependencies.get(source)?.add(target) ?? \r\n      this.dynamicDependencies.set(source, new Set([target]));\r\n  }\r\n}\r\n\r\nexport function createPathManager(componentClass: StructiveComponentClass): IPathManager {\r\n  return new PathManager(componentClass);\r\n}","/**\r\n * createComponentClass.ts\r\n *\r\n * StructiveのWeb Components用カスタム要素クラスを動的に生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - ユーザー定義のcomponentData（stateClass, html, css等）からWeb Componentsクラスを生成\r\n * - StateClass/テンプレート/CSS/バインディング情報などをIDで一元管理・登録\r\n * - 独自のget/setトラップやバインディング、親子コンポーネント探索、フィルター拡張など多機能な基盤を提供\r\n * - 静的プロパティでテンプレート・スタイル・StateClass・フィルター・getter情報などにアクセス可能\r\n * - defineメソッドでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - findStructiveParentで親Structiveコンポーネントを探索し、階層的な状態管理を実現\r\n * - getter/setter/バインディング最適化に対応\r\n * - テンプレート・CSS・StateClass・バインディング情報をIDで一元管理し、再利用性・拡張性を確保\r\n * - フィルターやバインディング情報も静的プロパティで柔軟に拡張可能\r\n */\r\nimport { inputBuiltinFilters, outputBuiltinFilters } from \"../Filter/builtinFilters.js\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { getStateClassById, registerStateClass } from \"../StateClass/registerStateClass.js\";\r\nimport { getStyleSheetById } from \"../StyleSheet/registerStyleSheet.js\";\r\nimport { registerCss } from \"../StyleSheet/regsiterCss.js\";\r\nimport { createComponentEngine } from \"../ComponentEngine/ComponentEngine.js\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types.js\";\r\nimport { registerHtml } from \"../Template/registerHtml.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { getBaseClass } from \"./getBaseClass.js\";\r\nimport { getComponentConfig } from \"./getComponentConfig.js\";\r\nimport { IComponent, IUserComponentData, IUserConfig, StructiveComponentClass, StructiveComponent } from \"./types\";\r\nimport { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions.js\";\r\nimport { config as globalConfig } from \"./getGlobalConfig.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { findStructiveParent } from \"./findStructiveParent.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { createPathManager } from \"../PathManager/PathManager.js\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types.js\";\r\n\r\n\r\nexport function createComponentClass(componentData: IUserComponentData): StructiveComponentClass {\r\n  const config = (componentData.stateClass.$config ?? {})as IUserConfig;\r\n  const componentConfig = getComponentConfig(config);\r\n  const id = generateId();\r\n  const { html, css, stateClass } = componentData;\r\n  const inputFilters:FilterWithOptions = Object.assign({}, inputBuiltinFilters);\r\n  const outputFilters:FilterWithOptions = Object.assign({}, outputBuiltinFilters);\r\n  stateClass.$isStructive = true;\r\n  registerHtml(id, html);\r\n  registerCss(id, css);\r\n  registerStateClass(id, stateClass);\r\n  const baseClass = getBaseClass(componentConfig.extends);\r\n  const extendTagName = componentConfig.extends;\r\n  return class extends baseClass implements IComponent {\r\n    #engine: IComponentEngine;\r\n\r\n    constructor() {\r\n      super();\r\n      this.#engine = createComponentEngine(componentConfig, this as StructiveComponent);\r\n      this.#engine.setup();\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.#engine.connectedCallback();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.#engine.disconnectedCallback();\r\n    }\r\n\r\n    #parentStructiveComponent: StructiveComponent | null | undefined;\r\n    get parentStructiveComponent(): StructiveComponent | null {\r\n      if (typeof this.#parentStructiveComponent === \"undefined\") {\r\n        this.#parentStructiveComponent = findStructiveParent(this as StructiveComponent);\r\n      }\r\n      return this.#parentStructiveComponent;\r\n    }\r\n\r\n    get state(): IComponentStateInput {\r\n      return this.#engine.stateInput;\r\n    }\r\n\r\n    get stateBinding(): IComponentStateBinding {\r\n      return this.#engine.stateBinding;\r\n    }\r\n\r\n    get isStructive(): boolean {\r\n      return this.#engine.stateClass.$isStructive ?? false;\r\n    }\r\n\r\n    get readyResolvers(): PromiseWithResolvers<void> {\r\n      return this.#engine.readyResolvers;\r\n    }\r\n\r\n    getBindingsFromChild(component: IComponent): Set<IBinding> | null {\r\n      return this.#engine.bindingsByComponent.get(component as StructiveComponent) ?? null;\r\n    }\r\n\r\n    registerChildComponent(component:StructiveComponent): void {\r\n      this.#engine.registerChildComponent(component);\r\n    }\r\n    unregisterChildComponent(component:StructiveComponent): void {\r\n      this.#engine.unregisterChildComponent(component);\r\n    }\r\n    static define(tagName:string) {\r\n      if (extendTagName) {\r\n        customElements.define(tagName, this, { extends: extendTagName });\r\n      } else {\r\n        customElements.define(tagName, this);\r\n      }\r\n    }\r\n\r\n    static get id():number {\r\n      return id;\r\n    }\r\n    static #html:string = html;\r\n    static get html():string {\r\n      return this.#html;\r\n    }\r\n    static set html(value:string) {\r\n      this.#html = value;\r\n      registerHtml(this.id, value);\r\n      this.#template = null;\r\n      this.#pathManager = null; // パス情報をリセット\r\n    }\r\n\r\n    static #css:string = css;\r\n    static get css() {\r\n      return this.#css;\r\n    }\r\n    static set css(value:string) {\r\n      this.#css = value;\r\n      registerCss(this.id, value);\r\n      this.#styleSheet = null;\r\n    }\r\n    static #template: HTMLTemplateElement | null = null;\r\n    static get template():HTMLTemplateElement {\r\n      if (!this.#template) {\r\n        this.#template = getTemplateById(this.id);\r\n      }\r\n      return this.#template;\r\n    }\r\n    static #styleSheet: CSSStyleSheet | null = null;\r\n    static get styleSheet():CSSStyleSheet {\r\n      if (!this.#styleSheet) {\r\n        this.#styleSheet = getStyleSheetById(this.id);\r\n      }\r\n      return this.#styleSheet;\r\n    }\r\n    static #stateClass: IStructiveState | null = null;\r\n    static get stateClass():IStructiveState {\r\n      if (!this.#stateClass) {\r\n        this.#stateClass = getStateClassById(this.id) as IStructiveState;\r\n      }\r\n      return this.#stateClass;\r\n    }\r\n    static #inputFilters:FilterWithOptions = inputFilters;\r\n    static get inputFilters():FilterWithOptions {\r\n      return this.#inputFilters;\r\n    }\r\n    static #outputFilters:FilterWithOptions = outputFilters;\r\n    static get outputFilters():FilterWithOptions {\r\n      return this.#outputFilters;\r\n    }\r\n    static #pathManager: IPathManager | null = null;\r\n    static get pathManager(): IPathManager {\r\n      if (!this.#pathManager) {\r\n        this.#pathManager = createPathManager(this as StructiveComponentClass);\r\n      }\r\n      return this.#pathManager;\r\n    }\r\n\r\n  } as StructiveComponentClass;\r\n}\r\n","/**\r\n * getComponentConfig.ts\r\n *\r\n * ユーザー設定（IUserConfig）とグローバル設定を統合し、コンポーネントの設定（IComponentConfig）を生成するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - getGlobalConfigでグローバル設定を取得\r\n * - ユーザー設定が優先され、未指定の場合はグローバル設定値を利用\r\n * - shadowDomModeやextendsなどの設定値を一元的に返却\r\n *\r\n * 設計ポイント:\r\n * - ユーザーごとの個別設定と全体のデフォルト設定を柔軟に統合\r\n * - 設定値のデフォルト化や拡張性を考慮した設計\r\n */\r\nimport { getGlobalConfig } from \"./getGlobalConfig.js\";\r\nimport { IUserConfig, IComponentConfig } from \"./types\";\r\n\r\nexport function getComponentConfig(userConfig: IUserConfig): IComponentConfig {\r\n  const globalConfig = getGlobalConfig();\r\n  return {\r\n    enableWebComponents: typeof userConfig.enableWebComponents === \"undefined\" ? true : userConfig.enableWebComponents,\r\n    shadowDomMode      : userConfig.shadowDomMode ?? globalConfig.shadowDomMode,\r\n    extends            : userConfig.extends ?? null,\r\n  };\r\n}","/**\r\n * getBaseClass.ts\r\n *\r\n * 指定したタグ名（extendTagName）から、その要素のコンストラクタ（基底クラス）を取得するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - extendTagNameが指定されていれば、そのタグのHTMLElementコンストラクタを返す\r\n * - 指定がなければHTMLElementを返す\r\n *\r\n * 設計ポイント:\r\n * - カスタム要素の継承元クラスを動的に取得し、柔軟なWeb Components拡張に対応\r\n */\r\nimport { Constructor } from \"../types\";\r\n\r\nexport function getBaseClass(extendTagName: string | null):Constructor<HTMLElement> {\r\n  return extendTagName ? (document.createElement(extendTagName).constructor as Constructor<HTMLElement>) : HTMLElement;\r\n}","/**\r\n * createSingleFileComponent.ts\r\n *\r\n * Structive用のシングルファイルコンポーネント（SFC）をパースし、各要素（HTML, CSS, StateClass）を抽出・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - テキストから<template>・<script type=\"module\">・<style>を抽出し、それぞれを分離\r\n * - <script type=\"module\">はBase64エンコードして動的importし、StateClassとして利用\r\n * - {{...}}埋め込み式は一時的にコメントノード化してHTMLパース時の消失を防止し、復元\r\n * - 各要素（html, css, stateClass, text）をIUserComponentDataとして返却\r\n *\r\n * 設計ポイント:\r\n * - escapeEmbed/unescapeEmbedでMustache構文の安全なパースを実現\r\n * - scriptはdata:URL経由で安全に動的import\r\n * - テンプレート・スクリプト・スタイルを柔軟に分離・管理できる設計\r\n */\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nfunction escapeEmbed(html: string): string {\r\n  return html.replaceAll(/\\{\\{([^\\}]+)\\}\\}/g, (match, expr) => {\r\n    return `<!--{{${expr}}}-->`;\r\n  });\r\n}\r\n\r\nfunction unescapeEmbed(html:string):string {\r\n  return html.replaceAll(/<!--\\{\\{([^\\}]+)\\}\\}-->/g, (match, expr) => {\r\n    return `{{${expr}}}`;\r\n  });\r\n}\r\n\r\nlet id = 0;\r\n\r\nexport async function createSingleFileComponent(path: string, text: string): Promise<IUserComponentData> {\r\n  const template = document.createElement(\"template\");\r\n  template.innerHTML = escapeEmbed(text);\r\n\r\n  const html = template.content.querySelector(\"template\");\r\n  html?.remove();\r\n\r\n  const script = template.content.querySelector(\"script[type=module]\") as HTMLScriptElement | null;\r\n  let scriptModule: any = {};\r\n  if (script) {\r\n    const uniq_comment = `\\n// uniq id: ${id++}\\n//# sourceURL=${path}\\n`;\r\n    // blob URLを使用（ブラウザ環境）\r\n    // テスト環境（jsdom）ではURL.createObjectURLが存在しないためフォールバック\r\n    if (typeof URL.createObjectURL === 'function') {\r\n      const blob = new Blob([script.text + uniq_comment], { type: \"application/javascript\" });\r\n      const url = URL.createObjectURL(blob);\r\n      try {\r\n        scriptModule = await import(url);\r\n      } finally {\r\n        URL.revokeObjectURL(url);\r\n      }\r\n    } else {\r\n      // フォールバック: Base64エンコード方式（テスト環境用）\r\n      const b64 = btoa(String.fromCodePoint(...new TextEncoder().encode(script.text + uniq_comment)));\r\n      scriptModule = await import(\"data:application/javascript;base64,\" + b64);\r\n    }\r\n  }\r\n  script?.remove();\r\n\r\n  const style = template.content.querySelector(\"style\");\r\n  style?.remove();\r\n\r\n  const stateClass = (scriptModule.default ?? class {}) as IStructiveState;\r\n  \r\n  return {\r\n    text,\r\n    html      : unescapeEmbed(html?.innerHTML ?? \"\").trim(),\r\n    css       : style?.textContent ?? \"\",\r\n    stateClass,\r\n  }\r\n}","/**\r\n * loadSingleFileComponent.ts\r\n *\r\n * 指定パスのシングルファイルコンポーネント（SFC）をfetchし、パースしてIUserComponentDataとして返すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - fetchで指定パスのSFCファイルを取得\r\n * - テキストとして読み込み、createSingleFileComponentでパース\r\n * - パース結果（IUserComponentData）を返却\r\n *\r\n * 設計ポイント:\r\n * - import.meta.resolveを利用し、パス解決の柔軟性を確保\r\n * - 非同期処理で動的なコンポーネントロードに対応\r\n */\r\nimport { createSingleFileComponent } from \"./createSingleFileComponent.js\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nexport async function loadSingleFileComponent(path: string): Promise<IUserComponentData> {\r\n  // Node/Vitest 等の SSR 環境では import.meta.resolve が存在しない場合があるためフォールバック\r\n  const resolved = (import.meta as any).resolve ? (import.meta as any).resolve(path) : path;\r\n  const response = await fetch(resolved);\r\n  const text = await response.text();\r\n  return createSingleFileComponent(path, text);\r\n}\r\n","/**\r\n * registerComponentClass.ts\r\n *\r\n * StructiveのWeb Componentsクラスを指定したタグ名でカスタム要素として登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - registerComponentClass: 渡されたcomponentClassをtagNameでdefineメソッドを使って登録\r\n *\r\n * 設計ポイント:\r\n * - Web Componentsのカスタム要素登録を簡潔にラップし、再利用性を高める設計\r\n */\r\nimport { StructiveComponentClass } from \"./types\";\r\n\r\nexport function registerComponentClass(tagName: string, componentClass: StructiveComponentClass) {\r\n  componentClass.define(tagName);\r\n}","/**\r\n * loadImportmap.ts\r\n *\r\n * HTML内の<script type=\"importmap\">タグからimportmap情報を取得・統合するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 複数のimportmapスクリプトタグを走査し、全てのimportsをマージしてIImportMap型で返却\r\n *\r\n * 設計ポイント:\r\n * - scriptタグのinnerHTMLをJSON.parseでパースし、importsプロパティを統合\r\n * - importmap.importsが複数存在する場合もObject.assignでマージ\r\n * - importmap仕様に準拠し、柔軟なimportエイリアス管理を実現\r\n */\r\nimport { IImportMap } from \"./types\";\r\n\r\nexport function loadImportmap():IImportMap {\r\n  const importmap: IImportMap = {};\r\n  document.querySelectorAll(\"script[type='importmap']\").forEach(script => {\r\n    const scriptImportmap = JSON.parse(script.innerHTML);\r\n    if (scriptImportmap.imports) {\r\n      importmap.imports = Object.assign(importmap.imports || {}, scriptImportmap.imports);\r\n    }\r\n  });\r\n  return importmap;\r\n}\r\n\r\n","/**\r\n * MainWrapper.ts\r\n *\r\n * アプリ全体のレイアウトやルーティングを管理するカスタムエレメント MainWrapper の実装です。\r\n *\r\n * 主な役割:\r\n * - Shadow DOMの有効化やレイアウトテンプレートの動的読み込み\r\n * - レイアウトテンプレートやスタイルの適用\r\n * - ルーター要素（routerTagName）の動的追加\r\n *\r\n * 設計ポイント:\r\n * - config.shadowDomMode で Shadow DOMの有効/無効を切り替え\r\n * - config.layoutPath が指定されていればfetchでレイアウトHTMLを取得し、テンプレート・スタイルを適用\r\n * - スタイルはadoptedStyleSheetsでShadowRootまたはdocumentに適用\r\n * - レイアウトが指定されていない場合はデフォルトのslotを挿入\r\n * - config.enableRouter が有効な場合はrouter要素をslotに追加\r\n */\r\nimport { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\n\r\nconst SLOT_KEY = \"router\";\r\nconst DEFAULT_LAYOUT = `<slot name=\"${SLOT_KEY}\"></slot>`;\r\n\r\nexport class MainWrapper extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    if (config.shadowDomMode !== \"none\") {\r\n      this.attachShadow({ mode: 'open' });\r\n    }\r\n  }\r\n\r\n  async connectedCallback() {\r\n    await this.loadLayout();\r\n    this.render();\r\n  }\r\n\r\n  get root(): ShadowRoot | HTMLElement {\r\n    return this.shadowRoot ?? this;\r\n  }\r\n\r\n  async loadLayout() {\r\n    if (config.layoutPath) {\r\n      const response = await fetch(config.layoutPath);\r\n      if (response.ok) {\r\n        const layoutText = await response.text();\r\n        const workTemplate = document.createElement(\"template\");\r\n        workTemplate.innerHTML = layoutText;\r\n      \r\n        const template = workTemplate.content.querySelector(\"template\");\r\n        const style = workTemplate.content.querySelector(\"style\") as CSSStyleSheet | null;\r\n      \r\n        this.root.appendChild(template?.content ?? document.createDocumentFragment());\r\n        if (style) {\r\n          const shadowRootOrDocument = this.shadowRoot ?? document;\r\n          const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n          if (!styleSheets.includes(style)) {\r\n            shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, style];\r\n          }\r\n        }\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-101',\r\n          message: `Failed to load layout from ${config.layoutPath}`,\r\n          context: { layoutPath: config.layoutPath },\r\n          docsUrl: '/docs/error-codes.md#tmp',\r\n          severity: 'error',\r\n        });\r\n      }\r\n    } else {\r\n      this.root.innerHTML = DEFAULT_LAYOUT;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // add router\r\n    if (config.enableRouter) {\r\n      const router = document.createElement(config.routerTagName);\r\n      router.setAttribute('slot', SLOT_KEY);\r\n      this.root.appendChild(router);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * exports.ts\r\n *\r\n * Structiveの主要なエントリーポイント・APIを外部公開するモジュールです。\r\n *\r\n * 主な役割:\r\n * - registerSingleFileComponents, bootstrap, config などの主要APIをエクスポート\r\n * - defineComponents: SFC群をまとめて登録し、autoInitが有効なら自動で初期化\r\n * - bootstrapStructive: 初期化処理を一度だけ実行\r\n *\r\n * 設計ポイント:\r\n * - グローバル設定(config)を外部から参照・変更可能\r\n * - 初期化処理の多重実行を防止し、安全な起動を保証\r\n */\r\nimport { registerSingleFileComponents } from \"./WebComponents/registerSingleFIleComponents.js\";\r\nimport { bootstrap } from \"./bootstrap.js\";\r\nimport { config as _config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { IConfig, ShadowDomMode } from \"./WebComponents/types\";\r\n\r\nexport const config: IConfig = _config;\r\nexport type { ShadowDomMode };\r\n\r\nlet initialized = false;\r\nexport async function defineComponents(singleFileComponents: Record<string, string>):Promise<void> {\r\n  await registerSingleFileComponents(singleFileComponents);\r\n  if (config.autoInit) {\r\n    await bootstrapStructive();\r\n  }\r\n}\r\n\r\nexport async function bootstrapStructive():Promise<void> {\r\n  if (!initialized) {\r\n    await bootstrap();\r\n    initialized = true;\r\n  }\r\n}\r\n\r\n","/**\r\n * registerSingleFileComponents.ts\r\n *\r\n * 複数のシングルファイルコンポーネント（SFC）をまとめてStructiveのWeb Componentsとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - singleFileComponents（tagNameとパスのマップ）を走査し、各SFCを非同期で取得・パース\r\n * - enableRouterが有効な場合はentryRouteでルーティング情報も登録\r\n * - createComponentClassでWeb Componentsクラスを生成し、registerComponentClassでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - SFCのロードからWeb Components登録、ルーティング登録までを一括で自動化\r\n * - 非同期処理で複数コンポーネントの動的登録に対応\r\n * - ルートパス\"/root\"の正規化や、@routesプレフィックスの除去など柔軟なパス処理\r\n */\r\nimport { entryRoute } from \"../Router/Router.js\";\r\nimport { createComponentClass } from \"./createComponentClass.js\";\r\nimport { config } from \"./getGlobalConfig.js\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent.js\";\r\nimport { registerComponentClass } from \"./registerComponentClass.js\";\r\nimport { IUserComponentData, SingleFileComponents } from \"./types\";\r\n\r\nexport async function registerSingleFileComponents(singleFileComponents:SingleFileComponents):Promise<void> {\r\n  for(const [ tagName, path ] of Object.entries(singleFileComponents)) {\r\n    let componentData : IUserComponentData | null = null;\r\n    if (config.enableRouter) {\r\n      const routePath = path.startsWith(\"@routes\") ? path.slice(7) : path; // remove the prefix 'routes:'\r\n      entryRoute(tagName, routePath === \"/root\" ? \"/\" : routePath); // routing\r\n    }\r\n    componentData = await loadSingleFileComponent(path);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  }\r\n}","/**\r\n * bootstrap.ts\r\n *\r\n * Structiveアプリケーションの初期化処理を行うエントリーポイントです。\r\n *\r\n * 主な役割:\r\n * - グローバル設定(config)に従い、必要なコンポーネントやルーター、メインラッパーを登録・初期化\r\n * - autoLoadFromImportMapが有効な場合はimportmapからルートやコンポーネントを動的ロード\r\n * - enableRouterが有効な場合はRouterコンポーネントをカスタム要素として登録\r\n * - enableMainWrapperが有効な場合はMainWrapperをカスタム要素として登録し、autoInsertMainWrapperが有効ならbodyに自動挿入\r\n *\r\n * 設計ポイント:\r\n * - 設定値に応じて初期化処理を柔軟に制御\r\n * - importmapやカスタム要素の登録、DOMへの自動挿入など、Structiveの起動に必要な処理を一元化\r\n */\r\nimport { MainWrapper } from \"./MainWrapper/MainWrapper.js\";\r\nimport { Router } from \"./Router/Router.js\";\r\nimport { config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { loadFromImportMap } from \"./WebComponents/loadFromImportMap.js\";\r\n\r\nexport async function bootstrap(): Promise<void> {\r\n  if (config.autoLoadFromImportMap) {\r\n    await loadFromImportMap();\r\n  }\r\n\r\n  if (config.enableRouter) {\r\n    customElements.define(config.routerTagName, Router);\r\n  }\r\n\r\n  if (config.enableMainWrapper) {\r\n    customElements.define(config.mainTagName, MainWrapper);\r\n    if (config.autoInsertMainWrapper) {\r\n      const mainWrapper = document.createElement(config.mainTagName);\r\n      document.body.appendChild(mainWrapper);\r\n    }\r\n  }\r\n}"],"names":["globalConfig","debug","locale","shadowDomMode","enableMainWrapper","enableRouter","autoInsertMainWrapper","autoInit","mainTagName","routerTagName","layoutPath","autoLoadFromImportMap","getGlobalConfig","config","raiseError","messageOrPayload","Error","message","code","context","hint","t","docsUrl","o","severity","i","cause","err","optionsRequired","fnName","optionMustBeNumber","valueMustBeNumber","valueMustBeDate","builtinFilters","eq","options","opt","value","optValue","Number","isNaN","ne","not","lt","le","gt","ge","inc","dec","mul","div","mod","fix","toFixed","toLocaleString","uc","toString","toUpperCase","lc","toLowerCase","cap","v","length","charAt","slice","trim","substr","opt1","opt1Value","opt2","opt2Value","pad","padStart","rep","repeat","rev","split","reverse","join","int","parseInt","float","parseFloat","round","Math","pow","floor","ceil","percent","date","Date","toLocaleDateString","time","toLocaleTimeString","datetime","ymd","year","getFullYear","month","getMonth","day","getDate","falsy","truthy","defaults","boolean","Boolean","number","string","String","null","outputBuiltinFilters","inputBuiltinFilters","id","generateId","stateClassById","styleSheetById","registerCss","css","styleSheet","CSSStyleSheet","replaceSync","registerStyleSheet","resolveNodeFromPath","root","path","node","childNodes","textToFilter","filters","text","filter","name","where","cache","Map","createFilters","texts","result","get","push","set","BindingNode","_binding","_node","_name","_subName","_filters","_decorates","this","subName","binding","decorates","bindContents","constructor","assignValue","updateElements","listIndexes","values","notifyRedraw","refs","applyChange","renderer","filteredValue","bindingState","getFilteredValue","readonlyState","readonlyHandler","activate","inactivate","isSelectElement","HTMLSelectElement","BindingNodeAttribute","setAttribute","DATA_BIND_ATTRIBUTE","COMMENT_EMBED_MARK","COMMENT_TEMPLATE_MARK","RESERVED_WORD_SET","Set","CONNECTED_CALLBACK_FUNC_NAME","DISCONNECTED_CALLBACK_FUNC_NAME","UPDATED_CALLBACK_FUNC_NAME","_cache","StructuredPathInfo","static","sid","pattern","pathSegments","lastSegment","cumulativePaths","cumulativePathSet","cumulativeInfos","cumulativeInfoSet","wildcardPaths","wildcardPathSet","wildcardInfos","indexByWildcardPath","wildcardInfoSet","wildcardParentPaths","wildcardParentPathSet","wildcardParentInfos","wildcardParentInfoSet","lastWildcardPath","lastWildcardInfo","parentPath","parentInfo","wildcardCount","children","getPattern","_pattern","getStructuredPathInfo","currentPatternPath","prevPatternPath","structuredPath","has","info","NodePath","currentPath","childNodeByName","level","find","segments","segIndex","currentSegment","childNode","appendChild","childName","findPathNodeByPath","rootNode","nodeCache","cachedNode","addPathNode","parentNode","symbolName","GetByRefSymbol","Symbol","for","SetByRefSymbol","ConnectedCallbackSymbol","DisconnectedCallbackSymbol","UpdatedCallbackSymbol","GetListIndexesByRefSymbol","ResolvedPathInfo","elements","paths","wildcardType","wildcardIndexes","tmpPatternElements","incompleteCount","completeCount","lastPath","element","getResolvedPathInfo","nameInfo","StatePropertyRef","listIndexRef","listIndex","deref","key","WeakRef","parentRef","getStatePropertyRef","at","refByInfoByListIndex","WeakMap","refByInfoByNull","ref","refByInfo","getContextListIndex","handler","lastRefStack","index","getListIndex","resolvedPath","receiver","parentListIndex","wildcardParentPattern","wildcardRef","wildcardParent","wildcardIndex","indexByIndexName","version","ListIndex","pos","position","indexes","dirty","varName","createListIndex","getByRef","target","refIndex","lastInfo","engine","pathManager","onlyGetters","addDynamicDependency","checkDependency","listable","lists","cacheable","getters","lastCacheEntry","getCacheEntry","versionRevision","versionRevisionByPath","updater","revision","stateOutput","startsWith","intersection","size","refStack","Reflect","newListIndexes","lastListInfoByRef","listInfo","oldList","newList","oldIndexes","Array","isArray","newIndexes","newListIndex","isSameList","indexByValue","newValue","oldIndex","existingListIndex","createListIndexes","cacheEntry","setCacheEntry","setByRef","isElements","swapInfo","refPath","swapInfoByRef","setters","parentValue","enqueueRef","indexOf","currentListIndexes","curIndex","delete","resolve","prop","expected","received","hasSetValue","resolveFn","wildcardPattern","infoPattern","walkWildcardPattern","wildardIndexPos","indexPos","parentIndexes","results","concat","resultIndexes","resultValues","getAll","trackDependency","to","globalRouter","navigate","owner","resolvedInfo","symbols","getListIndexes","getListIndexesByRef","callback","call","connectedCallback","disconnectedCallback","indexesByPath","add","from","updatedCallback","StateHandler$1","fill","loopContext","apis","trapGet","createReadonlyStateHandler","StateHandler","createReadonlyStateProxy","state","Proxy","trapSet","useWritableStateProxy","stateProxy","resultPromise","Promise","finally","setLoopContext","Renderer","updatingRefs","updatingRefSet","updatedBindings","processedRefs","reorderIndexesByRef","createReadonlyState","render","items","clear","remainItems","itemsByListRef","refSet","listRef","refKey","bindings","getBindings","renderItem","structiveChildComponents","structiveComponent","structiveComponentBindings","bindingsByComponent","diffListIndexes","Ut","lastListIndexSet","difference","childInfo","childRef","deps","dynamicDependencies","depPath","depInfo","depNode","infos","walk","depRef","nextInfo","nextRef","subDepRef","startRef","Updater","queue","rendering","saveQueue","versionUp","collectMaybeUpdates","queueMicrotask","update","updatedCallbackHandler","hasUpdatedCallback","initialRender","recursiveCollectMaybeUpdates","visitedInfo","isSource","entries","childPath","cacheUpdatedPathsByPath","updatedPaths","updatedPath","createUpdater","BindingNodeCheckbox","super","HTMLInputElement","type","decoratesCount","eventName","addEventListener","async","e","parentBindContent","currentLoopContext","updateStateValue","receivedType","checked","includes","BindingNodeClassList","className","BindingNodeClassName","classList","toggle","BindingNodeEvent","serialize","map","preventDefault","stopPropagation","func","getValue","apply","createBindingNodeEvent","filterTexts","filterFns","BindingNodeBlock","commentText","textContent","numId","isFinite","isInteger","BindingNodeIf","_bindContent","_trueBindContents","_falseBindContents","_bindContents","blankRef","createBindContent","valueType","nodeType","mountAfter","unmount","EMPTY_SET","USE_ALL_APPEND","globalThis","__STRUCTIVE_USE_ALL_APPEND__","BindingNodeFor","_bindContentByListIndex","_bindContentPool","_bindContentLastIndex","_loopInfo","undefined","_oldList","_oldListIndexes","_oldListIndexSet","bindContentLastIndex","poolLength","loopInfo","loopPath","bindContent","assignListIndex","loopRef","deleteBindContent","newBindContents","newListIndexesSet","oldListLength","removesSet","addsSet","newListLength","changeIndexesSet","overwritesSet","elementsPath","updatingRef","removeBindContentsSet","isAllRemove","isParentNodeHasOnlyThisNode","parentChildNodes","lastContent","firstNode","Node","TEXT_NODE","nextSibling","lastNode","previousSibling","getLastNode","append","when","lastBindContent","isAllAppend","changeIndexes","sort","a","b","oldIndexByListIndex","fragmentParentNode","document","createDocumentFragment","fragmentFirstNode","changeListIndexes","firstChildNode","beforeNode","insertBefore","bindingsByListIndex","createBindingNodeFor","defaultEventByName","valueAsNumber","valueAsDate","selected","twoWayPropertyByElementType","radio","checkbox","VALUES_SET","BLANK_SET","BindingNodeProperty","HTMLElement","HTMLTextAreaElement","defaultNames","HTMLOptionElement","getTwoWayPropertiesHTMLElement","createBindingNodeProperty","BindingNodeRadio","BindingNodeStyle","style","setProperty","AssignStateSymbol","NotifyRedrawSymbol","parentStructiveComponentByStructiveComponent","getCustomTagName","component","tagName","getAttribute","BindingNodeComponent","_notifyRedraw","customElements","whenDefined","then","notifyRefs","compRef","atIndex","parentComponent","registerChildComponent","stateBinding","addBinding","registerStructiveComponent","nodePropertyConstructorByNameByIsComment","class","if","nodePropertyConstructorByFirstName","attr","getBindingNodeCreator","propertyName","isComment","Comment","isElement","Element","fn","bindingNodeCreatorByName","nameElements","bindingNodeCreatorByFirstName","_getBindingNodeCreator","BindingState","isLoopIndex","_nullRef","_ref","_loopContext","writeState","saveBinding","removeBinding","BindingStateIndex","_indexNumber","indexNumber","loopContexts","bindingForList","parentBinding","ereg","RegExp","getBindingStateCreator","test","createBindingStateIndex","createBindingState","nodeTypeByNodeKey","getNodeType","nodeKey","createNodeKey","SVGElement","nodeName","nodeConstructor","getNodeTypeByNode","s","re","decode","m","exec","decodeURIComponent","parseFilter","parseProperty","property","parseExpressions","expression","bindExpression","decoratesExpression","nodePropertyText","statePropertyText","nodeProperty","inputFilterTexts","stateProperty","outputFilterTexts","parseExpression","removeAttributeFromElement","removeAttribute","removeAttributeByNodeType","Text","Template","replaceTextNodeFn","textNode","createTextNode","replaceChild","DataBindAttributes","nodePath","bindTexts","creatorByText","idText","getTemplateById","getDataBindText","removeDataBindAttribute","replaceTextNodeFromComment","routeIndexes","getAbsoluteNodePath","parseBindText","bindText","creator","createBindingNode","getNodesHavingDataBind","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","acceptNode","hasAttribute","FILTER_ACCEPT","FILTER_SKIP","isCommentNode","nextNode","currentNode","listDataBindAttributesById","listPathsSetById","pathsSetById","getDataBindAttributesFromTemplate","content","createDataBindAttributes","templateById","registerTemplate","template","rootId","forEach","nodeValue","removeChild","dataBindAttributes","listPaths","attribute","j","registerDataBindAttributes","templateId","Binding","bindingNode","_isActive","inputFilters","outputFilters","isActive","createBinding","LoopContext","clearListIndex","parentLoopContext","currentBindContent","unshift","createContent","fragment","importNode","Object","keys","lazyLoadComponentAliasByTagName","lazyLoadElements","querySelectorAll","loadLazyLoadComponent","createBindings","attributes","getDataBindAttributesById","BindContent","lastChildNode","_engine","_currentLoopContext","lastBinding","mount","mountBefore","afterNode","attachStyleInLightMode","shadowRootOrDocument","ShadowRoot","getParentShadowRoot","styleSheets","adoptedStyleSheets","createShadowRootWithStyle","shadowRoot","attachShadow","mode","extends","createElement","canHaveShadowRoot","ComponentStateBinding","childPaths","parentPaths","bindingByParentPath","bindingByChildPath","_childPathByParentPath","_parentPathByChildPath","_bindings","WeakSet","existingChildPath","existingParentPath","getChildPath","getParentPath","toParentPathFromChildPath","matchPaths","matchPathArray","longestMatchPath","remainPath","matchParentPath","toChildPathFromParentPath","matchChildPath","startsWithByChildPath","childPathInfo","matches","bind","childComponent","getBindingsFromChild","ComponentStateInputHandler","_componentStateBinding","componentStateBinding","assignState","object","parentPathRef","childListIndex","parentPattern","childPattern","getPropertyValue","setPropertyValue","ComponentStateOutput","_childEngine","_parentPaths","childEngine","isList","addPath","pathInfo","ComponentEngine","stateClass","baseClass","readyResolvers","withResolvers","stateInput","_blockPlaceholder","_blockParentNode","_ignoreDissconnectedCallback","_currentVersion","_propertyRefMetadataByRef","componentClass","createComponentStateInput","componentId","currentVersion","setup","alls","rootRef","enableWebComponents","createComment","replaceWith","dataset","json","JSON","parse","datasetState","hasConnectedCallback","hasDisconnectedCallback","parentStructiveComponent","unregisterChildComponent","remove","entry","metadata","splice","MUSTACHE_REGEXP","MUSTACHE_TYPES","SVG_NS","replaceTemplateTagWithComment","bindTextForDebug","namespaceURI","newTemplate","registerHtml","html","innerHTML","stack","replaceAll","match","expr","remain","currentInfo","endTags","pop","stackDepth","got","replaceMustacheWithTemplateTag","checkSegmentRegexp","checkPathRegexp","createAccessorFunctions","len","matchPath","curPath","matchInfo","count","segment","setterFuncText","Function","PathManager","funcs","getterSetters","optimizes","staticDependencies","createRootNode","getPathsSetById","listsFromAlls","union","cumulativePath","cumulativeInfo","getListPathsSetById","listPath","elementPath","currentProto","prototype","getOwnPropertyDescriptors","desc","hasGetter","hasSetter","getPrototypeOf","defineProperty","enumerable","configurable","dynamicDependencyKeys","source","createComponentClass","componentData","componentConfig","userConfig","qn","getComponentConfig","$config","Xs","Ys","Ns","assign","$isStructive","registerStateClass","extendTagName","getBaseClass","createComponentEngine","el","isStructive","define","styleSheetId","getStyleSheetById","stateClassId","getStateClassById","unescapeEmbed","loadSingleFileComponent","resolved","response","fetch","escapeEmbed","querySelector","script","scriptModule","uniq_comment","URL","createObjectURL","blob","Blob","url","import","revokeObjectURL","b64","btoa","fromCodePoint","TextEncoder","encode","default","createSingleFileComponent","registerComponentClass","ROUTES_KEY","COMPONENTS_KEY","LAZY_LOAD_SUFFIX","loadFromImportMap","importmap","scriptImportmap","imports","loadImportmap","loadAliasByTagName","alias","isLazyLoad","endsWith","replace","entryRoute","console","warn","ROUTE_PATH_PREFIX","routeEntries","Router","originalPathName","window","location","pathname","originalFileName","basePath","href","origin","_popstateHandler","popstateHandler","dispatchEvent","Event","removeEventListener","event","toPath","history","pushState","n","replacedPath","params","tag","regex","substring","customElement","stringify","hasOwnProperty","isLazyLoadComponent","messageElement","routePath","SLOT_KEY","DEFAULT_LAYOUT","MainWrapper","loadLayout","ok","layoutText","workTemplate","router","_config","initialized","defineComponents","singleFileComponents","registerSingleFileComponents","bootstrapStructive","mainWrapper","body","bootstrap"],"mappings":"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"}