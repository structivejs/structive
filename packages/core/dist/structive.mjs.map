{"version":3,"file":"structive.mjs","sources":["../src/WebComponents/getGlobalConfig.ts","../src/utils.ts","../src/Filter/errorMessages.ts","../src/Filter/builtinFilters.ts","../src/GlobalId/generateId.ts","../src/StateClass/registerStateClass.ts","../src/StyleSheet/registerStyleSheet.ts","../src/StyleSheet/regsiterCss.ts","../src/BindingBuilder/resolveNodeFromPath.ts","../src/BindingBuilder/getAbsoluteNodePath.ts","../src/BindingBuilder/createFilters.ts","../src/DataBinding/BindingFilter.ts","../src/DataBinding/BindingNode/BindingNode.ts","../src/DataBinding/BindingNode/BindingNodeAttribute.ts","../src/constants.ts","../src/StateProperty/getStructuredPathInfo.ts","../src/PathTree/PathNode.ts","../src/StateClass/symbols.ts","../src/StateProperty/getResolvedPathInfo.ts","../src/StatePropertyRef/StatepropertyRef.ts","../src/StateClass/methods/getContextListIndex.ts","../src/StateClass/methods/getListIndex.ts","../src/StateClass/apis/trackDependency.ts","../src/StateClass/traps/indexByIndexName.ts","../src/ListIndex/ListIndex.ts","../src/StateClass/methods/checkDependency.ts","../src/StateClass/methods/createListIndexes.ts","../src/StateClass/methods/getByRef.ts","../src/StateClass/methods/setByRef.ts","../src/StateClass/apis/resolve.ts","../src/StateClass/apis/connectedCallback.ts","../src/StateClass/apis/disconnectedCallback.ts","../src/StateClass/apis/getAll.ts","../src/StateClass/methods/getListIndexesByRef.ts","../src/StateClass/apis/updatedCallback.ts","../src/StateClass/apis/invoke.ts","../src/StateClass/traps/get.ts","../src/StateClass/createReadonlyStateProxy.ts","../src/StateClass/traps/set.ts","../src/StateClass/methods/setLoopContext.ts","../src/StateClass/useWritableStateProxy.ts","../src/Updater/Renderer.ts","../src/Updater/RenderMain.ts","../src/Updater/UpdateActivityTracker.ts","../src/Updater/Updater.ts","../src/DataBinding/BindingNode/BindingNodeCheckbox.ts","../src/DataBinding/BindingNode/BindingNodeClassList.ts","../src/DataBinding/BindingNode/BindingNodeClassName.ts","../src/DataBinding/BindingNode/BindingNodeEvent.ts","../src/DataBinding/BindingNode/BindingNodeBlock.ts","../src/DataBinding/BindingNode/BindingNodeIf.ts","../src/DataBinding/BindingNode/BindingNodeFor.ts","../src/DataBinding/BindingNode/BindingNodeProperty.ts","../src/DataBinding/BindingNode/BindingNodeRadio.ts","../src/DataBinding/BindingNode/BindingNodeStyle.ts","../src/ComponentStateInput/symbols.ts","../src/WebComponents/findStructiveParent.ts","../src/WebComponents/getCustomTagName.ts","../src/DataBinding/BindingNode/BindingNodeComponent.ts","../src/BindingBuilder/getBindingNodeCreator.ts","../src/DataBinding/BindingState/BindingState.ts","../src/DataBinding/BindingState/BindingStateIndex.ts","../src/BindingBuilder/getBindingStateCreator.ts","../src/BindingBuilder/getDataBindText.ts","../src/BindingBuilder/getNodeType.ts","../src/BindingBuilder/parseBindText.ts","../src/BindingBuilder/removeDataBindAttribute.ts","../src/BindingBuilder/replaceTextNodeFromComment.ts","../src/BindingBuilder/createDataBindAttributes.ts","../src/BindingBuilder/getNodesHavingDataBind.ts","../src/BindingBuilder/registerDataBindAttributes.ts","../src/Template/removeEmptyTextNodes.ts","../src/Template/registerTemplate.ts","../src/DataBinding/Binding.ts","../src/LoopContext/createLoopContext.ts","../src/DataBinding/BindContent.ts","../src/ComponentEngine/canHaveShadowRoot.ts","../src/ComponentEngine/attachShadow.ts","../src/ComponentStateBinding/createComponentStateBinding.ts","../src/ComponentStateInput/createComponentStateInput.ts","../src/ComponentStateOutput/createComponentStateOutput.ts","../src/Updater/CompleteQueue.ts","../src/ComponentEngine/ComponentEngine.ts","../src/Template/replaceMustacheWithTemplateTag.ts","../src/Template/replaceTemplateTagWithComment.ts","../src/Template/registerHtml.ts","../src/WebComponents/getBaseClass.ts","../src/WebComponents/getComponentConfig.ts","../src/StateProperty/createAccessorFunctions.ts","../src/PathManager/PathManager.ts","../src/WebComponents/createComponentClass.ts","../src/WebComponents/loadImportmap.ts","../src/WebComponents/createSingleFileComponent.ts","../src/WebComponents/loadSingleFileComponent.ts","../src/WebComponents/registerComponentClass.ts","../src/WebComponents/loadFromImportMap.ts","../src/Router/Router.ts","../src/WebComponents/registerSingleFIleComponents.ts","../src/MainWrapper/MainWrapper.ts","../src/bootstrap.ts","../src/exports.ts"],"sourcesContent":["/**\r\n * getGlobalConfig.ts\r\n *\r\n * Utility for defining and retrieving global configuration (IConfig) used throughout Structive.\r\n *\r\n * Main responsibilities:\r\n * - globalConfig: Defines default global configuration values (debug, locale, shadowDomMode, etc.)\r\n * - getGlobalConfig: Function that returns the global configuration object\r\n * - config: Exported as an alias of getGlobalConfig() for immediate access\r\n *\r\n * Design points:\r\n * - Centrally manages configuration values commonly used across all components\r\n * - Explicitly defines default values, making it easy to extend and customize\r\n */\r\nimport { IConfig } from \"./types\";\r\n\r\n/**\r\n * Global configuration object with default values for all Structive components.\r\n * This object can be modified directly to change application-wide behavior.\r\n */\r\nconst globalConfig: IConfig = {\r\n  /** Enable debug mode for verbose logging */\r\n  \"debug\"                : false,\r\n  /** Types of debug reports to enable */\r\n  \"debugReports\"         : [],\r\n  /** Locale for internationalization (e.g., \"en-US\", \"ja-JP\") */\r\n  \"locale\"               : \"en-US\",\r\n  /** Shadow DOM mode: \"auto\" (default) uses Shadow DOM when supported, \"none\" disables it, \"force\" requires it */\r\n  \"shadowDomMode\"        : \"auto\",\r\n  /** Enable the main wrapper component */\r\n  \"enableMainWrapper\"    : true,\r\n  /** Enable the router component */\r\n  \"enableRouter\"         : true,\r\n  /** Automatically insert the main wrapper into the document */\r\n  \"autoInsertMainWrapper\": false,\r\n  /** Automatically initialize components on page load */\r\n  \"autoInit\"             : true,\r\n  /** Custom tag name for the main wrapper element */\r\n  \"mainTagName\"          : \"app-main\",\r\n  /** Custom tag name for the router element */\r\n  \"routerTagName\"        : \"view-router\",\r\n  /** Path to the layout template file */\r\n  \"layoutPath\"           : \"\",\r\n  /** Automatically load components referenced in import maps */\r\n  \"autoLoadFromImportMap\": false,\r\n};\r\n\r\n/**\r\n * Retrieves the global configuration object.\r\n * Returns a reference to the live configuration object, so modifications\r\n * will affect all components.\r\n * \r\n * @returns {IConfig} The global configuration object\r\n * \r\n * @example\r\n * const config = getGlobalConfig();\r\n * config.debug = true; // Enable debug mode\r\n * config.shadowDomMode = 'none'; // Disable Shadow DOM\r\n */\r\nexport function getGlobalConfig():IConfig {\r\n  return globalConfig;\r\n}\r\n\r\n/**\r\n * Pre-initialized global configuration for convenient access.\r\n * This is a direct reference to the result of getGlobalConfig().\r\n * \r\n * @example\r\n * import { config } from './getGlobalConfig';\r\n * console.log(config.locale); // 'en-US'\r\n */\r\nexport const config = getGlobalConfig();\r\n","/**\r\n * Error generation utility\r\n *\r\n * Purpose:\r\n * - Throws exceptions with structured metadata (code, context, hint, documentation URL, severity, cause)\r\n * - Follows existing Error conventions while adding additional properties to improve debuggability\r\n *\r\n * Example:\r\n * raiseError({\r\n *   code: 'UPD-001',\r\n *   message: 'Engine not initialized',\r\n *   context: { where: 'Renderer.render' },\r\n *   docsUrl: './docs/error-codes.md#upd'\r\n * });\r\n */\r\nimport { config } from \"./WebComponents/getGlobalConfig\";\r\n\r\n/**\r\n * Payload object for structured error information.\r\n * Extends standard Error with additional debugging metadata.\r\n */\r\nexport type StructiveErrorPayload = {\r\n  /** Error code for categorization (e.g., 'UPD-001', 'CE-202') */\r\n  code: string;\r\n  /** Human-readable error message */\r\n  message: string;\r\n  /** Additional context data for debugging (e.g., variable values, location) */\r\n  context?: Record<string, unknown>;\r\n  /** Suggestion for resolving the error */\r\n  hint?: string;\r\n  /** URL to documentation explaining this error code */\r\n  docsUrl?: string;\r\n  /** Severity level: 'error' for failures, 'warn' for non-critical issues */\r\n  severity?: \"error\" | \"warn\";\r\n  /** Original error that caused this error (for error chaining) */\r\n  cause?: unknown;\r\n};\r\n\r\n/**\r\n * Throws an error with a simple message.\r\n * \r\n * @param {string} message - Error message\r\n * @returns {never} This function never returns (always throws)\r\n */\r\nexport function raiseError(message: string): never;\r\n\r\n/**\r\n * Throws an error with structured metadata for enhanced debugging.\r\n * \r\n * @param {StructiveErrorPayload} payload - Structured error information\r\n * @returns {never} This function never returns (always throws)\r\n */\r\nexport function raiseError(payload: StructiveErrorPayload): never;\r\n\r\n/**\r\n * Raises an error with optional structured metadata.\r\n * \r\n * This function provides two calling patterns:\r\n * 1. Simple string message for basic errors\r\n * 2. Structured payload with metadata for enhanced debugging\r\n * \r\n * The structured payload attaches additional properties to the Error object,\r\n * making it easier to debug issues in production by providing context, hints,\r\n * and links to documentation.\r\n * \r\n * @param {string | StructiveErrorPayload} messageOrPayload - Error message or structured payload\r\n * @returns {never} This function never returns (always throws)\r\n * \r\n * @example\r\n * // Simple error\r\n * raiseError('Something went wrong');\r\n * \r\n * @example\r\n * // Structured error with metadata\r\n * raiseError({\r\n *   code: 'STATE-101',\r\n *   message: 'Invalid state property',\r\n *   context: { property: 'user.name', value: undefined },\r\n *   hint: 'Ensure the property is initialized before access',\r\n *   docsUrl: './docs/error-codes.md#state-101',\r\n *   severity: 'error'\r\n * });\r\n */\r\nexport function raiseError(messageOrPayload: string | StructiveErrorPayload): never {\r\n  // Handle simple string message\r\n  if (typeof messageOrPayload === \"string\") {\r\n    throw new Error(messageOrPayload);\r\n  }\r\n  \r\n  // Handle structured payload\r\n  const { message, code, context, hint, docsUrl, severity, cause } = messageOrPayload;\r\n\r\n  if (config.debug) {\r\n    // eslint-disable-next-line no-console\r\n    console.group(`[Structive Error] ${code}: ${message}`);\r\n    // eslint-disable-next-line no-console\r\n    if (context) {console.log('Context:', context);}\r\n    // eslint-disable-next-line no-console\r\n    if (hint) {console.log('Hint:', hint);}\r\n    // eslint-disable-next-line no-console\r\n    if (docsUrl) {console.log('Docs:', docsUrl);}\r\n    if (cause) {console.error('Cause:', cause);}\r\n    // eslint-disable-next-line no-console\r\n    console.groupEnd();\r\n  }\r\n  \r\n  // Create base Error with the message\r\n  const err: unknown = new Error(message);\r\n  \r\n  // Attach additional metadata as properties (keeping message for existing compatibility)\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  (err as any).code = code;\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  if (context) {(err as any).context = context;}\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  if (hint) {(err as any).hint = hint;}\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  if (docsUrl) {(err as any).docsUrl = docsUrl;}\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  if (severity) {(err as any).severity = severity;}\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  if (cause) {(err as any).cause = cause;}\r\n  \r\n  throw err;\r\n}\r\n","/**\r\n * errorMessages.ts\r\n *\r\n * Error message generation utilities used by filter functions.\r\n *\r\n * Main responsibilities:\r\n * - Throws clear error messages when filter options or value type checks fail\r\n * - Takes function name as argument to specify which filter caused the error\r\n *\r\n * Design points:\r\n * - optionsRequired: Error when required option is not specified\r\n * - optionMustBeNumber: Error when option value is not a number\r\n * - valueMustBeNumber: Error when value is not a number\r\n * - valueMustBeBoolean: Error when value is not boolean\r\n * - valueMustBeDate: Error when value is not a Date\r\n */\r\nimport { raiseError } from \"../utils\";\r\n\r\nconst createContext = (where: string, fnName: string) => ({ where, fnName });\r\n\r\n/**\r\n * Throws error when filter requires at least one option but none provided.\r\n * \r\n * @param fnName - Name of the filter function\r\n * @returns Never returns (always throws)\r\n * @throws FLT-202 Filter requires at least one option\r\n */\r\nexport function optionsRequired(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires at least one option`,\r\n    context: createContext(\"Filter.optionsRequired\", fnName),\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\n/**\r\n * Throws error when filter option must be a number but invalid value provided.\r\n * \r\n * @param fnName - Name of the filter function\r\n * @returns Never returns (always throws)\r\n * @throws FLT-202 Filter requires a number as option\r\n */\r\nexport function optionMustBeNumber(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a number as option`,\r\n    context: createContext(\"Filter.optionMustBeNumber\", fnName),\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\n/**\r\n * Throws error when filter requires numeric value but non-number provided.\r\n * \r\n * @param fnName - Name of the filter function\r\n * @returns Never returns (always throws)\r\n * @throws FLT-202 Filter requires a number value\r\n */\r\nexport function valueMustBeNumber(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a number value`,\r\n    context: createContext(\"Filter.valueMustBeNumber\", fnName),\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\n/**\r\n * Throws error when filter requires numeric value but non-number provided.\r\n * \r\n * @param fnName - Name of the filter function\r\n * @returns Never returns (always throws)\r\n * @throws FLT-202 Filter requires a number value\r\n */\r\nexport function valueMustBeString(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a string value`,\r\n    context: createContext(\"Filter.valueMustBeString\", fnName),\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\n/**\r\n * Throws error when filter requires boolean value but non-boolean provided.\r\n * \r\n * @param fnName - Name of the filter function\r\n * @returns Never returns (always throws)\r\n * @throws FLT-202 Filter requires a boolean value\r\n */\r\nexport function valueMustBeBoolean(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a boolean value`,\r\n    context: createContext(\"Filter.valueMustBeBoolean\", fnName),\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\n/**\r\n * Throws error when filter requires Date value but non-Date provided.\r\n * \r\n * @param fnName - Name of the filter function\r\n * @returns Never returns (always throws)\r\n * @throws FLT-202 Filter requires a date value\r\n */\r\nexport function valueMustBeDate(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a date value`,\r\n    context: createContext(\"Filter.valueMustBeDate\", fnName),\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}","/**\r\n * builtinFilters.ts\r\n *\r\n * Implementation file for built-in filter functions available in Structive.\r\n *\r\n * Main responsibilities:\r\n * - Provides filters for conversion, comparison, formatting, and validation of numbers, strings, dates, booleans, etc.\r\n * - Defines functions with options for each filter name, enabling flexible use during binding\r\n * - Designed for common use as both input and output filters\r\n *\r\n * Design points:\r\n * - Comprehensive coverage of diverse filters: eq, ne, lt, gt, inc, fix, locale, uc, lc, cap, trim, slice, pad, int, float, round, date, time, ymd, falsy, truthy, defaults, boolean, number, string, null, etc.\r\n * - Rich type checking and error handling for option values\r\n * - Centralized management of filter functions with FilterWithOptions type, easy to extend\r\n * - Dynamic retrieval of filter functions from filter names and options via builtinFilterFn\r\n */\r\nimport { getGlobalConfig } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { optionMustBeNumber, optionsRequired, valueMustBeBoolean, valueMustBeDate, valueMustBeNumber } from \"./errorMessages.js\";\r\nimport { FilterFn, FilterWithOptions } from \"./types\";\r\n\r\nconst config = getGlobalConfig();\r\n\r\nfunction validateNumberString(value: string): boolean {\r\n  if (!value || isNaN(Number(value))) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Equality filter - compares value with option.\r\n * \r\n * @param options - Array with comparison value as first element\r\n * @returns Filter function that returns boolean\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number (when value is number)\r\n */\r\nconst eq = (options?:string[]): FilterFn<boolean> => {\r\n  const opt = options?.[0] ?? optionsRequired('eq');\r\n  return (value: unknown): boolean => {\r\n    // Align types for comparison\r\n    if (typeof value === 'number') {\r\n      if (!validateNumberString(opt)) {optionMustBeNumber('eq');}\r\n      return value === Number(opt);\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value === opt;\r\n    }\r\n    // Strict equality for others\r\n    return value === opt;\r\n  }\r\n}\r\n\r\n/**\r\n * Inequality filter - compares value with option.\r\n * \r\n * @param options - Array with comparison value as first element\r\n * @returns Filter function that returns boolean\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number (when value is number)\r\n */\r\nconst ne = (options?:string[]): FilterFn<boolean> => {\r\n  const opt = options?.[0] ?? optionsRequired('ne');\r\n  return (value: unknown): boolean => {\r\n    // Align types for comparison\r\n    if (typeof value === 'number') {\r\n      if (!validateNumberString(opt)) {optionMustBeNumber('ne');}\r\n      return value !== Number(opt);\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value !== opt;\r\n    }\r\n    // Strict equality for others\r\n    return value !== opt;\r\n  }\r\n}\r\n\r\n/**\r\n * Boolean NOT filter - inverts boolean value.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns inverted boolean\r\n * @throws FLT-103 Value must be boolean\r\n */\r\nconst not = (_options?:string[]): FilterFn<boolean> => {\r\n  return (value: unknown): boolean => {\r\n    if (typeof value !== 'boolean') {valueMustBeBoolean('not');}\r\n    return !value;\r\n  }\r\n}\r\n\r\n/**\r\n * Less than filter - checks if value is less than option.\r\n * \r\n * @param options - Array with comparison number as first element\r\n * @returns Filter function that returns boolean\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst lt = (options?:string[]): FilterFn<boolean> => {\r\n  const opt = options?.[0] ?? optionsRequired('lt');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('lt');}\r\n  return (value: unknown): boolean => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('lt');}\r\n    return value < Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Less than or equal filter - checks if value is less than or equal to option.\r\n * \r\n * @param options - Array with comparison number as first element\r\n * @returns Filter function that returns boolean\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst le = (options?:string[]): FilterFn<boolean> => {\r\n  const opt = options?.[0] ?? optionsRequired('le');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('le');}\r\n  return (value: unknown): boolean => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('le');}\r\n    return value <= Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Greater than filter - checks if value is greater than option.\r\n * \r\n * @param options - Array with comparison number as first element\r\n * @returns Filter function that returns boolean\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst gt = (options?:string[]): FilterFn<boolean> => {\r\n  const opt = options?.[0] ?? optionsRequired('gt');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('gt');}\r\n  return (value: unknown): boolean => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('gt');}\r\n    return value > Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Greater than or equal filter - checks if value is greater than or equal to option.\r\n * \r\n * @param options - Array with comparison number as first element\r\n * @returns Filter function that returns boolean\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst ge = (options?:string[]): FilterFn<boolean> => {\r\n  const opt = options?.[0] ?? optionsRequired('ge');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('ge');}\r\n  return (value: unknown): boolean => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('ge');}\r\n    return value >= Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Increment filter - adds option value to input value.\r\n * \r\n * @param options - Array with increment number as first element\r\n * @returns Filter function that returns incremented number\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst inc = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? optionsRequired('inc');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('inc');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('inc');}\r\n    return value + Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Decrement filter - subtracts option value from input value.\r\n * \r\n * @param options - Array with decrement number as first element\r\n * @returns Filter function that returns decremented number\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst dec = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? optionsRequired('dec');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('dec');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('dec');}\r\n    return value - Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Multiply filter - multiplies value by option.\r\n * \r\n * @param options - Array with multiplier number as first element\r\n * @returns Filter function that returns multiplied number\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst mul = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? optionsRequired('mul');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('mul');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('mul');}\r\n    return value * Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Divide filter - divides value by option.\r\n * \r\n * @param options - Array with divisor number as first element\r\n * @returns Filter function that returns divided number\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst div = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? optionsRequired('div');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('div');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('div');}\r\n    return value / Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Modulo filter - returns remainder of division.\r\n * \r\n * @param options - Array with divisor number as first element\r\n * @returns Filter function that returns remainder\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst mod = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? optionsRequired('mod');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('mod');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('mod');}\r\n    return value % Number(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Fixed decimal filter - formats number to fixed decimal places.\r\n * \r\n * @param options - Array with decimal places as first element (default: 0)\r\n * @returns Filter function that returns formatted string\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst fix = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? \"0\";\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('fix');}\r\n  return (value: unknown): string => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('fix');}\r\n    return value.toFixed(Number(opt));\r\n  }\r\n}\r\n\r\n/**\r\n * Locale number filter - formats number according to locale.\r\n * \r\n * @param options - Array with locale string as first element (default: config.locale)\r\n * @returns Filter function that returns localized number string\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst locale = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: unknown): string => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('locale');}\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Uppercase filter - converts string to uppercase.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns uppercase string\r\n */\r\nconst uc = (_options?:string[]): FilterFn<string> => {\r\n  return (value: unknown): string => {\r\n    return String(value).toUpperCase();\r\n  }\r\n}\r\n\r\n/**\r\n * Lowercase filter - converts string to lowercase.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns lowercase string\r\n */\r\nconst lc = (_options?:string[]): FilterFn<string> => {\r\n  return (value: unknown): string => {\r\n    return String(value).toLowerCase();\r\n  }\r\n}\r\n\r\n/**\r\n * Capitalize filter - capitalizes first character of string.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns capitalized string\r\n */\r\nconst cap = (_options?:string[]): FilterFn<string> => {\r\n  return (value: unknown): string => {\r\n    const v = String(value);\r\n    if (v.length === 0) {return v;}\r\n    if (v.length === 1) {return v.toUpperCase();}\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n  }\r\n}\r\n\r\n/**\r\n * Trim filter - removes whitespace from both ends of string.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns trimmed string\r\n */\r\nconst trim = (_options?:string[]): FilterFn<string> => {\r\n  return (value: unknown): string => {\r\n    return String(value).trim();\r\n  }\r\n}\r\n\r\n/**\r\n * Slice filter - extracts portion of string from specified index.\r\n * \r\n * @param options - Array with start index as first element\r\n * @returns Filter function that returns sliced string\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n */\r\nconst slice = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? optionsRequired('slice');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('slice');}\r\n  return (value: unknown): string => {\r\n    return String(value).slice(Number(opt));\r\n  }\r\n}\r\n\r\n/**\r\n * Substring filter - extracts substring from specified position and length.\r\n * \r\n * @param options - Array with start index and length\r\n * @returns Filter function that returns substring\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n */\r\nconst substr = (options?:string[]): FilterFn<string> => {\r\n  const opt1 = options?.[0] ?? optionsRequired('substr');\r\n  if (!validateNumberString(opt1)) {optionMustBeNumber('substr');}\r\n  const opt2 = options?.[1] ?? optionsRequired('substr');\r\n  if (!validateNumberString(opt2)) {optionMustBeNumber('substr');}\r\n  return (value: unknown): string => {\r\n    return String(value).substr(Number(opt1), Number(opt2));\r\n  }\r\n}\r\n\r\n/**\r\n * Pad filter - pads string to specified length from start.\r\n * \r\n * @param options - Array with target length and pad string (default: '0')\r\n * @returns Filter function that returns padded string\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n */\r\nconst pad = (options?:string[]): FilterFn<string> => {\r\n  const opt1 = options?.[0] ?? optionsRequired('pad');\r\n  if (!validateNumberString(opt1)) {optionMustBeNumber('pad');}\r\n  const opt2 = options?.[1] ?? '0';\r\n  return (value: unknown): string => {\r\n    return String(value).padStart(Number(opt1), opt2);\r\n  }\r\n}\r\n\r\n/**\r\n * Repeat filter - repeats string specified number of times.\r\n * \r\n * @param options - Array with repeat count as first element\r\n * @returns Filter function that returns repeated string\r\n * @throws FLT-101 Options required\r\n * @throws FLT-102 Option must be number\r\n */\r\nconst rep = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? optionsRequired('rep');\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('rep');}\r\n  return (value: unknown): string => {\r\n    return String(value).repeat(Number(opt));\r\n  }\r\n}\r\n\r\n/**\r\n * Reverse filter - reverses character order in string.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns reversed string\r\n */\r\nconst rev = (_options?:string[]): FilterFn<string> => {\r\n  return (value: unknown): string => {\r\n    return String(value).split('').reverse().join('');\r\n  }\r\n}\r\n\r\n/**\r\n * Integer filter - parses value to integer.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns integer\r\n */\r\nconst int = (_options?:string[]): FilterFn<number> => {\r\n  return (value: unknown): number => {\r\n    return parseInt(String(value), 10);\r\n  }\r\n}\r\n\r\n/**\r\n * Float filter - parses value to floating point number.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns float\r\n */\r\nconst float = (_options?:string[]): FilterFn<number> => {\r\n  return (value: unknown): number => {\r\n    return parseFloat(String(value));\r\n  }\r\n}\r\n\r\n/**\r\n * Round filter - rounds number to specified decimal places.\r\n * \r\n * @param options - Array with decimal places as first element (default: 0)\r\n * @returns Filter function that returns rounded number\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst round = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? '0';\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('round');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('round');}\r\n    const optValue = Math.pow(10, Number(opt));\r\n    return Math.round(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\n/**\r\n * Floor filter - rounds number down to specified decimal places.\r\n * \r\n * @param options - Array with decimal places as first element (default: 0)\r\n * @returns Filter function that returns floored number\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst floor = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? '0';\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('floor');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('floor');}\r\n    const optValue = Math.pow(10, Number(opt));\r\n    return Math.floor(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\n/**\r\n * Ceiling filter - rounds number up to specified decimal places.\r\n * \r\n * @param options - Array with decimal places as first element (default: 0)\r\n * @returns Filter function that returns ceiled number\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst ceil = (options?:string[]): FilterFn<number> => {\r\n  const opt = options?.[0] ?? '0';\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('ceil');}\r\n  return (value: unknown): number => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('ceil');}\r\n    const optValue = Math.pow(10, Number(opt));\r\n    return Math.ceil(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\n/**\r\n * Percent filter - formats number as percentage string.\r\n * \r\n * @param options - Array with decimal places as first element (default: 0)\r\n * @returns Filter function that returns percentage string with '%'\r\n * @throws FLT-102 Option must be number\r\n * @throws FLT-104 Value must be number\r\n */\r\nconst percent = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? '0';\r\n  if (!validateNumberString(opt)) {optionMustBeNumber('percent');}\r\n  return (value: unknown): string => {\r\n    if (typeof value !== 'number') {valueMustBeNumber('percent');}\r\n    return `${(value * 100).toFixed(Number(opt))}%`;\r\n  }\r\n}\r\n\r\n/**\r\n * Date filter - formats Date object as localized date string.\r\n * \r\n * @param options - Array with locale string as first element (default: config.locale)\r\n * @returns Filter function that returns date string\r\n * @throws FLT-105 Value must be Date\r\n */\r\nconst date = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: unknown): string => {\r\n    if (!(value instanceof Date))  {valueMustBeDate('date');}\r\n    return value.toLocaleDateString(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Time filter - formats Date object as localized time string.\r\n * \r\n * @param options - Array with locale string as first element (default: config.locale)\r\n * @returns Filter function that returns time string\r\n * @throws FLT-105 Value must be Date\r\n */\r\nconst time = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: unknown): string => {\r\n    if (!(value instanceof Date)) {valueMustBeDate('time');}\r\n    return value.toLocaleTimeString(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * DateTime filter - formats Date object as localized date and time string.\r\n * \r\n * @param options - Array with locale string as first element (default: config.locale)\r\n * @returns Filter function that returns datetime string\r\n * @throws FLT-105 Value must be Date\r\n */\r\nconst datetime = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: unknown): string => {\r\n    if (!(value instanceof Date)) {valueMustBeDate('datetime');}\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\n/**\r\n * Year-Month-Day filter - formats Date object as YYYY-MM-DD string.\r\n * \r\n * @param options - Array with separator string as first element (default: '-')\r\n * @returns Filter function that returns formatted date string\r\n * @throws FLT-105 Value must be Date\r\n */\r\nconst ymd = (options?:string[]): FilterFn<string> => {\r\n  const opt = options?.[0] ?? '-';\r\n  return (value: unknown): string => {\r\n    if (!(value instanceof Date)) {valueMustBeDate('ymd');}\r\n    const year = value.getFullYear().toString();\r\n    const month = (value.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = value.getDate().toString().padStart(2, '0');\r\n    return `${year}${opt}${month}${opt}${day}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Falsy filter - checks if value is falsy.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns true for false/null/undefined/0/''/NaN\r\n */\r\nconst falsy = (_options?:string[]): FilterFn<boolean> => {\r\n  return (value: unknown): boolean => value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value);\r\n}\r\n\r\n/**\r\n * Truthy filter - checks if value is truthy.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns true for non-falsy values\r\n */\r\nconst truthy = (_options?:string[]): FilterFn<boolean> => {\r\n  return (value: unknown): boolean =>value !== false && value !== null && value !== undefined && value !== 0 && value !== '' && !Number.isNaN(value);\r\n}\r\n\r\n/**\r\n * Default filter - returns default value if input is falsy.\r\n * \r\n * @param options - Array with default value as first element\r\n * @returns Filter function that returns value or default\r\n * @throws FLT-101 Options required\r\n */\r\nconst defaults = (options?:string[]): FilterFn<unknown> => {\r\n  const opt = options?.[0] ?? optionsRequired('defaults');\r\n  return (value: unknown): unknown => {\r\n    if (value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value)) {return opt;}\r\n    return value;\r\n  }\r\n}\r\n\r\n/**\r\n * Boolean filter - converts value to boolean.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns boolean\r\n */\r\nconst boolean = (_options?:string[]): FilterFn<boolean> => {\r\n  return (value: unknown): boolean => {\r\n    return Boolean(value);\r\n  }\r\n}\r\n\r\n/**\r\n * Number filter - converts value to number.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns number\r\n */\r\nconst number = (_options?:string[]): FilterFn<number> => {\r\n  return (value: unknown): number => {\r\n    return Number(value);\r\n  }\r\n}\r\n\r\n/**\r\n * String filter - converts value to string.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns string\r\n */\r\nconst string = (_options?:string[]): FilterFn<string> => {\r\n  return (value: unknown): string => {\r\n    return String(value);\r\n  }\r\n}\r\n\r\n/**\r\n * Null filter - converts empty string to null.\r\n * \r\n * @param options - Unused\r\n * @returns Filter function that returns null for empty string, otherwise original value\r\n */\r\nconst _null = (_options?:string[]): FilterFn<unknown> => {\r\n  return (value: unknown): unknown => {\r\n    return (value === \"\") ? null : value;\r\n  } \r\n}\r\n\r\nconst builtinFilters: FilterWithOptions = {\r\n  \"eq\": eq,\r\n  \"ne\": ne,\r\n  \"not\": not,\r\n\r\n  \"lt\": lt,\r\n  \"le\": le,\r\n  \"gt\": gt,\r\n  \"ge\": ge,\r\n\r\n  \"inc\": inc,\r\n  \"dec\": dec,\r\n  \"mul\": mul,\r\n  \"div\": div,\r\n  \"mod\": mod,\r\n\r\n  \"fix\": fix,\r\n  \"locale\": locale,\r\n  \"uc\": uc,\r\n  \"lc\": lc,\r\n  \"cap\": cap,\r\n  \"trim\": trim,\r\n  \"slice\": slice,\r\n  \"substr\": substr,\r\n  \"pad\": pad,\r\n  \"rep\": rep,\r\n  \"rev\": rev,\r\n\r\n  \"int\": int,\r\n  \"float\": float,\r\n  \"round\": round,\r\n  \"floor\": floor,\r\n  \"ceil\": ceil,\r\n  \"percent\": percent,\r\n\r\n  \"date\": date,\r\n  \"time\": time,\r\n  \"datetime\": datetime,\r\n  \"ymd\": ymd,\r\n\r\n  \"falsy\": falsy,\r\n  \"truthy\": truthy,\r\n  \"defaults\": defaults,\r\n\r\n  \"boolean\": boolean,\r\n  \"number\": number,\r\n  \"string\": string,\r\n  \"null\": _null,\r\n};\r\n\r\nexport const outputBuiltinFilters = builtinFilters;\r\nexport const inputBuiltinFilters = builtinFilters;\r\n\r\n/**\r\n * Retrieves built-in filter function by name and options.\r\n * \r\n * @param name - Filter name\r\n * @param options - Array of option strings\r\n * @returns Function that takes FilterWithOptions and returns filter function\r\n * @throws FLT-201 Filter not found\r\n */\r\nexport const builtinFilterFn = (name:string, options: string[]) => (filters: FilterWithOptions) => {\r\n  const filter = filters[name];\r\n  if (!filter) {\r\n    raiseError({\r\n      code: \"FLT-201\",\r\n      message: `Filter not found: ${name}`,\r\n      context: { where: 'builtinFilterFn', name },\r\n      docsUrl: \"./docs/error-codes.md#flt\",\r\n    });\r\n  }\r\n  return filter(options);\r\n}\r\n\r\n","\r\nlet id = 0;\r\n\r\nexport function generateId(): number {\r\n  return ++id;\r\n}","/**\r\n * registerStateClass.ts\r\n *\r\n * Management module for registering and retrieving StateClass instances by ID.\r\n *\r\n * Main responsibilities:\r\n * - stateClassById: Record managing StateClass instances keyed by ID\r\n * - registerStateClass: Registers a StateClass instance with the specified ID\r\n * - getStateClassById: Retrieves a StateClass instance by ID (throws error if not registered)\r\n *\r\n * Design points:\r\n * - Centrally manages StateClass instances globally for fast access via ID\r\n * - Raises clear exceptions via raiseError when accessing non-existent IDs\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IStructiveState } from \"./types\";\r\n\r\n// Global registry mapping StateClass IDs to their instances\r\nconst stateClassById: Record<number,IStructiveState> = {};\r\n\r\n/**\r\n * Registers a StateClass instance with a unique ID.\r\n * \r\n * This function stores the StateClass instance in a global registry,\r\n * making it accessible for retrieval via getStateClassById.\r\n * \r\n * @param id - Unique identifier for the StateClass instance\r\n * @param stateClass - StateClass instance to register\r\n */\r\nexport function registerStateClass(id: number, stateClass: IStructiveState) {\r\n  stateClassById[id] = stateClass;\r\n}\r\n\r\n/**\r\n * Retrieves a registered StateClass instance by its ID.\r\n * \r\n * This function looks up a StateClass instance from the global registry.\r\n * If the ID is not found, it throws a descriptive error.\r\n * \r\n * @param id - Unique identifier of the StateClass instance to retrieve\r\n * @returns The registered StateClass instance\r\n * @throws {Error} STATE-101 - When no StateClass is registered with the given ID\r\n */\r\nexport function getStateClassById(id: number): IStructiveState {\r\n  return stateClassById[id] ?? raiseError({\r\n    code: \"STATE-101\",\r\n    message: `StateClass not found: ${id}`,\r\n    context: { where: 'StateClass.getStateClassById', stateClassId: id },\r\n    docsUrl: \"./docs/error-codes.md#state\",\r\n  });\r\n}\r\n","/**\r\n * registerStyleSheet.ts\r\n *\r\n * Management module for registering and retrieving CSSStyleSheet instances by ID.\r\n *\r\n * Main responsibilities:\r\n * - styleSheetById: Record that manages CSSStyleSheet instances keyed by ID\r\n * - registerStyleSheet: Registers a CSSStyleSheet instance with a specified ID\r\n * - getStyleSheetById: Retrieves a CSSStyleSheet instance by ID (throws error if not registered)\r\n *\r\n * Design points:\r\n * - Centrally manages CSSStyleSheet instances globally, enabling fast access via ID\r\n * - Throws clear exceptions via raiseError when accessing non-existent IDs\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\n\r\n/**\r\n * Global registry for CSSStyleSheet instances keyed by numeric ID.\r\n * Enables fast lookup and sharing of stylesheets across components.\r\n */\r\nconst styleSheetById: Record<number,CSSStyleSheet> = {};\r\n\r\n/**\r\n * Registers a CSSStyleSheet instance with a unique numeric ID.\r\n * Allows the stylesheet to be retrieved later via getStyleSheetById.\r\n * Overwrites any existing stylesheet with the same ID.\r\n * \r\n * @param {number} id - Unique numeric identifier for the stylesheet\r\n * @param {CSSStyleSheet} css - The CSSStyleSheet instance to register\r\n * @returns {void}\r\n * \r\n * @example\r\n * const sheet = new CSSStyleSheet();\r\n * registerStyleSheet(1, sheet);\r\n */\r\nexport function registerStyleSheet(id: number, css: CSSStyleSheet) {\r\n  styleSheetById[id] = css;\r\n}\r\n\r\n/**\r\n * Retrieves a registered CSSStyleSheet instance by its numeric ID.\r\n * Throws an error if no stylesheet is found with the given ID.\r\n * \r\n * @param {number} id - The numeric identifier of the stylesheet to retrieve\r\n * @returns {CSSStyleSheet} The registered CSSStyleSheet instance\r\n * @throws {Error} Throws CSS-001 error if the stylesheet ID is not registered\r\n * \r\n * @example\r\n * const sheet = getStyleSheetById(1);\r\n * document.adoptedStyleSheets = [sheet];\r\n */\r\nexport function getStyleSheetById(id: number): CSSStyleSheet {\r\n  // Return the stylesheet if found, otherwise throw a descriptive error\r\n  return styleSheetById[id] ?? raiseError({\r\n    code: \"CSS-001\",\r\n    message: `Stylesheet not found: ${id}`,\r\n    context: { where: 'StyleSheet.getStyleSheetById', styleSheetId: id },\r\n    docsUrl: \"./docs/error-codes.md#css\",\r\n  });\r\n}","/**\r\n * regsiterCss.ts\r\n *\r\n * Utility function for creating CSSStyleSheet from CSS strings and registering them by ID.\r\n *\r\n * Main responsibilities:\r\n * - Creates CSSStyleSheet instances from CSS strings\r\n * - Registers the CSSStyleSheet with a specified ID using registerStyleSheet\r\n *\r\n * Design points:\r\n * - Uses styleSheet.replaceSync to apply CSS synchronously\r\n * - Enables global style management and dynamic style application\r\n */\r\nimport { registerStyleSheet } from \"./registerStyleSheet.js\";\r\n\r\n/**\r\n * Creates a CSSStyleSheet from a CSS string and registers it with a unique ID.\r\n * The CSS is applied synchronously using replaceSync for immediate availability.\r\n * \r\n * @param {number} id - Unique numeric identifier for the stylesheet\r\n * @param {string} css - CSS rules as a string to be applied to the stylesheet\r\n * @returns {void}\r\n * \r\n * @example\r\n * registerCss(1, `\r\n *   .container { display: flex; }\r\n *   .item { padding: 10px; }\r\n * `);\r\n */\r\nexport function registerCss(id: number, css: string) {\r\n  // Create a new CSSStyleSheet instance\r\n  const styleSheet = new CSSStyleSheet();\r\n  \r\n  // Apply CSS rules synchronously to the stylesheet\r\n  styleSheet.replaceSync(css);\r\n  \r\n  // Register the stylesheet in the global registry\r\n  registerStyleSheet(id, styleSheet);\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * Utility function to traverse and retrieve the target node from root node and node path (index array).\r\n *\r\n * NodePath structure:\r\n * - Numeric array representing childNodes index at each level\r\n * - Example: [1, 2] represents root.childNodes[1].childNodes[2]\r\n * - Empty array [] represents root node itself\r\n * \r\n * Processing characteristics:\r\n * - Traverse childNodes[index] sequentially from root to get target node\r\n * - Returns null if node doesn't exist midway (error-safe)\r\n * - Uses for loop instead of reduce (breaks immediately when null)\r\n * \r\n * Processing flow:\r\n * 1. Set root node as starting point\r\n * 2. If path is empty array, return root node (early return)\r\n * 3. Traverse each index in path sequentially:\r\n *    a. Get childNodes[index] of current node\r\n *    b. If node doesn't exist, set null and break loop\r\n * 4. Return final node (or null)\r\n * \r\n * DOM tree example:\r\n * ```html\r\n * <div>                    // root (index: -)\r\n *   <span>Hello</span>     // root.childNodes[0]\r\n *   <ul>                   // root.childNodes[1]\r\n *     <li>Item 1</li>      // root.childNodes[1].childNodes[0]\r\n *     <li>Item 2</li>      // root.childNodes[1].childNodes[1]\r\n *   </ul>\r\n * </div>\r\n * ```\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * const root = document.querySelector('#root');\r\n * \r\n * // Empty path → Returns root node itself\r\n * const node1 = resolveNodeFromPath(root, []);\r\n * // → root\r\n * \r\n * // Single index\r\n * const node2 = resolveNodeFromPath(root, [1]);\r\n * // → root.childNodes[1] (<ul> element)\r\n * \r\n * // Multiple levels\r\n * const node3 = resolveNodeFromPath(root, [1, 1]);\r\n * // → root.childNodes[1].childNodes[1] (<li>Item 2</li>)\r\n * \r\n * // Invalid path (non-existent index)\r\n * const node4 = resolveNodeFromPath(root, [1, 5]);\r\n * // → null (childNodes[5] doesn't exist)\r\n * \r\n * // Invalid path (no node midway)\r\n * const node5 = resolveNodeFromPath(root, [0, 0, 0]);\r\n * // → null (<span>Hello</span>'s childNodes[0] is text node,\r\n * //         its childNodes[0] doesn't exist)\r\n * ```\r\n * \r\n * @param root - Root node as starting point for traversal\r\n * @param path - Index array for each level (NodePath)\r\n * @returns Node specified by path, or null\r\n */\r\nexport function resolveNodeFromPath(root: Node, path: NodePath): Node | null {\r\n  // Step 1: Set root node as starting point\r\n  let node = root;\r\n  \r\n  // Step 2: Return root node if path is empty\r\n  if (path.length === 0) {return node;}\r\n  \r\n  // Step 3: Traverse each index in path sequentially\r\n  // Using for loop instead of path.reduce() to explicitly check and break when null\r\n  for (let i = 0; i < path.length; i++) {\r\n    // Get childNodes[index] of current node (null if doesn't exist)\r\n    node = node?.childNodes[path[i]] ?? null;\r\n    \r\n    // Break loop if node doesn't exist\r\n    if (node === null) {break;}\r\n  }\r\n  \r\n  // Step 4: Return final node (or null)\r\n  return node;\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * Utility function that traces the index from parent node to root for the specified node,\r\n * and returns it as an absolute path (NodePath).\r\n *\r\n * Processing flow:\r\n * 1. Start from current node and loop while parent node exists\r\n * 2. Get index of current node within parent's childNodes\r\n * 3. Prepend index to array (build in reverse order)\r\n * 4. Move to parent node and repeat\r\n * 5. Return index array when root node is reached\r\n *\r\n * Example: Given the following DOM tree structure:\r\n * ```\r\n * root\r\n *   ├─ child[0]\r\n *   ├─ child[1]\r\n *   │   ├─ grandchild[0]\r\n *   │   ├─ grandchild[1]\r\n *   │   └─ grandchild[2] ← Specify this node\r\n *   └─ child[2]\r\n * ```\r\n * Returns `[1, 2]` (index 1 in parent, index 2 within that)\r\n *\r\n * This absolute path is used to locate the same node from template later.\r\n * (Forms a pair with resolveNodeFromPath function)\r\n *\r\n * @param node - Target DOM node to get absolute path for\r\n * @returns Index array from root to this node (NodePath)\r\n */\r\nexport function getAbsoluteNodePath(node: Node): NodePath {\r\n  // Array to store result (indexes arranged from root to leaf)\r\n  let routeIndexes: NodePath = [];\r\n  let currentNode: Node | null = node;\r\n  \r\n  // Loop while parent node exists (until reaching root)\r\n  while (currentNode.parentNode !== null) {\r\n    // Convert parent node's childNodes to array\r\n    const childNodes = Array.from(currentNode.parentNode.childNodes) as Node[];\r\n    \r\n    // Get index of current node within parent's childNodes and prepend to array\r\n    // Prepending maintains root→leaf order\r\n    routeIndexes = [childNodes.indexOf(currentNode), ...routeIndexes];\r\n    \r\n    // Move to parent node for next iteration\r\n    currentNode = currentNode.parentNode;\r\n  }\r\n  \r\n  // Return index array from root\r\n  return routeIndexes;\r\n}","import { FilterFn, Filters, FilterWithOptions } from \"../Filter/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\n\r\n/**\r\n * Generates an executable filter function (FilterFn) from filter text metadata\r\n * (containing name and options).\r\n * \r\n * Processing flow:\r\n * 1. Look up filter function from registry by filter name\r\n * 2. Raise error if not found\r\n * 3. Apply options array and return customized filter function\r\n * \r\n * @param filters - Filter registry (name -> factory function map)\r\n * @param text - Filter metadata (name and options array)\r\n * @returns Customized filter function\r\n * @throws When filter is not found\r\n */\r\nfunction textToFilter(filters: FilterWithOptions, text: IFilterText): FilterFn {\r\n  // Look up filter from registry by name\r\n  const filter = filters[text.name];\r\n  \r\n  if (!filter) {\r\n    // Raise error when filter is not found\r\n    raiseError({\r\n      code: 'FLT-201',\r\n      message: `Filter not found: ${text.name}`,\r\n      context: { where: 'createFilters.textToFilter', name: text.name },\r\n      docsUrl: './docs/error-codes.md#flt',\r\n    });\r\n  }\r\n  \r\n  // Pass options array to filter factory to generate executable function\r\n  // Example: filters['currency'](['USD', '2']) => (value) => formatCurrency(value, 'USD', 2)\r\n  return filter(text.options);\r\n}\r\n\r\n/**\r\n * Cache for filter text arrays\r\n * When the same filter array is used multiple times, return from cache instead of regenerating\r\n */\r\nconst cache: Map<IFilterText[], Filters> = new Map();\r\n\r\n/**\r\n * Generates an array of executable filter functions from filter text array (metadata).\r\n * Uses cache for the same texts array to optimize performance.\r\n * \r\n * Processing flow:\r\n * 1. Check cache (has this texts array been processed before?)\r\n * 2. On cache hit, return cached result\r\n * 3. On cache miss, transform each filter text via textToFilter\r\n * 4. Store generated function array in cache\r\n * 5. Return filter function array\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * const filterTexts = [\r\n *   { name: 'trim', options: [] },\r\n *   { name: 'uppercase', options: [] }\r\n * ];\r\n * const filterFns = createFilters(registry, filterTexts);\r\n * // filterFns[0](value) -> trim(value)\r\n * // filterFns[1](value) -> uppercase(value)\r\n * ```\r\n * \r\n * @param filters - Filter registry (name -> factory function map)\r\n * @param texts - Array of filter metadata\r\n * @returns Array of executable filter functions\r\n */\r\nexport function createFilters(filters: FilterWithOptions, texts: IFilterText[]): Filters {\r\n  // Check cache\r\n  let result = cache.get(texts);\r\n  \r\n  if (typeof result === \"undefined\") {\r\n    // Cache miss: generate new\r\n    result = [];\r\n    \r\n    // Transform each filter text into executable function\r\n    for (let i = 0; i < texts.length; i++) {\r\n      result.push(textToFilter(filters, texts[i]));\r\n    }\r\n    \r\n    // Store generated function array in cache (reuse in subsequent calls)\r\n    cache.set(texts, result);\r\n  }\r\n  \r\n  // Return cached or newly generated result\r\n  return result;\r\n}\r\n","/**\r\n * Creates and caches filter functions for data binding.\r\n * \r\n * This module provides a caching mechanism for filter creation to avoid\r\n * recreating filter chains for the same filter definitions and text patterns.\r\n */\r\nimport { createFilters } from \"../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../Filter/types\";\r\n\r\n// Cache storage: Map<FilterDefinitions, Map<FilterTextPatterns, CreatedFilters>>\r\nconst filtersByFilterTextsByFilters: Map<FilterWithOptions, Map<IFilterText[], Filters>> = new Map();\r\n\r\n/**\r\n * Creates a list of filter functions based on the provided definitions and text patterns.\r\n * Results are cached to improve performance when the same filters are requested multiple times.\r\n * \r\n * @param filters - The available filter definitions (map of filter names to functions/options).\r\n * @param filterTexts - The parsed filter text patterns from the binding string.\r\n * @returns An array of executable filter functions.\r\n */\r\nexport function createBindingFilters(filters: FilterWithOptions, filterTexts: IFilterText[]): Filters {\r\n  let filtersByFilterTexts = filtersByFilterTextsByFilters.get(filters);\r\n  if (!filtersByFilterTexts) {\r\n    filtersByFilterTexts = new Map();\r\n    filtersByFilterTextsByFilters.set(filters, filtersByFilterTexts);\r\n  }\r\n  let filterFns = filtersByFilterTexts.get(filterTexts);\r\n  if (!filterFns) {\r\n    filterFns = createFilters(filters, filterTexts);\r\n    filtersByFilterTexts.set(filterTexts, filterFns);\r\n  }\r\n  return filterFns;\r\n}","import { Filters } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../../Updater/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { IBindingNode } from \"./types\";\r\n\r\n/**\r\n * BindingNode class is the base class for binding processing on a single target node (Element, Text, etc.).\r\n *\r\n * Architecture:\r\n * - _binding: Reference to parent binding (IBinding)\r\n * - _node: Target DOM node for binding\r\n * - _name: Property name of binding (e.g., \"textContent\", \"value\")\r\n * - _filters: Array of filter functions applied when retrieving value\r\n * - _decorates: Array of decorator strings (e.g., [\"prevent\", \"stop\"])\r\n * - _bindContents: Array of child BindContent (for structural control bindings)\r\n *\r\n * Main responsibilities:\r\n * 1. Hold node, property name, filters, decorators, and binding info\r\n * 2. Provide interface for binding value update (applyChange → assignValue)\r\n * 3. Manage multiple bind contents (bindContents) for structural control bindings\r\n * 4. Extend binding processing per node/property type by implementing assignValue, updateElements in subclasses\r\n *\r\n * Design patterns:\r\n * - Template Method: applyChange provides common flow, assignValue implemented in subclasses\r\n * - Strategy: Customize behavior with filters and decorators\r\n *\r\n * Subclasses:\r\n * - BindingNodeAttribute: Attribute binding\r\n * - BindingNodeProperty*: Property binding (value, checked, etc.)\r\n * - BindingNodeEvent*: Event binding\r\n * - BindingNodeFor, BindingNodeIf: Structural control binding\r\n *\r\n * Design points:\r\n * - assignValue, updateElements are unimplemented (must override in subclasses)\r\n * - isSelectElement, value, filteredValue etc. extended in subclasses as needed\r\n * - Flexible handling of filters, decorators, and bind contents\r\n */\r\nexport class BindingNode implements IBindingNode {\r\n  readonly isSelectElement: boolean;\r\n  readonly node: Node;\r\n  readonly name: string;\r\n  readonly subName: string;\r\n  readonly binding: IBinding;\r\n  readonly decorates: string[];\r\n  readonly filters: Filters;\r\n  readonly renderable: boolean = true;\r\n  readonly buildable: boolean = false;\r\n  \r\n  /**\r\n   * Getter to return array of child BindContent (for structural control bindings).\r\n   * \r\n   * @returns Array of IBindContent instances (empty in base class)\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return [];\r\n  }\r\n  \r\n  /**\r\n   * Constructor.\r\n   * - binding: Parent binding\r\n   * - node: Target DOM node for binding\r\n   * - name: Property name of binding\r\n   * - filters: Array of filter functions\r\n   * - decorates: Array of decorator strings\r\n   *\r\n   * Initialization process:\r\n   * 1. Save all parameters to private fields\r\n   * 2. bindContents initialized as empty array\r\n   * 3. Subclasses can implement additional initialization in activate()\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Target DOM node\r\n   * @param name - Property name of binding\r\n   * @param subName - Sub-property name\r\n   * @param filters - Array of filter functions\r\n   * @param decorates - Array of decorator strings\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    this.isSelectElement = node instanceof HTMLSelectElement;\r\n    this.node = node;\r\n    this.name = name;\r\n    this.subName = subName;\r\n    this.binding = binding;\r\n    this.filters = filters;\r\n    this.decorates = decorates;\r\n  }\r\n  \r\n  /**\r\n   * Method to assign value to DOM (unimplemented in base class, must override in subclasses).\r\n   * - Attribute binding: Set attribute value\r\n   * - Property binding: Set property value\r\n   * - Event binding: Register event listener\r\n   * - Structural control binding: Modify DOM structure\r\n   *\r\n   * @param value - Value to assign to DOM\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  assignValue(_value: unknown): void {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Binding assignValue not implemented',\r\n      context: { where: 'BindingNode.assignValue', name: this.name },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Method to batch update multiple elements (unimplemented in base class, override in structural control bindings).\r\n   * - BindingNodeFor: Batch update of loop items\r\n   * - Other bindings: Normally not used\r\n   *\r\n   * @param listIndexes - Array of list indices\r\n   * @param values - Array of values\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  updateElements(_listIndexes: IListIndex[], _values: unknown[]) {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Binding updateElements not implemented',\r\n      context: { where: 'BindingNode.updateElements', name: this.name },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Redraw notification method (empty implementation in base class, can override in subclasses).\r\n   * - Used to update related bindings after dynamic dependency resolution\r\n   * - Used in structural control bindings to notify child BindContent\r\n   *\r\n   * @param refs - Array of state references for redraw\r\n   */\r\n  notifyRedraw(_refs: IStatePropertyRef[]): void {\r\n    // Subclasses can implement notification considering parent-child relationships\r\n  }\r\n  \r\n  /**\r\n   * Change application method (Template Method pattern).\r\n   * - Retrieves filtered value from BindingState\r\n   * - Calls assignValue to reflect to DOM\r\n   * - Subclasses override assignValue to implement specific processing\r\n   *\r\n   * @param renderer - Renderer instance for state access\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState, renderer.readonlyHandler);\r\n    this.assignValue(filteredValue);\r\n  }\r\n  \r\n  /**\r\n   * Method to activate binding node (empty implementation in base class, can override in subclasses).\r\n   * - Execute initial rendering\r\n   * - Register event listeners (event binding)\r\n   * - Initialize child BindContent (structural control binding)\r\n   */\r\n  activate(): void {\r\n    // Subclasses can implement activation processing\r\n  }\r\n  \r\n  /**\r\n   * Method to inactivate binding node (empty implementation in base class, can override in subclasses).\r\n   * - Unregister event listeners (event binding)\r\n   * - Cleanup child BindContent (structural control binding)\r\n   */\r\n  inactivate(): void {\r\n    // Subclasses can implement inactivation processing\r\n  }\r\n\r\n  /**\r\n   * Getter to return current value (null in base class, override in subclasses).\r\n   * Used to get current DOM value in bidirectional binding.\r\n   * \r\n   * @returns Current value or null\r\n   */\r\n  get value(): unknown {\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n   * Getter to return filtered value (null in base class, override in subclasses).\r\n   * Used to get filtered DOM value in bidirectional binding.\r\n   * \r\n   * @returns Filtered value or null\r\n   */\r\n  get filteredValue(): unknown {\r\n    return null;\r\n  }\r\n\r\n}","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeAttribute class implements binding node for attribute bindings (e.g., attr.src, attr.alt).\r\n * Converts null/undefined/NaN to empty string to conform to HTML spec.\r\n */\r\nclass BindingNodeAttribute extends BindingNode {\r\n  /**\r\n   * Assigns attribute value to DOM element.\r\n   * Converts null/undefined/NaN to empty string.\r\n   * \r\n   * @param value - Value to assign to attribute\r\n   */\r\n  assignValue(value: unknown): void {\r\n    const element = this.node as Element;\r\n    const stringValue = \r\n      value === null || \r\n      value === undefined || \r\n      (typeof value === \"number\" && Number.isNaN(value))\r\n        ? \"\"\r\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string\r\n        : String(value);\r\n    \r\n    element.setAttribute(this.subName, stringValue);\r\n  }\r\n}\r\n\r\nconst subNameByName: Record<string, string> = {};\r\n\r\n/**\r\n * Factory function to generate attribute binding node.\r\n * \r\n * @param name - Binding name (e.g., \"attr.src\", \"attr.alt\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeAttribute with binding, node, and filters\r\n */\r\nexport const createBindingNodeAttribute: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      const subName = subNameByName[name] ?? (subNameByName[name] = name.split(\".\")[1]);\r\n      return new BindingNodeAttribute(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","export const DATA_BIND_ATTRIBUTE = \"data-bind\";\r\nexport const COMMENT_EMBED_MARK = \"@@:\"; // 埋め込み変数のマーク\r\nexport const COMMENT_TEMPLATE_MARK = \"@@|\"; // テンプレートのマーク\r\nexport const MAX_WILDCARD_DEPTH = 32; // ワイルドカードの最大深度\r\nexport const WILDCARD = \"*\"; // ワイルドカード\r\nexport const RESERVED_WORD_SET = new Set([\r\n  \"constructor\", \"prototype\", \"__proto__\", \"toString\",\r\n  \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\r\n  \"watch\", \"unwatch\", \"eval\", \"arguments\",\r\n  \"let\", \"var\", \"const\", \"class\", \"function\",\r\n  \"null\", \"true\", \"false\", \"new\", \"return\",\r\n]);\r\n\r\nexport const CONNECTED_CALLBACK_FUNC_NAME = \"$connectedCallback\";\r\nexport const DISCONNECTED_CALLBACK_FUNC_NAME = \"$disconnectedCallback\";\r\nexport const UPDATED_CALLBACK_FUNC_NAME = \"$updatedCallback\";","/**\r\n * getStructuredPathInfo.ts\r\n *\r\n * Utility for generating and caching detailed structured path information (IStructuredPathInfo)\r\n * from State property path strings.\r\n *\r\n * Main responsibilities:\r\n * - Splits path strings and analyzes segments, wildcard (*) positions, and parent-child relationships\r\n * - Structures information about path hierarchy and wildcard hierarchy (cumulativePaths/wildcardPaths/parentPath, etc.)\r\n * - Caches analysis results as IStructuredPathInfo for reusability and performance\r\n * - Ensures safety with reserved word checks\r\n *\r\n * Design points:\r\n * - Caches by path for fast retrieval on multiple accesses to the same path\r\n * - Strictly analyzes wildcards, parent-child relationships, and hierarchical structure, optimized for bindings and nested loops\r\n * - Raises exceptions via raiseError for reserved words or dangerous paths\r\n */\r\nimport { RESERVED_WORD_SET } from '../constants.js';\r\nimport { raiseError } from '../utils.js';\r\nimport { IStructuredPathInfo } from './types';\r\n\r\n/**\r\n * Cache for structured path information.\r\n * Uses plain object instead of Map since reserved words and object property names\r\n * are not expected to be used as path patterns in practice.\r\n */\r\nconst _cache: { [key:string]: IStructuredPathInfo } = {};\r\n\r\n/**\r\n * Class representing comprehensive structured information about a State property path.\r\n * Analyzes path hierarchy, wildcard positions, parent-child relationships, and provides\r\n * various access patterns for binding and dependency tracking.\r\n * \r\n * @class StructuredPathInfo\r\n * @implements {IStructuredPathInfo}\r\n */\r\nclass StructuredPathInfo implements IStructuredPathInfo {\r\n  static id : number = 0;\r\n  readonly id = ++StructuredPathInfo.id;\r\n  readonly sid = this.id.toString();\r\n  readonly pattern;\r\n  readonly pathSegments;\r\n  readonly lastSegment;\r\n  readonly cumulativePaths;\r\n  readonly cumulativePathSet;\r\n  readonly cumulativeInfos;\r\n  readonly cumulativeInfoSet;\r\n  readonly wildcardPaths;\r\n  readonly wildcardPathSet;\r\n  readonly wildcardInfos;\r\n  readonly indexByWildcardPath;\r\n  readonly wildcardInfoSet;\r\n  readonly wildcardParentPaths;\r\n  readonly wildcardParentPathSet;\r\n  readonly wildcardParentInfos;\r\n  readonly wildcardParentInfoSet;\r\n  readonly lastWildcardPath;\r\n  readonly lastWildcardInfo;\r\n  readonly parentPath;\r\n  readonly parentInfo;\r\n  readonly wildcardCount;\r\n\r\n  /**\r\n   * Constructs a StructuredPathInfo instance with comprehensive path analysis.\r\n   * Parses the pattern into segments, identifies wildcards, builds cumulative and wildcard paths,\r\n   * and establishes parent-child relationships for hierarchical navigation.\r\n   * \r\n   * @param {string} pattern - The property path pattern (e.g., \"items.*.name\" or \"user.profile\")\r\n   */\r\n  constructor(pattern: string) {\r\n    // Helper to get or create StructuredPathInfo instances, avoiding redundant creation for self-reference\r\n    const getPattern = (_pattern: string): IStructuredPathInfo => {\r\n      return (pattern === _pattern) ? this : getStructuredPathInfo(_pattern);\r\n    };\r\n    \r\n    // Split the pattern into individual path segments (e.g., \"items.*.name\" → [\"items\", \"*\", \"name\"])\r\n    const pathSegments = pattern.split(\".\");\r\n    \r\n    // Arrays to track all cumulative paths from root to each segment\r\n    const cumulativePaths = [];\r\n    const cumulativeInfos: IStructuredPathInfo[] = [];\r\n    \r\n    // Arrays to track wildcard-specific information\r\n    const wildcardPaths = [];\r\n    const indexByWildcardPath: Record<string, number> = {}; // Maps wildcard path to its index position\r\n    const wildcardInfos = [];\r\n    const wildcardParentPaths = []; // Paths of parent segments for each wildcard\r\n    const wildcardParentInfos = [];\r\n    \r\n    let currentPatternPath = \"\", prevPatternPath = \"\";\r\n    let wildcardCount = 0;\r\n    \r\n    // Iterate through each segment to build cumulative paths and identify wildcards\r\n    for(let i = 0; i < pathSegments.length; i++) {\r\n      currentPatternPath += pathSegments[i];\r\n      \r\n      // If this segment is a wildcard, track it with all wildcard-specific metadata\r\n      if (pathSegments[i] === \"*\") {\r\n        wildcardPaths.push(currentPatternPath);\r\n        indexByWildcardPath[currentPatternPath] = wildcardCount; // Store wildcard's ordinal position\r\n        wildcardInfos.push(getPattern(currentPatternPath));\r\n        wildcardParentPaths.push(prevPatternPath); // Parent path is the previous cumulative path\r\n        wildcardParentInfos.push(getPattern(prevPatternPath));\r\n        wildcardCount++;\r\n      }\r\n      \r\n      // Track all cumulative paths for hierarchical navigation (e.g., \"items\", \"items.*\", \"items.*.name\")\r\n      cumulativePaths.push(currentPatternPath);\r\n      cumulativeInfos.push(getPattern(currentPatternPath));\r\n      \r\n      // Save current path as previous for next iteration, then add separator\r\n      prevPatternPath = currentPatternPath;\r\n      currentPatternPath += \".\";\r\n    }\r\n    \r\n    // Determine the deepest (last) wildcard path and the parent path of the entire pattern\r\n    const lastWildcardPath = wildcardPaths.length > 0 ? wildcardPaths[wildcardPaths.length - 1] : null;\r\n    const parentPath = cumulativePaths.length > 1 ? cumulativePaths[cumulativePaths.length - 2] : null;\r\n    \r\n    // Assign all analyzed data to readonly properties\r\n    this.pattern = pattern;\r\n    this.pathSegments = pathSegments;\r\n    this.lastSegment = pathSegments[pathSegments.length - 1];\r\n    this.cumulativePaths = cumulativePaths;\r\n    this.cumulativePathSet = new Set(cumulativePaths); // Set for fast lookup\r\n    this.cumulativeInfos = cumulativeInfos;\r\n    this.cumulativeInfoSet = new Set(cumulativeInfos);\r\n    this.wildcardPaths = wildcardPaths;\r\n    this.wildcardPathSet = new Set(wildcardPaths);\r\n    this.indexByWildcardPath = indexByWildcardPath;\r\n    this.wildcardInfos = wildcardInfos;\r\n    this.wildcardInfoSet = new Set(wildcardInfos);\r\n    this.wildcardParentPaths = wildcardParentPaths;\r\n    this.wildcardParentPathSet = new Set(wildcardParentPaths);\r\n    this.wildcardParentInfos = wildcardParentInfos;\r\n    this.wildcardParentInfoSet = new Set(wildcardParentInfos);\r\n    this.lastWildcardPath = lastWildcardPath;\r\n    this.lastWildcardInfo = lastWildcardPath ? getPattern(lastWildcardPath) : null;\r\n    this.parentPath = parentPath;\r\n    this.parentInfo = parentPath ? getPattern(parentPath) : null;\r\n    this.wildcardCount = wildcardCount;\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves or creates a StructuredPathInfo instance for the given path pattern.\r\n * Uses caching to avoid redundant parsing of the same path patterns.\r\n * Validates that the path is not a reserved word before processing.\r\n * \r\n * @param {string} structuredPath - The property path pattern to analyze (e.g., \"items.*.name\")\r\n * @returns {IStructuredPathInfo} Comprehensive structured information about the path\r\n * @throws {Error} Throws STATE-202 error if the path is a reserved word\r\n * \r\n * @example\r\n * const info = getStructuredPathInfo(\"items.*.name\");\r\n * console.log(info.wildcardCount); // 1\r\n * console.log(info.cumulativePaths); // [\"items\", \"items.*\", \"items.*.name\"]\r\n */\r\nexport function getStructuredPathInfo(structuredPath: string): IStructuredPathInfo {\r\n  // Validate that the path is not a reserved word to prevent conflicts\r\n  if (RESERVED_WORD_SET.has(structuredPath)) {\r\n    raiseError({\r\n      code: 'STATE-202',\r\n      message: `Pattern is reserved word: ${structuredPath}`,\r\n      context: { where: 'StateProperty.getStructuredPathInfo', structuredPath },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n  \r\n  // Return cached result if available\r\n  const info = _cache[structuredPath];\r\n  if (typeof info !== \"undefined\") {\r\n    return info;\r\n  }\r\n  \r\n  // Create new StructuredPathInfo and cache it for future use\r\n  return (_cache[structuredPath] = new StructuredPathInfo(structuredPath));\r\n}\r\n","import { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IPathNode } from \"./types\";\r\n\r\n/**\r\n * NodePath class represents a node in the property path tree.\r\n * Manages hierarchical path structure with parent-child relationships.\r\n */\r\nclass NodePath implements IPathNode {\r\n  readonly parentPath: string;\r\n  readonly currentPath: string;\r\n  readonly name: string;\r\n  readonly childNodeByName: Map<string, IPathNode>;\r\n  readonly level: number;\r\n  \r\n  /**\r\n   * Creates a new NodePath instance.\r\n   * @param parentPath - Path of the parent node\r\n   * @param name - Name of this node\r\n   * @param level - Depth level in the tree (0 for root)\r\n   */\r\n  constructor(parentPath: string, name: string, level: number) {\r\n    this.parentPath = parentPath;\r\n    this.currentPath = parentPath ? `${parentPath  }.${  name}` : name;\r\n    this.name = name;\r\n    this.level = level;\r\n    this.childNodeByName = new Map<string, IPathNode>();\r\n  }\r\n\r\n  /**\r\n   * Finds a node by traversing path segments.\r\n   * @param segments - Array of path segments to traverse\r\n   * @param segIndex - Current segment index (default: 0)\r\n   * @returns Found node or null if not found\r\n   */\r\n  find(segments: string[], segIndex: number = 0): IPathNode | null {\r\n    if (segIndex >= segments.length) {\r\n      return null;\r\n    }\r\n\r\n    const currentSegment = segments[segIndex];\r\n    const childNode = this.childNodeByName.get(currentSegment);\r\n\r\n    if (childNode) {\r\n      if (segIndex === segments.length - 1) {\r\n        return childNode;\r\n      }\r\n      return childNode.find(segments, segIndex + 1);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Appends a child node with the given name.\r\n   * Creates new child if it doesn't exist, otherwise returns existing child.\r\n   * @param childName - Name of the child node to append\r\n   * @returns Child node (existing or newly created)\r\n   */\r\n  appendChild(childName: string): IPathNode {\r\n    let childNode = this.childNodeByName.get(childName);\r\n    if (!childNode) {\r\n      const currentPath = this.parentPath ? `${this.parentPath  }.${  this.name}` : this.name;\r\n      childNode = new NodePath(currentPath, childName, this.level + 1);\r\n      this.childNodeByName.set(childName, childNode);\r\n    }\r\n    return childNode;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create the root node of the path tree.\r\n * @returns Root node with empty path and name at level 0\r\n */\r\nexport function createRootNode(): IPathNode {\r\n  return new NodePath(\"\", \"\", 0);\r\n}\r\n\r\nconst cache = new Map<IPathNode, Map<IStructuredPathInfo, IPathNode | null>>();\r\n\r\nexport function findPathNodeByInfo(rootNode: IPathNode, info: IStructuredPathInfo): IPathNode | null {\r\n  let nodeCache = cache.get(rootNode);\r\n  if (!nodeCache) {\r\n    nodeCache = new Map<IStructuredPathInfo, IPathNode | null>();\r\n    cache.set(rootNode, nodeCache);\r\n  }\r\n  let cachedNode = nodeCache.get(info) ?? null;\r\n  if (cachedNode) {\r\n    return cachedNode;\r\n  }\r\n  cachedNode = rootNode.find(info.pathSegments);\r\n  nodeCache.set(info, cachedNode);\r\n  return cachedNode;\r\n}\r\n\r\n/**\r\n * Finds a path node by path string with caching.\r\n * @param rootNode - Root node to search from\r\n * @param path - Path string to find\r\n * @returns Found node or null if not found\r\n */\r\nexport function findPathNodeByPath(rootNode: IPathNode, path: string): IPathNode | null {\r\n  const info = getStructuredPathInfo(path);\r\n  return findPathNodeByInfo(rootNode, info);\r\n}\r\n\r\n/**\r\n * Adds a path node to the tree, creating parent nodes if necessary.\r\n * @param rootNode - Root node of the tree\r\n * @param path - Path string to add\r\n * @returns Created or existing node at the path\r\n */\r\nexport function addPathNode(rootNode: IPathNode, path: string): IPathNode {\r\n  const info = getStructuredPathInfo(path);\r\n  if (info.parentPath === null) {\r\n    return rootNode.appendChild(path);\r\n  } else {\r\n    let parentNode = findPathNodeByPath(rootNode, info.parentPath);\r\n    if (parentNode === null) {\r\n      parentNode = addPathNode(rootNode, info.parentPath);\r\n    }\r\n    return parentNode.appendChild(info.lastSegment);\r\n  }\r\n}\r\n","\r\nconst symbolName = \"state\";\r\n\r\nexport const GetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.GetByRef`);\r\nexport const SetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.SetByRef`);\r\nexport const SetCacheableSymbol        : unique symbol = Symbol.for(`${symbolName}.SetCacheable`);\r\nexport const ConnectedCallbackSymbol   : unique symbol = Symbol.for(`${symbolName}.ConnectedCallback`);\r\nexport const DisconnectedCallbackSymbol: unique symbol = Symbol.for(`${symbolName}.DisconnectedCallback`);\r\nexport const UpdatedCallbackSymbol     : unique symbol = Symbol.for(`${symbolName}.UpdatedCallback`);\r\nexport const GetListIndexesByRefSymbol : unique symbol = Symbol.for(`${symbolName}.GetListIndexesByRef`);\r\n","/**\r\n * getResolvedPathInfo.ts\r\n *\r\n * Utility for parsing and generating detailed path information (IResolvedPathInfo)\r\n * from State property names (path strings), including wildcard and index information.\r\n *\r\n * Main responsibilities:\r\n * - Breaks down property names to determine presence and type of wildcards and indexes\r\n * - Automatically determines wildcard type: context/all/partial/none\r\n * - Caches by path for reusability and performance\r\n * - Retrieves structured path information via getStructuredPathInfo\r\n *\r\n * Design points:\r\n * - Caches using Map to handle reserved words like \"constructor\" and \"toString\"\r\n * - Flexibly determines wildcards (*) and numeric indexes, storing them in wildcardIndexes\r\n * - context type indicates unresolved indexes, all type indicates all resolved indexes, partial type indicates mixed\r\n * - ResolvedPathInfo class centralizes path parsing and information management\r\n */\r\nimport { IResolvedPathInfo, WildcardType } from './types';\r\nimport { getStructuredPathInfo } from './getStructuredPathInfo.js';\r\n\r\n/**\r\n * Cache for resolved path information.\r\n * Uses Map to safely handle property names including reserved words like \"constructor\" and \"toString\".\r\n */\r\nconst _cache: Map<string, IResolvedPathInfo> = new Map();\r\n\r\n/**\r\n * Class that parses and stores resolved path information.\r\n * \r\n * Analyzes property path strings to extract:\r\n * - Path segments and their hierarchy\r\n * - Wildcard locations and types\r\n * - Numeric indexes vs unresolved wildcards\r\n * - Wildcard type classification (none/context/all/partial)\r\n */\r\nclass ResolvedPathInfo implements IResolvedPathInfo {\r\n  static id : number = 0;\r\n  readonly id = ++ResolvedPathInfo.id;\r\n  readonly name;\r\n  readonly elements;\r\n  readonly paths;\r\n  readonly wildcardCount;\r\n  readonly wildcardType;\r\n  readonly wildcardIndexes;\r\n  readonly info;\r\n  \r\n  /**\r\n   * Constructs resolved path information from a property path string.\r\n   * \r\n   * Parses the path to identify wildcards (*) and numeric indexes,\r\n   * classifies the wildcard type, and generates structured path information.\r\n   * \r\n   * @param name - Property path string (e.g., \"items.*.name\" or \"data.0.value\")\r\n   */\r\n  constructor(name: string) {\r\n    // Split path into individual segments\r\n    const elements = name.split(\".\");\r\n    const tmpPatternElements = elements.slice();\r\n    const paths = [];\r\n    let incompleteCount = 0; // Count of unresolved wildcards (*)\r\n    let completeCount = 0;   // Count of resolved wildcards (numeric indexes)\r\n    let lastPath = \"\";\r\n    let wildcardCount = 0;\r\n    let wildcardType: WildcardType = \"none\";\r\n    const wildcardIndexes: (number | null)[] = [];\r\n    \r\n    // Process each segment to identify wildcards and indexes\r\n    for(let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (element === \"*\") {\r\n        // Unresolved wildcard\r\n        tmpPatternElements[i] = \"*\";\r\n        wildcardIndexes.push(null);\r\n        incompleteCount++;\r\n        wildcardCount++;\r\n      } else {\r\n        const number = Number(element);\r\n        if (!Number.isNaN(number)) {\r\n          // Numeric index - treat as resolved wildcard\r\n          tmpPatternElements[i] = \"*\";\r\n          wildcardIndexes.push(number);\r\n          completeCount++;\r\n          wildcardCount++;\r\n        }\r\n      }\r\n      // Build cumulative path array\r\n      lastPath += element;\r\n      paths.push(lastPath);\r\n      lastPath += (i < elements.length - 1 ? \".\" : \"\");\r\n    }\r\n    // Generate pattern string with wildcards normalized\r\n    const pattern = tmpPatternElements.join(\".\");\r\n    const info = getStructuredPathInfo(pattern);\r\n    \r\n    // Classify wildcard type based on resolved vs unresolved counts\r\n    if (incompleteCount > 0 || completeCount > 0) {\r\n      if (incompleteCount === wildcardCount) {\r\n        // All wildcards are unresolved - need context to resolve\r\n        wildcardType = \"context\";\r\n      } else if (completeCount === wildcardCount) {\r\n        // All wildcards are resolved with numeric indexes\r\n        wildcardType = \"all\";\r\n      } else {\r\n        // Mix of resolved and unresolved wildcards\r\n        wildcardType = \"partial\";\r\n      }\r\n    }\r\n    this.name = name;\r\n    this.elements = elements;\r\n    this.paths = paths;\r\n    this.wildcardCount = wildcardCount;\r\n    this.wildcardType = wildcardType;\r\n    this.wildcardIndexes = wildcardIndexes;\r\n    this.info = info;\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves or creates resolved path information for a property path.\r\n * \r\n * This function caches resolved path information for performance.\r\n * On first access, it parses the path and creates a ResolvedPathInfo instance.\r\n * Subsequent accesses return the cached result.\r\n * \r\n * @param name - Property path string (e.g., \"items.*.name\", \"data.0.value\")\r\n * @returns Resolved path information containing segments, wildcards, and type classification\r\n */\r\nexport function getResolvedPathInfo(name:string):IResolvedPathInfo {\r\n  let nameInfo: IResolvedPathInfo | undefined;\r\n  // Return cached value or create, cache, and return new instance\r\n  return _cache.get(name) ?? (_cache.set(name, nameInfo = new ResolvedPathInfo(name)), nameInfo);\r\n}","/**\r\n * StatePropertyRef\r\n *\r\n * Purpose:\r\n * - Generates and caches unique reference objects (IStatePropertyRef) from State's structured path information\r\n *   (IStructuredPathInfo) and optional list indexes (IListIndex).\r\n * - Returns the same instance for identical (info, listIndex) combinations, enabling stable comparisons\r\n *   and use as Map keys.\r\n *\r\n * Implementation notes:\r\n * - The key is composed from info.sid and listIndex.sid (or just info.sid if listIndex is null)\r\n * - listIndex is held via WeakRef; throws LIST-201 error if GC'd when accessed\r\n * - Cache uses WeakMap(listIndex) for non-null listIndex, and Map(info) for null listIndex\r\n */\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IStatePropertyRef } from \"./types\";\r\n\r\n/**\r\n * Class representing a unique reference to a State property.\r\n * Combines structured path information with list index context for precise property identification.\r\n * Uses WeakRef for memory-efficient list index storage and supports parent reference traversal.\r\n * \r\n * @class StatePropertyRef\r\n * @implements {IStatePropertyRef}\r\n */\r\nclass StatePropertyRef implements IStatePropertyRef {\r\n  /** Structured information about the property path pattern */\r\n  readonly info: IStructuredPathInfo;\r\n  \r\n  /** Private WeakRef to the list index, allowing garbage collection when no longer referenced */\r\n  private _listIndexRef: WeakRef<IListIndex> | null;\r\n  \r\n  /**\r\n   * Gets the list index for this property reference.\r\n   * Throws an error if the list index has been garbage collected.\r\n   * \r\n   * @returns {IListIndex | null} The list index, or null if this reference has no list context\r\n   * @throws {Error} Throws LIST-201 error if the listIndex was GC'd\r\n   */\r\n  get listIndex(): IListIndex | null {\r\n    if (this._listIndexRef === null) {return null;}\r\n    // Attempt to dereference WeakRef; if GC'd, throw error\r\n    return this._listIndexRef.deref() ?? raiseError({\r\n      code: \"LIST-201\",\r\n      message: \"listIndex is null\",\r\n      context: {\r\n        where: 'StatePropertyRef.get listIndex',\r\n        sid: this.info.sid,\r\n        key: this.key,\r\n      },\r\n      docsUrl: \"./docs/error-codes.md#list\",\r\n    });\r\n  }\r\n  \r\n  /** \r\n   * Unique string key composed from info.sid and listIndex.sid.\r\n   * Used for caching and fast lookups.\r\n   */\r\n  readonly key: string;\r\n  \r\n  /**\r\n   * Constructs a StatePropertyRef instance.\r\n   * Creates a WeakRef for the listIndex to allow garbage collection.\r\n   * Generates a composite key for caching purposes.\r\n   * \r\n   * @param {IStructuredPathInfo} info - Structured path information\r\n   * @param {IListIndex | null} listIndex - Optional list index context\r\n   */\r\n  constructor(\r\n    info: IStructuredPathInfo,\r\n    listIndex: IListIndex | null,\r\n  ) {\r\n    this.info = info;\r\n    // Store listIndex as WeakRef to allow GC when no longer needed elsewhere\r\n    this._listIndexRef = listIndex !== null ? new WeakRef(listIndex) : null;\r\n    // Compose key from info.sid and optionally listIndex.sid\r\n    this.key = (listIndex === null) ? info.sid : (`${info.sid  }#${  listIndex.sid}`);\r\n  }\r\n\r\n  /**\r\n   * Gets the parent property reference (one level up in the path hierarchy).\r\n   * Handles list index adjustment when the parent has fewer wildcards.\r\n   * \r\n   * @returns {IStatePropertyRef | null} Parent reference, or null if this is a root property\r\n   */\r\n  get parentRef(): IStatePropertyRef | null {\r\n    const parentInfo = this.info.parentInfo;\r\n    if (!parentInfo) {return null;}\r\n    \r\n    // If current path has more wildcards than parent, use parent's list index (drop last level)\r\n    // Otherwise, use the same list index\r\n    const parentListIndex = (this.info.wildcardCount > parentInfo.wildcardCount \r\n      ? this.listIndex?.at(-2) \r\n      : this.listIndex) \r\n        ?? null;\r\n    return getStatePropertyRef(parentInfo, parentListIndex);\r\n  }\r\n}\r\n\r\n/**\r\n * Cache for StatePropertyRef instances with non-null list indexes.\r\n * Uses WeakMap keyed by IListIndex to allow garbage collection when list indexes are no longer referenced.\r\n * Each entry maps pattern strings to their corresponding StatePropertyRef instances.\r\n */\r\nconst refByInfoByListIndex: WeakMap<IListIndex, Record<string, IStatePropertyRef>> = new WeakMap();\r\n\r\n/**\r\n * Cache for StatePropertyRef instances with null list indexes.\r\n * Uses a plain object keyed by pattern string since there's no WeakMap key available.\r\n */\r\nconst refByInfoByNull: Record<string, IStatePropertyRef> = {};\r\n\r\n/**\r\n * Retrieves or creates a StatePropertyRef instance for the given path info and list index.\r\n * Implements caching to ensure identical (info, listIndex) pairs return the same instance,\r\n * enabling reference equality checks and stable Map keys.\r\n * \r\n * @param {IStructuredPathInfo} info - Structured path information\r\n * @param {IListIndex | null} listIndex - Optional list index context\r\n * @returns {IStatePropertyRef} Cached or newly created StatePropertyRef instance\r\n * \r\n * @example\r\n * const ref1 = getStatePropertyRef(pathInfo, listIndex);\r\n * const ref2 = getStatePropertyRef(pathInfo, listIndex);\r\n * console.log(ref1 === ref2); // true - same instance returned\r\n */\r\nexport function getStatePropertyRef(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n): IStatePropertyRef {\r\n  let ref = null;\r\n  \r\n  if (listIndex !== null) {\r\n    // Non-null listIndex: use WeakMap-based cache\r\n    let refByInfo;\r\n    if (typeof (refByInfo = refByInfoByListIndex.get(listIndex)) === \"undefined\") {\r\n      // First reference for this listIndex: create new ref and initialize cache entry\r\n      ref = new StatePropertyRef(info, listIndex);\r\n      refByInfoByListIndex.set(listIndex, { [info.pattern]: ref });\r\n    } else {\r\n      // Cache entry exists for this listIndex: check for matching pattern\r\n      if (typeof (ref = refByInfo[info.pattern]) === \"undefined\") {\r\n        // Pattern not found: create and cache new ref\r\n        return refByInfo[info.pattern] = new StatePropertyRef(info, listIndex);\r\n      }\r\n    }\r\n  } else {\r\n    // Null listIndex: use plain object cache\r\n    if (typeof (ref = refByInfoByNull[info.pattern]) === \"undefined\") {\r\n      // Pattern not found: create and cache new ref\r\n      return refByInfoByNull[info.pattern] = new StatePropertyRef(info, null);\r\n    }\r\n  }\r\n  \r\n  return ref;\r\n}\r\n","/**\r\n * getContextListIndex.ts\r\n *\r\n * Internal API function for StateClass that retrieves the list index (IListIndex)\r\n * corresponding to the specified structuredPath (wildcard property path) in the\r\n * current property reference scope.\r\n *\r\n * Main responsibilities:\r\n * - Retrieves list index for the specified path from the last accessed StatePropertyRef in handler\r\n * - Supports wildcard hierarchies, enabling use in multiple loops and nested array bindings\r\n *\r\n * Design points:\r\n * - Retrieves the most recent property reference information\r\n * - Identifies the index of structuredPath from info.wildcardPaths\r\n * - Gets list index for the corresponding level using listIndex.at(index)\r\n * - Returns null if path doesn't match or reference doesn't exist\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\n/**\r\n * Retrieves the list index for the specified structured path from the current property reference scope.\r\n * \r\n * This function accesses the most recently accessed StatePropertyRef in the handler and extracts\r\n * the list index corresponding to the given wildcard path. It supports nested loops and hierarchical\r\n * wildcard structures.\r\n * \r\n * @param handler - State handler containing the reference stack\r\n * @param structuredPath - Wildcard property path (e.g., \"items.*\", \"data.*.children.*\")\r\n * @returns List index for the specified path, or null if not found or reference is invalid\r\n */\r\nexport function getContextListIndex(\r\n  handler: IStateHandler,\r\n  structuredPath: string\r\n): IListIndex | null {\r\n  // Get the most recently accessed property reference from the stack\r\n  const ref = handler.lastRefStack;\r\n  if (ref === null) {\r\n    return null;\r\n  }\r\n  // Ensure the reference has list index information\r\n  if (ref.listIndex === null) {\r\n    return null;\r\n  }\r\n  // Look up the wildcard level index for the specified path\r\n  const index = ref.info.indexByWildcardPath[structuredPath];\r\n  if (typeof index !== \"undefined\") {\r\n    // Return the list index at the corresponding wildcard level\r\n    return ref.listIndex.at(index);\r\n  }\r\n  // Path not found in the current reference\r\n  return null;\r\n}\r\n","/**\r\n * getListIndex.ts\r\n *\r\n * Internal API function for StateClass that retrieves the list index (IListIndex)\r\n * corresponding to the given path information (IResolvedPathInfo).\r\n *\r\n * Main responsibilities:\r\n * - Resolves list index based on path's wildcard type (context/all/partial/none)\r\n * - context type retrieves list index from current loop context\r\n * - all type traverses list index collections at each hierarchy level to retrieve the index\r\n * - partial and none types are not implemented or return null\r\n *\r\n * Design points:\r\n * - Flexibly supports wildcards, multiple loops, and nested array bindings\r\n * - Retrieves list index collections for each hierarchy level via handler.engine.getListIndexesSet\r\n * - Throws detailed exceptions via raiseError on errors\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IResolvedPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { GetListIndexesByRefSymbol } from \"../symbols\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { getContextListIndex } from \"./getContextListIndex\";\r\n\r\n/**\r\n * Retrieves the list index for the given resolved path based on its wildcard type.\r\n * \r\n * This function handles different wildcard types:\r\n * - \"none\": Returns null (no wildcards)\r\n * - \"context\": Retrieves from current loop context\r\n * - \"all\": Traverses wildcard hierarchy to build complete list index\r\n * - \"partial\": Not yet supported, throws error\r\n * \r\n * @param resolvedPath - Resolved path information containing wildcard type and hierarchy\r\n * @param receiver - State proxy object\r\n * @param handler - State handler containing context and engine references\r\n * @returns List index for the path, or null if no wildcards exist\r\n * @throws {Error} STATE-202 - When required path components are missing\r\n * @throws {Error} LIST-201 - When list index cannot be found for a wildcard level\r\n */\r\nexport function getListIndex(\r\n  resolvedPath: IResolvedPathInfo, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): IListIndex | null {\r\n  switch (resolvedPath.wildcardType) {\r\n    case \"none\":\r\n      // No wildcards in path, no list index needed\r\n      return null;\r\n\r\n    case \"context\":{\r\n      // Get the last wildcard path from resolved path info\r\n      const lastWildcardPath = resolvedPath.info.lastWildcardPath ?? \r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'lastWildcardPath is null',\r\n          context: { where: 'StateClass.getListIndex', pattern: resolvedPath.info.pattern },\r\n          docsUrl: './docs/error-codes.md#state',\r\n        });\r\n      // Retrieve list index from current loop context\r\n      return getContextListIndex(handler, lastWildcardPath) ?? \r\n        raiseError({\r\n          code: 'LIST-201',\r\n          message: `ListIndex not found: ${resolvedPath.info.pattern}`,\r\n          context: { where: 'StateClass.getListIndex', pattern: resolvedPath.info.pattern },\r\n          docsUrl: './docs/error-codes.md#list',\r\n        });\r\n    }\r\n\r\n    case \"all\": {\r\n      // Traverse all wildcard levels to build complete list index hierarchy\r\n      let parentListIndex: IListIndex | null = null;\r\n      for(let i = 0; i < resolvedPath.info.wildcardCount; i++) {\r\n        // Get the parent info for this wildcard level\r\n        const wildcardParentPattern = resolvedPath.info.wildcardParentInfos[i] ?? \r\n          raiseError({\r\n            code: 'STATE-202',\r\n            message: 'wildcardParentPattern is null',\r\n            context: { where: 'StateClass.getListIndex', pattern: resolvedPath.info.pattern, index: i },\r\n            docsUrl: './docs/error-codes.md#state',\r\n          });\r\n        // Create a reference for the current wildcard level\r\n        const wildcardRef = getStatePropertyRef(wildcardParentPattern, parentListIndex);\r\n        // Get all list indexes at this wildcard level\r\n        const listIndexes: IListIndex[] = receiver[GetListIndexesByRefSymbol](wildcardRef) ?? \r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { where: 'StateClass.getListIndex', wildcardParent: wildcardParentPattern.pattern },\r\n            docsUrl: './docs/error-codes.md#list',\r\n          });\r\n        // Get the specific index for this wildcard level\r\n        const wildcardIndex = resolvedPath.wildcardIndexes[i] ?? \r\n          raiseError({\r\n            code: 'STATE-202',\r\n            message: 'wildcardIndex is null',\r\n            context: { where: 'StateClass.getListIndex', pattern: resolvedPath.info.pattern, index: i },\r\n            docsUrl: './docs/error-codes.md#state',\r\n          });\r\n        // Select the list index at the specified position for this level\r\n        parentListIndex = listIndexes[wildcardIndex] ?? \r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { where: 'StateClass.getListIndex', wildcardParent: wildcardParentPattern.pattern, wildcardIndex },\r\n            docsUrl: './docs/error-codes.md#list',\r\n          });\r\n      }\r\n      // Return the final list index after traversing all levels\r\n      return parentListIndex;\r\n    }\r\n\r\n    case \"partial\":\r\n      // Partial wildcard support is not yet implemented\r\n      raiseError({\r\n        code: 'STATE-202',\r\n        message: `Partial wildcard type is not supported yet: ${resolvedPath.info.pattern}`,\r\n        context: { where: 'StateClass.getListIndex', pattern: resolvedPath.info.pattern },\r\n        docsUrl: './docs/error-codes.md#state',\r\n      });\r\n  }\r\n}\r\n","/**\r\n * trackDependency.ts\r\n *\r\n * Implementation of trackDependency function for StateClass API to dynamically register\r\n * dependencies between paths referenced during getter chains.\r\n *\r\n * Main responsibilities:\r\n * - Retrieves currently resolving StatePropertyRef (lastRefStack)\r\n * - Tracks dependencies only for getters registered in pathManager.getters\r\n * - Calls addDynamicDependency for references with different patterns than itself\r\n *\r\n * Design points:\r\n * - Raises STATE-202 error if lastRefStack doesn't exist\r\n * - Does not register recursive getter dependencies (self-reference)\r\n * - Dynamic dependencies are aggregated in pathManager and used for cache invalidation\r\n */\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\ntype TrackDependencyFunction = (path: string) => void;\r\n\r\n/**\r\n * Returns a function to register dynamic dependency from currently resolving getter to specified path.\r\n *\r\n * - Only tracks dependencies for getters registered in pathManager.getters\r\n * - Excludes self-references, only recording dependencies between different patterns\r\n * - Dynamic dependencies are centrally managed via pathManager.addDynamicDependency\r\n *\r\n * @param target   - Proxy target object\r\n * @param prop     - Accessed property key\r\n * @param receiver - Proxy receiver\r\n * @param handler  - StateClass handler\r\n * @returns        Anonymous function that registers dependency to pattern specified by path argument\r\n */\r\nexport function trackDependency(\r\n  _target: object, \r\n  _prop: PropertyKey, \r\n  _receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): TrackDependencyFunction {\r\n  return (path: string): void => {\r\n    // Get the currently resolving getter's info from the stack\r\n    const lastInfo = handler.lastRefStack?.info ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'Internal error: lastRefStack is null',\r\n      context: { where: 'StateClass.trackDependency', path },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n    // Only register dependency if source is a getter and target is different\r\n    // This prevents self-references and only tracks getter -> property dependencies\r\n    if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n      lastInfo.pattern !== path) {\r\n      handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, path);\r\n    }\r\n  };\r\n}\r\n","import { MAX_WILDCARD_DEPTH } from \"../../constants\";\r\n\r\n/**\r\n * indexByIndexName\r\n * Mapping from index name to stack index\r\n * $1 => 0\r\n * $2 => 1\r\n * :\r\n * ${i + 1} => i\r\n * i < MAX_WILDCARD_DEPTH\r\n */\r\nexport const indexByIndexName: { [key: PropertyKey]: number } = {};\r\nfor (let i = 0; i < MAX_WILDCARD_DEPTH; i++) {\r\n  indexByIndexName[`$${i+1}`] = i;\r\n}\r\n","import { IListIndex } from \"./types\";\r\n\r\nlet version = 0;\r\nlet id = 0;\r\n\r\n/**\r\n * ListIndex class manages hierarchical index information for nested loops.\r\n * Tracks parent-child relationships and maintains version for change detection.\r\n */\r\nclass ListIndex implements IListIndex {\r\n  readonly id = ++id;\r\n  readonly sid = id.toString();\r\n  readonly parentListIndex: IListIndex | null;\r\n  readonly position: number;\r\n  readonly length: number;\r\n\r\n  private _index: number;\r\n  private _version: number;\r\n  private _indexes: number[] | undefined;\r\n  private _listIndexes: WeakRef<IListIndex>[] | undefined;\r\n\r\n  /**\r\n   * Creates a new ListIndex instance.\r\n   * \r\n   * @param parentListIndex - Parent list index for nested loops, or null for top-level\r\n   * @param index - Current index value in the loop\r\n   */\r\n  constructor(parentListIndex: IListIndex | null, index: number) {\r\n    this.parentListIndex = parentListIndex;\r\n    this.position = parentListIndex ? parentListIndex.position + 1 : 0;\r\n    this.length = this.position + 1;\r\n    this._index = index;\r\n    this._version = version;\r\n  }\r\n\r\n  /**\r\n   * Gets current index value.\r\n   * \r\n   * @returns Current index number\r\n   */\r\n  get index() {\r\n    return this._index;\r\n  }\r\n  \r\n  /**\r\n   * Sets index value and updates version.\r\n   * \r\n   * @param value - New index value\r\n   */\r\n  set index(value: number) {\r\n    this._index = value;\r\n    this._version = ++version;\r\n    this.indexes[this.position] = value;\r\n  }\r\n\r\n  /**\r\n   * Gets current version number for change detection.\r\n   * \r\n   * @returns Version number\r\n   */\r\n  get version(): number {\r\n    return this._version;\r\n  }\r\n\r\n  /**\r\n   * Checks if parent indexes have changed since last access.\r\n   * \r\n   * @returns true if parent has newer version, false otherwise\r\n   */\r\n  get dirty(): boolean {\r\n    if (this.parentListIndex === null) {\r\n      return false;\r\n    } else {\r\n      return this.parentListIndex.dirty || this.parentListIndex.version > this._version;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets array of all index values from root to current level.\r\n   * Rebuilds array if parent indexes have changed (dirty).\r\n   * \r\n   * @returns Array of index values\r\n   */\r\n  get indexes(): number[] {\r\n    if (this.parentListIndex === null) {\r\n      if (typeof this._indexes === \"undefined\") {\r\n        this._indexes = [this._index];\r\n      }\r\n    } else {\r\n      if (typeof this._indexes === \"undefined\" || this.dirty) {\r\n        this._indexes = [...this.parentListIndex.indexes, this._index];\r\n        this._version = version;\r\n      }\r\n    }\r\n    return this._indexes;\r\n  }\r\n\r\n  /**\r\n   * Gets array of WeakRef to all ListIndex instances from root to current level.\r\n   * \r\n   * @returns Array of WeakRef<IListIndex>\r\n   */\r\n  get listIndexes(): WeakRef<IListIndex>[] {\r\n    if (this.parentListIndex === null) {\r\n      if (typeof this._listIndexes === \"undefined\") {\r\n        this._listIndexes = [new WeakRef(this)];\r\n      }\r\n    } else {\r\n      if (typeof this._listIndexes === \"undefined\") {\r\n        this._listIndexes = [...this.parentListIndex.listIndexes, new WeakRef(this)];\r\n      }\r\n    }\r\n    return this._listIndexes;\r\n  }\r\n\r\n  /**\r\n   * Gets variable name for this loop index ($1, $2, etc.).\r\n   * \r\n   * @returns Variable name string\r\n   */\r\n  get varName(): string {\r\n    return `$${this.position + 1}`;\r\n  }\r\n\r\n  /**\r\n   * Gets ListIndex at specified position in hierarchy.\r\n   * Supports negative indexing from end.\r\n   * \r\n   * @param pos - Position index (0-based, negative for from end)\r\n   * @returns ListIndex at position or null if not found/garbage collected\r\n   */\r\n  at(pos: number): IListIndex | null {\r\n    if (pos >= 0) {\r\n      return this.listIndexes[pos]?.deref() || null;\r\n    } else {\r\n      return this.listIndexes[this.listIndexes.length + pos]?.deref() || null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create ListIndex instance.\r\n * \r\n * @param parentListIndex - Parent list index for nested loops, or null for top-level\r\n * @param index - Current index value in the loop\r\n * @returns New IListIndex instance\r\n */\r\nexport function createListIndex(parentListIndex: IListIndex | null, index: number): IListIndex {\r\n  return new ListIndex(parentListIndex, index);\r\n}\r\n","import { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\n/**\r\n * Checks and registers dynamic dependency between the currently resolving getter and the referenced property.\r\n * Only registers dependencies for getters that are not self-referencing.\r\n * @param handler - State handler containing reference stack and path manager\r\n * @param ref - State property reference being accessed\r\n */\r\nexport function checkDependency(\r\n  handler: IStateHandler,\r\n  ref: IStatePropertyRef,\r\n): void {\r\n  // Register dynamic dependency only if we're inside a getter resolution (refIndex >= 0)\r\n  if (handler.refIndex >= 0) {\r\n    const lastInfo = handler.lastRefStack?.info ?? null;\r\n    if (lastInfo !== null) {\r\n      // Only register if source is a getter and not accessing itself\r\n      if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern) &&\r\n        lastInfo.pattern !== ref.info.pattern) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, ref.info.pattern);\r\n      }\r\n    }\r\n  }\r\n}","import { createListIndex } from \"../../ListIndex/ListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\n\r\n/**\r\n * Checks if two lists are identical by comparing length and each element.\r\n * @param oldList - Previous list to compare\r\n * @param newList - New list to compare\r\n * @returns True if lists are identical, false otherwise\r\n */\r\nfunction isSameList(oldList: unknown[], newList: unknown[]): boolean {\r\n  if (oldList.length !== newList.length) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < oldList.length; i++) {\r\n    if (oldList[i] !== newList[i]) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Creates or updates list indexes by comparing old and new lists.\r\n * Optimizes by reusing existing list indexes when values match.\r\n * @param parentListIndex - Parent list index for nested lists, or null for top-level\r\n * @param oldList - Previous list (will be normalized to array)\r\n * @param newList - New list (will be normalized to array)\r\n * @param oldIndexes - Array of existing list indexes to potentially reuse\r\n * @returns Array of list indexes for the new list\r\n */\r\nexport function createListIndexes(\r\n  parentListIndex: IListIndex | null,\r\n  rawOldList: unknown,\r\n  rawNewList: unknown,\r\n  oldIndexes: IListIndex[]\r\n): IListIndex[] {\r\n  // Normalize inputs to arrays (handles null/undefined)\r\n  const oldList: unknown[] = Array.isArray(rawOldList) ? rawOldList : [];\r\n  const newList: unknown[] = Array.isArray(rawNewList) ? rawNewList : [];\r\n  const newIndexes: IListIndex[] = [];\r\n  // Early return for empty list\r\n  if (newList.length === 0) {\r\n    return [];\r\n  }\r\n  // If old list was empty, create all new indexes\r\n  if (oldList.length === 0) {\r\n    for(let i = 0; i < newList.length; i++) {\r\n      const newListIndex = createListIndex(parentListIndex, i);\r\n      newIndexes.push(newListIndex);\r\n    }\r\n    return newIndexes;\r\n  }\r\n  // If lists are identical, return existing indexes unchanged (optimization)\r\n  if (isSameList(oldList, newList)) {\r\n    return oldIndexes;\r\n  }\r\n  // Use index-based map for efficiency\r\n  const indexByValue = new Map<unknown, number>();\r\n  for(let i = 0; i < oldList.length; i++) {\r\n    // For duplicate values, the last index takes precedence (maintains existing behavior)\r\n    indexByValue.set(oldList[i], i);\r\n  }\r\n\r\n  // Build new indexes array by matching values with old list\r\n  for(let i = 0; i < newList.length; i++) {\r\n    const newValue = newList[i];\r\n    const oldIndex = indexByValue.get(newValue);\r\n    \r\n    if (typeof oldIndex === \"undefined\") {\r\n      // New element\r\n      const newListIndex = createListIndex(parentListIndex, i);\r\n      newIndexes.push(newListIndex);\r\n    } else {\r\n      // Reuse existing element\r\n      const existingListIndex = oldIndexes[oldIndex];\r\n      // Update index if position changed\r\n      if (existingListIndex.index !== i) {\r\n        existingListIndex.index = i;\r\n      }\r\n      newIndexes.push(existingListIndex);\r\n    }\r\n  }\r\n  return newIndexes;\r\n\r\n}","/**\r\n * getByRef.ts\r\n *\r\n * Implementation of getByRef function as internal API for StateClass to retrieve values from\r\n * state object (target) by specifying structured path info (IStructuredPathInfo) and list index (IListIndex).\r\n *\r\n * Main responsibilities:\r\n * - Retrieves State values for specified path/index (supports nested loops and wildcards)\r\n * - Automatic dependency registration (wrapped with setTracking when trackedGetters enabled)\r\n * - Cache mechanism (caches values by refKey when handler.cacheable)\r\n * - Sets scope temporarily with SetStatePropertyRefSymbol when retrieving via getter\r\n * - Recursively retrieves values by traversing parent info and listIndex if not found\r\n *\r\n * Design points:\r\n * - Enables dependency tracking with setTracking when included in handler.engine.trackedGetters\r\n * - Optimizes by caching values with refKey when cache enabled, retrieves and reuses them\r\n * - Flexibly supports wildcards and nested loops, achieving recursive value retrieval\r\n * - Guarantees cache storage in finally block\r\n */\r\nimport { ICacheEntry } from \"../../ComponentEngine/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\nimport { checkDependency } from \"./checkDependency\";\r\nimport { createListIndexes } from \"./createListIndexes\";\r\n\r\n/**\r\n * Retrieves value from state object (target) based on structured path info (info, listIndex).\r\n * \r\n * - Automatic dependency registration (wrapped with setTracking when trackedGetters enabled)\r\n * - Cache mechanism (caches by refKey when handler.cacheable)\r\n * - Supports nesting and wildcards (recursively retrieves values by traversing parent info and listIndex)\r\n * - Sets scope temporarily with SetStatePropertyRefSymbol when retrieving via getter\r\n * \r\n * @param target    - State object\r\n * @param ref       - State property reference\r\n * @param receiver  - Proxy\r\n * @param handler   - State handler\r\n * @returns         Value of the target property\r\n * @throws STC-001 If property does not exist in state when accessed directly\r\n * @throws STC-002 If handler.refStack is empty when accessing a getter\r\n */\r\nexport function getByRef(\r\n  target   : object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IStateProxy,\r\n  handler  : IStateHandler\r\n): unknown {\r\n  // Check and register dependency if called from within a getter\r\n  checkDependency(handler, ref);\r\n\r\n  let value: unknown;\r\n  // Determine if this path needs list management or caching\r\n  const listable = handler.engine.pathManager.lists.has(ref.info.pattern);\r\n  const cacheable = ref.info.wildcardCount > 0 || \r\n                    handler.engine.pathManager.getters.has(ref.info.pattern);\r\n  let lastCacheEntry = null;\r\n  if (cacheable || listable) {\r\n    // Try to retrieve cached value and validate its freshness\r\n    lastCacheEntry = handler.engine.getCacheEntry(ref);\r\n    const versionRevision = handler.engine.versionRevisionByPath.get(ref.info.pattern);\r\n    if (lastCacheEntry !== null) {\r\n      if (typeof versionRevision === \"undefined\") {\r\n        // No updates\r\n        return lastCacheEntry.value;\r\n      } else {\r\n        // Check version to determine if cache is still valid\r\n        if (lastCacheEntry.version > handler.updater.version) {\r\n          // This can occur when async updates happen\r\n          return lastCacheEntry.value;\r\n        }\r\n        // Compare versions and revisions to detect updates\r\n        if (lastCacheEntry.version < versionRevision.version || lastCacheEntry.revision < versionRevision.revision) {\r\n          // Updates detected\r\n        } else {\r\n          return lastCacheEntry.value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // If getters with parent-child relationships exist, retrieve from external dependencies\r\n  // ToDo: When getters exist in state (path prefix matches), retrieve via getter\r\n  if (handler.engine.stateOutput.startsWith(ref.info) && \r\n        handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n    return handler.engine.stateOutput.get(ref);\r\n  }\r\n\r\n  // If pattern exists in target, retrieve via getter\r\n  if (ref.info.pattern in target) {\r\n    // Validate ref stack before pushing\r\n    if (handler.refStack.length === 0) {\r\n      raiseError({\r\n        code: 'STC-002',\r\n        message: 'handler.refStack is empty in getByRef',\r\n        context: {\r\n          where: 'StateClass.getByRef',\r\n          pattern: ref.info.pattern,\r\n        },\r\n        docsUrl: './docs/error-codes.md#stc',\r\n      });\r\n    }\r\n    // Push current ref onto stack for dependency tracking during getter execution\r\n    handler.refIndex++;\r\n    if (handler.refIndex >= handler.refStack.length) {\r\n      handler.refStack.push(null);\r\n    }\r\n    handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n    try {\r\n      // Execute the getter\r\n      return value = Reflect.get(target, ref.info.pattern, receiver);\r\n    } finally {\r\n      // Always restore ref stack state, even if getter throws\r\n      handler.refStack[handler.refIndex] = null;\r\n      handler.refIndex--;\r\n      handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      // Store in cache\r\n      if (cacheable || listable) {\r\n        let newListIndexes = null;\r\n        if (listable) {\r\n          // Need to calculate list indexes\r\n          if (handler.renderer !== null) {\r\n            // Track last list info for diff calculation in renderer\r\n            if (!handler.renderer.lastListInfoByRef.has(ref)) {\r\n              if (lastCacheEntry) {\r\n                const listIndexes = lastCacheEntry.listIndexes ?? [];\r\n                const value = lastCacheEntry.value;\r\n                if (!Array.isArray(value)) {\r\n                  raiseError({\r\n                    code: \"STC-001\",\r\n                    message: `Property \"${ref.info.pattern}\" is expected to be an array for list management.`,\r\n                    context: {\r\n                      where: 'StateClass.getByRef',\r\n                      pattern: ref.info.pattern,\r\n                    },\r\n                    docsUrl: \"./docs/error-codes.md#stc\",\r\n                  });\r\n                }\r\n                handler.renderer.lastListInfoByRef.set(ref, { listIndexes, value });\r\n              } else {\r\n                handler.renderer.lastListInfoByRef.set(ref, { listIndexes: [], value: [] });\r\n              }\r\n            }\r\n          }\r\n          // Calculate new list indexes by comparing old and new values\r\n          newListIndexes = createListIndexes(\r\n            ref.listIndex, lastCacheEntry?.value, value, lastCacheEntry?.listIndexes ?? []\r\n          );\r\n        }\r\n        // Create or update cache entry with new value and metadata\r\n        const cacheEntry: ICacheEntry = lastCacheEntry ?? {\r\n          value: null,\r\n          listIndexes: null,\r\n          version: 0,\r\n          revision: 0,\r\n        };\r\n        cacheEntry.value = value;\r\n        cacheEntry.listIndexes = newListIndexes;\r\n        cacheEntry.version = handler.updater.version;\r\n        cacheEntry.revision = handler.updater.revision;\r\n        handler.engine.setCacheEntry(ref, cacheEntry);\r\n      }\r\n    }\r\n  } else {\r\n    // Error if not exists\r\n    raiseError({\r\n      code: \"STC-001\",\r\n      message: `Property \"${ref.info.pattern}\" does not exist in state.`,\r\n      context: {\r\n        where: 'StateClass.getByRef',\r\n        pattern: ref.info.pattern,\r\n      },\r\n      docsUrl: \"./docs/error-codes.md#stc\",\r\n    })\r\n  }\r\n}\r\n","/**\r\n * setByRef.ts\r\n *\r\n * Internal API function for StateClass that sets values to the state object (target)\r\n * by specifying structured path information (IStructuredPathInfo) and list index (IListIndex).\r\n *\r\n * Main responsibilities:\r\n * - Sets State values for specified path/index (supports multiple loops and wildcards)\r\n * - Temporarily sets scope with SetStatePropertyRefSymbol when setting via getter/setter\r\n * - Recursively sets values by traversing parent info and listIndex if not found\r\n * - Registers update information via engine.updater.addUpdatedStatePropertyRefValue after setting\r\n *\r\n * Design points:\r\n * - Flexibly supports wildcards and multiple loops, achieving recursive value setting\r\n * - Always registers update information in finally block for re-rendering and dependency resolution\r\n * - Design considers scope switching via getter/setter\r\n */\r\nimport { createListIndex } from \"../../ListIndex/ListIndex\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IListSnapshot } from \"../../Updater/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { GetByRefSymbol, GetListIndexesByRefSymbol } from \"../symbols\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\nimport { getByRef } from \"./getByRef\";\r\n\r\n/**\r\n * Sets a value to the state object for the specified property reference.\r\n * \r\n * This function handles value setting with support for wildcards, multiple loops, and nested structures.\r\n * It manages scope switching for getter/setter execution and tracks swap operations for element updates.\r\n * Update information is always registered in the finally block for re-rendering and dependency resolution.\r\n * \r\n * @param target - State object\r\n * @param ref - State property reference indicating where to set the value\r\n * @param value - Value to set\r\n * @param receiver - State proxy object\r\n * @param handler - State handler containing engine and updater references\r\n * @returns Result of the set operation\r\n * @throws {Error} STATE-202 - When required parent info or list index is missing\r\n */\r\nexport function setByRef(\r\n    target   : object, \r\n    ref      : IStatePropertyRef,\r\n    value    : unknown, \r\n    receiver : IStateProxy,\r\n    handler  : IStateHandler\r\n): unknown {\r\n  // Check if this path represents an element in a list\r\n  const isElements = handler.engine.pathManager.elements.has(ref.info.pattern);\r\n  let parentRef: IStatePropertyRef | null = null;\r\n  let swapInfo: IListSnapshot | null = null;\r\n  // Prepare swapInfo for elements to track value swapping in lists\r\n  if (isElements) {\r\n    parentRef = ref.parentRef ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'propRef.stateProp.parentInfo is undefined',\r\n      context: { where: 'StateClass.setByRef', scope: 'element', refPath: ref.info.pattern },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n    // Get or create swap info for tracking list element changes\r\n    swapInfo = handler.updater.swapInfoByRef.get(parentRef) || null;\r\n    if (swapInfo === null) {\r\n      const parentValue = receiver[GetByRefSymbol](parentRef) ?? [];\r\n      if (!Array.isArray(parentValue)) {\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'Expected array value for list elements',\r\n          context: { where: 'StateClass.setByRef', scope: 'element', refPath: parentRef.info.pattern },\r\n          docsUrl: './docs/error-codes.md#state',\r\n        });\r\n      }\r\n      swapInfo = {\r\n        value: [...parentValue as unknown[]],\r\n        listIndexes: [...(receiver[GetListIndexesByRefSymbol](parentRef) ?? [])]\r\n      }\r\n      handler.updater.swapInfoByRef.set(parentRef, swapInfo);\r\n    }\r\n  }\r\n  try {\r\n    // If getters with parent-child relationships exist, set value through external dependencies\r\n    // TODO: When getter exists in state (path prefix matches), retrieve via getter\r\n    if (handler.engine.stateOutput.startsWith(ref.info) && \r\n        handler.engine.pathManager.setters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n      return handler.engine.stateOutput.set(ref, value);\r\n    }\r\n    // If property exists directly in target, set via setter\r\n    if (ref.info.pattern in target) {\r\n      // Push current ref onto stack for scope tracking during setter execution\r\n      handler.refIndex++;\r\n      if (handler.refIndex >= handler.refStack.length) {\r\n        handler.refStack.push(null);\r\n      }\r\n      handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n      try {\r\n        // Execute the setter\r\n        return Reflect.set(target, ref.info.pattern, value, receiver);\r\n      } finally {\r\n        // Always restore ref stack state\r\n        handler.refStack[handler.refIndex] = null;\r\n        handler.refIndex--;\r\n        handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      }\r\n    } else {\r\n      // Property doesn't exist directly, need to traverse parent hierarchy\r\n      const parentInfo = ref.info.parentInfo ?? raiseError({\r\n        code: 'STATE-202',\r\n        message: 'propRef.stateProp.parentInfo is undefined',\r\n        context: { where: 'StateClass.setByRef', refPath: ref.info.pattern },\r\n        docsUrl: './docs/error-codes.md#state',\r\n      });\r\n      // Calculate parent list index based on wildcard hierarchy\r\n      const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount \r\n        ? (ref.listIndex?.parentListIndex ?? null) \r\n        : ref.listIndex;\r\n      const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n      // Get the parent value to set property on\r\n      const parentValue = getByRef(target, parentRef, receiver, handler);\r\n      if (parentValue === null || typeof parentValue !== \"object\") {\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'Parent value is not an object',\r\n          context: { where: 'StateClass.setByRef', refPath: parentRef.info.pattern },\r\n          docsUrl: './docs/error-codes.md#state',\r\n        });\r\n      }\r\n      const lastSegment = ref.info.lastSegment;\r\n      // Handle wildcard (array element) vs named property\r\n      if (lastSegment === \"*\") {\r\n        const index = ref.listIndex?.index ?? raiseError({\r\n          code: 'STATE-202',\r\n          message: 'propRef.listIndex?.index is undefined',\r\n          context: { where: 'StateClass.setByRef', refPath: ref.info.pattern },\r\n          docsUrl: './docs/error-codes.md#state',\r\n        });\r\n        return Reflect.set(parentValue, index, value);\r\n      } else {\r\n        return Reflect.set(parentValue, lastSegment, value);\r\n      }\r\n    }\r\n  } finally {\r\n    // Always register this ref for update processing\r\n    handler.updater.enqueueRef(ref);\r\n    if (isElements) {\r\n      // Handle list element swap tracking\r\n      const index = swapInfo!.value.indexOf(value);\r\n      const currentListIndexes = receiver[GetListIndexesByRefSymbol](parentRef!) ?? [];\r\n      const curIndex = ref.listIndex!.index; \r\n      // Assign list index from swap info or create new one\r\n      const listIndex = (index !== -1) ? swapInfo!.listIndexes[index] : createListIndex(parentRef!.listIndex, -1);\r\n      currentListIndexes[curIndex] = listIndex;\r\n      // Check for duplicates to determine if swap is complete\r\n      // If no duplicates, consider swap complete and update indexes\r\n      const parentValue = receiver[GetByRefSymbol](parentRef!) ?? [];\r\n      if (parentValue === null || !Array.isArray(parentValue)) {\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'Parent value is not an array during swap check',\r\n          context: { where: 'StateClass.setByRef', scope: 'element swap', refPath: parentRef!.info.pattern },\r\n          docsUrl: './docs/error-codes.md#state',\r\n        });\r\n      }\r\n      const listValueSet = new Set(parentValue);\r\n      if (listValueSet.size === swapInfo!.value.length) {\r\n        // Swap complete, renormalize indexes to match current positions\r\n        for(let i = 0; i < currentListIndexes.length; i++) {\r\n          currentListIndexes[i].index = i;\r\n        }\r\n        // Delete swapInfo as swap is complete\r\n        handler.updater.swapInfoByRef.delete(parentRef!);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * resolve.ts\r\n *\r\n * Implementation of resolve function for StateClass API to get/set State values\r\n * by specifying path and indexes.\r\n *\r\n * Main responsibilities:\r\n * - Gets or sets State values from string path and index array\r\n * - Supports paths with wildcards and nested loops\r\n * - Executes get (getByRef) when value not specified, set (setByRef) when specified\r\n *\r\n * Design points:\r\n * - Parses path with getStructuredPathInfo and resolves list indexes for each wildcard level\r\n * - Gets list index collection for each level via handler.engine.getListIndexesSet\r\n * - Centrally handles value get/set with getByRef/setByRef\r\n * - Enables flexible binding and API-based usage\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { GetListIndexesByRefSymbol, SetByRefSymbol } from \"../symbols.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\n\r\ntype ResolveFunction = (path: string, indexes: number[], value?: unknown) => unknown;\r\n\r\n/**\r\n * Creates a resolve function to get/set State values by path and indexes.\r\n * @param target - Target object to access\r\n * @param prop - Property key (unused but part of signature)\r\n * @param receiver - State proxy for context\r\n * @param handler - State handler with engine and dependency tracking\r\n * @returns Function that accepts path, indexes, and optional value\r\n * @throws STATE-202 If indexes length insufficient or setting on readonly proxy\r\n * @throws LIST-201 If list index not found at any wildcard level\r\n */\r\nexport function resolve(\r\n  target: object, \r\n  _prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): ResolveFunction {\r\n  return (path: string, indexes: number[], value?: unknown): unknown => {\r\n    const info = getStructuredPathInfo(path);\r\n    const lastInfo = handler.lastRefStack?.info ?? null;\r\n    if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n      // Register dependency if included in getters\r\n      if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern)) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n      }\r\n    }\r\n\r\n    // Validate that enough indexes are provided for all wildcard levels\r\n    if (info.wildcardParentInfos.length > indexes.length) {\r\n      raiseError({\r\n        code: 'STATE-202',\r\n        message: `indexes length is insufficient: ${path}`,\r\n        context: {\r\n          where: 'StateClass.resolve',\r\n          path,\r\n          expected: info.wildcardParentInfos.length,\r\n          received: indexes.length,\r\n        },\r\n        docsUrl: './docs/error-codes.md#state',\r\n      });\r\n    }\r\n    // Resolve ListIndex for each wildcard level by walking through the hierarchy\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i];\r\n      // Get reference for current wildcard level\r\n      const wildcardRef = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n      // Access the value to ensure list exists\r\n      getByRef(target, wildcardRef, receiver, handler);\r\n      // Get all list indexes at this level\r\n      const listIndexes = receiver[GetListIndexesByRefSymbol](wildcardRef);\r\n      if (listIndexes === null) {\r\n        raiseError({\r\n          code: 'LIST-201',\r\n          message: `ListIndexes not found: ${wildcardParentPattern.pattern}`,\r\n          context: {\r\n            where: 'StateClass.resolve',\r\n            pattern: wildcardParentPattern.pattern,\r\n          },\r\n          docsUrl: './docs/error-codes.md#list',\r\n        });\r\n      }\r\n      // Get the specific list index for this level using provided index\r\n      const index = indexes[i];\r\n      listIndex = listIndexes[index] ?? raiseError({\r\n        code: 'LIST-201',\r\n        message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n        context: {\r\n          where: 'StateClass.resolve',\r\n          pattern: wildcardParentPattern.pattern,\r\n          index,\r\n        },\r\n        docsUrl: './docs/error-codes.md#list',\r\n      });\r\n    }\r\n\r\n    // Create reference with resolved list index and perform get or set\r\n    // Determine if Writable or Readonly and call appropriate method\r\n    const ref = getStatePropertyRef(info, listIndex);\r\n    const hasSetValue = typeof value !== \"undefined\";\r\n    // Check if receiver supports setting (has SetByRefSymbol)\r\n    if (SetByRefSymbol in receiver) {\r\n      if (!hasSetValue) {\r\n        return getByRef(target, ref, receiver, handler);\r\n      } else {\r\n        setByRef(target, ref, value, receiver, handler);\r\n      }\r\n    } else {\r\n      if (!hasSetValue) {\r\n        return getByRef(target, ref, receiver, handler);\r\n      } else {\r\n        // Cannot set on readonly proxy\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: `Cannot set value on a readonly proxy: ${path}`,\r\n          context: {\r\n            where: 'StateClass.resolve',\r\n            path,\r\n          },\r\n          docsUrl: './docs/error-codes.md#state',\r\n        });\r\n      }\r\n    }\r\n  };\r\n} ","/**\r\n * connectedCallback.ts\r\n *\r\n * Utility function to invoke the StateClass lifecycle hook \"$connectedCallback\".\r\n *\r\n * Main responsibilities:\r\n * - Invokes $connectedCallback method if defined on the object (target)\r\n * - Callback is invoked with target's this context, passing IReadonlyStateProxy (receiver) as argument\r\n * - Executable as async function (await compatible)\r\n *\r\n * Design points:\r\n * - Safely retrieves $connectedCallback property using Reflect.get\r\n * - Does nothing if the callback doesn't exist\r\n * - Used for lifecycle management and custom initialization logic\r\n */\r\nimport { CONNECTED_CALLBACK_FUNC_NAME } from \"../../constants\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\n/**\r\n * Invokes the $connectedCallback lifecycle hook if defined on the target.\r\n * @param target - Target object to check for callback\r\n * @param prop - Property key (unused but part of signature)\r\n * @param receiver - State proxy to pass as this context\r\n * @param handler - State handler (unused but part of signature)\r\n * @returns Promise or void depending on callback implementation\r\n */\r\nexport function connectedCallback(\r\n  target: object, \r\n  _prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  _handler: IStateHandler\r\n): unknown {\r\n  const callback: unknown = Reflect.get(target, CONNECTED_CALLBACK_FUNC_NAME);\r\n  if (typeof callback === \"function\") {\r\n    return callback.call(receiver);\r\n  }\r\n}","/**\r\n * disconnectedCallback.ts\r\n *\r\n * Utility function to invoke the StateClass lifecycle hook \"$disconnectedCallback\".\r\n *\r\n * Main responsibilities:\r\n * - Invokes $disconnectedCallback method if defined on the object (target)\r\n * - Callback is invoked with target's this context, passing IReadonlyStateProxy (receiver) as argument\r\n * - Executable as async function (await compatible)\r\n *\r\n * Design points:\r\n * - Safely retrieves $disconnectedCallback property using Reflect.get\r\n * - Does nothing if the callback doesn't exist\r\n * - Used for lifecycle management and cleanup logic\r\n */\r\nimport { DISCONNECTED_CALLBACK_FUNC_NAME } from \"../../constants\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\n/**\r\n * Invokes the $disconnectedCallback lifecycle hook if defined on the target.\r\n * @param target - Target object to check for callback\r\n * @param prop - Property key (unused but part of signature)\r\n * @param receiver - State proxy to pass as this context\r\n * @param handler - State handler (unused but part of signature)\r\n */\r\nexport function disconnectedCallback(\r\n  target: object, \r\n  _prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  _handler: IStateHandler\r\n): unknown {\r\n  const callback: unknown = Reflect.get(target, DISCONNECTED_CALLBACK_FUNC_NAME);\r\n  if (typeof callback === \"function\") {\r\n    return callback.call(receiver);\r\n  }\r\n}","/**\r\n * getAll\r\n *\r\n * Retrieves all elements as an array from a State path containing wildcards.\r\n * Throws: LIST-201 (unresolved index), BIND-201 (wildcard information inconsistency)\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"./resolve.js\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\nimport { GetListIndexesByRefSymbol } from \"../symbols.js\";\r\n\r\ntype GetAllFunction = (path: string, indexes?: number[]) => unknown[];\r\n\r\n/**\r\n * Creates a function to retrieve all elements from a wildcard path.\r\n * @param target - Target object to retrieve from\r\n * @param prop - Property key (unused but part of signature)\r\n * @param receiver - State proxy for context\r\n * @param handler - State handler with engine and dependency tracking\r\n * @returns Function that accepts path and optional indexes, returns array of values\r\n * @throws LIST-201 If list index not found\r\n * @throws BIND-201 If wildcard information is inconsistent\r\n */\r\nexport function getAll(\r\n  target: object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): GetAllFunction {\r\n    const resolveFn = resolve(target, prop, receiver, handler);\r\n    return (path: string, _indexes?: number[]): unknown[] => {\r\n      let indexes = _indexes;\r\n      const info = getStructuredPathInfo(path);\r\n      const lastInfo = handler.lastRefStack?.info ?? null;\r\n      if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n        // Register dependency if included in getters\r\n        if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern)) {\r\n          handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n        }\r\n      }\r\n  \r\n      // If indexes not provided, try to extract from context\r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError({\r\n            code: 'BIND-201',\r\n            message: 'Wildcard info is missing',\r\n            context: {\r\n              where: 'StateClass.getAll',\r\n              wildcardIndex: i,\r\n              pattern: info.pattern,\r\n            },\r\n            docsUrl: './docs/error-codes.md#bind',\r\n          });\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      /**\r\n       * Recursively walks through wildcard patterns to collect all matching indexes.\r\n       * @param wildcardParentInfos - Array of wildcard parent path infos\r\n       * @param wildardIndexPos - Current position in wildcard hierarchy\r\n       * @param listIndex - Current list index or null\r\n       * @param indexes - Array of specified indexes (empty for all)\r\n       * @param indexPos - Current position in indexes array\r\n       * @param parentIndexes - Accumulated parent indexes\r\n       * @param results - Output array to collect all matching index combinations\r\n       */\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        // Base case: no more wildcards, add accumulated indexes to results\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        // Get the list at current wildcard level\r\n        const wildcardRef = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n        getByRef(target, wildcardRef, receiver, handler);\r\n        const listIndexes = receiver[GetListIndexesByRefSymbol](wildcardRef);\r\n        if (listIndexes === null) {\r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: {\r\n              where: 'StateClass.getAll',\r\n              pattern: wildcardParentPattern.pattern,\r\n            },\r\n            docsUrl: './docs/error-codes.md#list',\r\n          });\r\n        }\r\n        const index = indexes[indexPos] ?? null;\r\n        // If no specific index provided, iterate through all list items\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          // Specific index provided, use it\r\n          const listIndex = listIndexes[index] ?? raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: {\r\n              where: 'StateClass.getAll',\r\n              pattern: wildcardParentPattern.pattern,\r\n              index,\r\n            },\r\n            docsUrl: './docs/error-codes.md#list',\r\n          });\r\n          // Continue to next wildcard level if exists\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          } else {\r\n            // Reached the final wildcard layer, finalize the result\r\n            results.push(parentIndexes.concat(listIndex.index));\r\n          }\r\n        }\r\n      }\r\n      // Collect all matching index combinations\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      // Resolve values for each collected index combination\r\n      const resultValues: unknown[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolveFn(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * getListIndexesByRef.ts\r\n *\r\n * Internal API function for StateClass that retrieves the list indexes (IListIndex[])\r\n * for a given property reference.\r\n *\r\n * Main responsibilities:\r\n * - Validates that the reference points to a list path\r\n * - Retrieves list indexes from stateOutput if available (optimization)\r\n * - Updates cache by calling getByRef and retrieves list indexes from cache\r\n * - Throws detailed errors if list indexes cannot be found\r\n *\r\n * Design points:\r\n * - Checks stateOutput first for performance optimization\r\n * - Uses getByRef to ensure cache is up to date\r\n * - Validates cache entry existence and list indexes presence\r\n * - Provides detailed error context for debugging\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { getByRef } from \"./getByRef\";\r\n\r\n/**\r\n * Retrieves all list indexes for the specified property reference.\r\n * \r\n * This function ensures the reference points to a list path, then retrieves the list indexes\r\n * either from stateOutput (if available) or from the cache after updating it via getByRef.\r\n * \r\n * @param target - State object\r\n * @param ref - State property reference pointing to a list path\r\n * @param receiver - State proxy object\r\n * @param handler - State handler containing engine and cache references\r\n * @returns Array of list indexes for the specified list path\r\n * @throws {Error} LIST-201 - When the path is not registered as a list\r\n * @throws {Error} LIST-202 - When cache entry is not found after update\r\n * @throws {Error} LIST-203 - When list indexes are missing in the cache entry\r\n */\r\nexport function getListIndexesByRef(\r\n  target   : object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IStateProxy,\r\n  handler  : IStateHandler\r\n \r\n): IListIndex[] {\r\n  // Validate that the path is registered as a list\r\n  if (!handler.engine.pathManager.lists.has(ref.info.pattern)) {\r\n    raiseError({\r\n      code: 'LIST-201',\r\n      message: `path is not a list: ${ref.info.pattern}`,\r\n      context: { where: 'StateClass.getListIndexesByRef', pattern: ref.info.pattern },\r\n      docsUrl: './docs/error-codes.md#list',\r\n    });\r\n  }\r\n  // Try to retrieve from stateOutput first (optimization for external dependencies)\r\n  if (handler.engine.stateOutput.startsWith(ref.info) && \r\n        handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n    return handler.engine.stateOutput.getListIndexes(ref) ?? [];\r\n  }\r\n\r\n  // Update cache by calling getByRef, which also calculates list indexes\r\n  getByRef(target, ref, receiver, handler); // Also updates cache\r\n  const cacheEntry = handler.engine.getCacheEntry(ref);\r\n  // Validate that cache entry exists\r\n  if (cacheEntry === null) {\r\n    raiseError({\r\n      code: 'LIST-202',\r\n      message: `List cache entry not found: ${ref.info.pattern}`,\r\n      context: { where: 'StateClass.getListIndexesByRef', pattern: ref.info.pattern },\r\n      docsUrl: './docs/error-codes.md#list',\r\n    });\r\n  }\r\n\r\n  const listIndexes = cacheEntry.listIndexes;\r\n  // Validate that list indexes exist in cache entry\r\n  if (listIndexes === null) {\r\n    raiseError({\r\n      code: 'LIST-203',\r\n      message: `List indexes not found in cache entry: ${ref.info.pattern}`,\r\n      context: { where: 'StateClass.getListIndexesByRef', pattern: ref.info.pattern },\r\n      docsUrl: './docs/error-codes.md#list',\r\n    });\r\n  }\r\n\r\n  return listIndexes;\r\n}","/**\r\n * updatedCallback.ts\r\n *\r\n * Utility function to invoke the StateClass lifecycle hook \"$updatedCallback\".\r\n *\r\n * Main responsibilities:\r\n * - Invokes $updatedCallback method if defined on the object (target)\r\n * - Callback is invoked with target's this context, passing IReadonlyStateProxy (receiver) as argument\r\n * - Executable as async function (await compatible)\r\n *\r\n * Design points:\r\n * - Safely retrieves $updatedCallback property using Reflect.get\r\n * - Does nothing if the callback doesn't exist\r\n * - Used for lifecycle management and update handling logic\r\n */\r\nimport { UPDATED_CALLBACK_FUNC_NAME } from \"../../constants\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\n/**\r\n * Invokes the $updatedCallback lifecycle hook if defined on the target.\r\n * Aggregates updated paths and their indexes before passing to the callback.\r\n * @param target - Target object to check for callback\r\n * @param refs - Array of state property references that were updated\r\n * @param receiver - State proxy to pass as this context\r\n * @param handler - State handler (unused but part of signature)\r\n * @returns Promise or void depending on callback implementation\r\n */\r\nexport function updatedCallback(\r\n  target: object, \r\n  refs: IStatePropertyRef[], \r\n  receiver: IStateProxy,\r\n  _handler: IStateHandler,\r\n): unknown {\r\n  const callback: unknown = Reflect.get(target, UPDATED_CALLBACK_FUNC_NAME);\r\n  if (typeof callback === \"function\") {\r\n    const paths: Set<string> = new Set();\r\n    const indexesByPath: Record<string, number[]> = {};\r\n    for (const ref of refs) {\r\n      const path = ref.info.pattern;\r\n      paths.add(path);\r\n      if (ref.info.wildcardCount > 0) {\r\n        const index = ref.listIndex!.index;\r\n        const indexes = indexesByPath[path];\r\n        if (typeof indexes === \"undefined\") {\r\n          indexesByPath[path] = [index];\r\n        } else {\r\n          indexes.push(index);\r\n        }\r\n      }\r\n    }\r\n    return callback.call(receiver, Array.from(paths), indexesByPath);\r\n  }\r\n}","import { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\ntype InvokeFunction<T> = (callback: () => T) => T;\r\n\r\nexport function invoke<T>(\r\n  _target: object, \r\n  _prop: PropertyKey, \r\n  _receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): InvokeFunction<T> {\r\n  return (callback: () => T): T => {\r\n    if (typeof callback !== \"function\") {\r\n      raiseError({\r\n        code: 'STATE-203',\r\n        message: 'Callback is not a function',\r\n        context: {\r\n          where: 'StateClass.invoke',\r\n          callback,\r\n        },\r\n        docsUrl: './docs/error-codes.md#state',\r\n      });\r\n    }\r\n    const resultPromise = handler.updater.invoke<T>((): T => {\r\n      return Reflect.apply(callback, _receiver, []);\r\n    });\r\n    if (resultPromise instanceof Promise) {\r\n      resultPromise.catch((error: unknown) => {\r\n        const cause = error instanceof Error ? error : new Error(String(error));\r\n        raiseError({\r\n          code: 'STATE-204',\r\n          message: 'Invoke callback rejected',\r\n          context: { where: 'StateClass.invoke' },\r\n          docsUrl: './docs/error-codes.md#state',\r\n          severity: 'error',\r\n          cause,\r\n        });\r\n      });\r\n    }\r\n    return resultPromise;\r\n  } ;\r\n}\r\n","/**\r\n * get.ts\r\n *\r\n * Implementation of the get function as a Proxy trap for StateClass,\r\n * handling property access and value retrieval.\r\n *\r\n * Main responsibilities:\r\n * - For string properties, returns values or APIs based on special properties ($1-$9, $resolve, $getAll, $navigate)\r\n * - For regular properties, resolves path info via getResolvedPathInfo and retrieves list index via getListIndex\r\n * - Retrieves values corresponding to structured path and list index via getByRef\r\n * - For symbol properties, calls APIs via handler.callableApi\r\n * - For other cases, executes normal property access via Reflect.get\r\n *\r\n * Design points:\r\n * - $1-$9 are special properties that return list index values from the most recent StatePropertyRef\r\n * - $resolve, $getAll, $navigate return API functions or router instances\r\n * - Regular property access also supports bindings and nested loops\r\n * - Ensures extensibility and compatibility through symbol APIs and Reflect.get\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types.js\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, GetListIndexesByRefSymbol, SetByRefSymbol, UpdatedCallbackSymbol } from \"../symbols.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\nimport { indexByIndexName } from \"./indexByIndexName.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"../apis/resolve.js\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { connectedCallback } from \"../apis/connectedCallback.js\";\r\nimport { disconnectedCallback } from \"../apis/disconnectedCallback.js\";\r\nimport { getAll } from \"../apis/getAll.js\";\r\nimport { getListIndexesByRef } from \"../methods/getListIndexesByRef.js\";\r\nimport { updatedCallback } from \"../apis/updatedCallback.js\";\r\nimport { invoke } from \"../apis/invoke.js\";\r\n\r\n/**\r\n * Proxy trap handler for property access on State objects.\r\n * \r\n * This function intercepts property access and handles:\r\n * - Index name properties ($1-$9): Returns list index values from current context\r\n * - Special properties ($resolve, $getAll, $navigate, etc.): Returns API functions\r\n * - String properties: Resolves path and retrieves value via getByRef\r\n * - Symbol properties: Returns internal API functions for StateClass operations\r\n * - Other properties: Falls back to default Reflect.get behavior\r\n * \r\n * @param target - State object being accessed\r\n * @param prop - Property key being accessed (string, symbol, or other)\r\n * @param receiver - Proxy object that triggered this trap\r\n * @param handler - State handler containing context and configuration\r\n * @returns Value of the accessed property or an API function\r\n * @throws {Error} LIST-201 - When list index is not found for index name properties\r\n */\r\nexport function get(\r\n  target  : object, \r\n  prop    : PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler : IStateHandler\r\n): unknown {\r\n  // Check if property is an index name ($1-$9)\r\n  const index = indexByIndexName[prop];\r\n  if (typeof index !== \"undefined\") {\r\n    // Retrieve list index from the most recent property reference\r\n    const listIndex = handler.lastRefStack?.listIndex;\r\n    return listIndex?.indexes[index] ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: `ListIndex not found: ${prop.toString()}`,\r\n      context: { prop: String(prop), indexes: listIndex?.indexes ?? null, index },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n      severity: 'error',\r\n    });\r\n  }\r\n  // Handle string properties\r\n  if (typeof prop === \"string\") {\r\n    // Check for special properties starting with $\r\n    if (prop[0] === \"$\") {\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolve(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAll(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n        case \"$component\":\r\n          return handler.engine.owner;\r\n        case \"$invoke\":\r\n          return invoke(target, prop, receiver, handler);\r\n        case \"$wrap\":\r\n          return (callback: () => void) => { \r\n            const fn = invoke(target, prop, receiver, handler);\r\n            return () => fn(callback); \r\n          };\r\n        case \"$updateComplete\":\r\n          return handler.updater.updateComplete;\r\n      }\r\n    }\r\n    // Regular property access: resolve path, get list index, and retrieve value\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return getByRef(\r\n      target, \r\n      ref,\r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    // Handle symbol properties for internal APIs\r\n    if (handler.symbols.has(prop)) {\r\n      // Return API functions based on symbol type\r\n      switch (prop) {\r\n        case GetByRefSymbol: \r\n          return (ref: IStatePropertyRef) => \r\n            getByRef(target, ref, receiver, handler);\r\n        case SetByRefSymbol: \r\n          return (ref: IStatePropertyRef, value: unknown) => \r\n            setByRef(target, ref, value, receiver, handler);\r\n        case GetListIndexesByRefSymbol:\r\n          return (ref: IStatePropertyRef) =>\r\n            getListIndexesByRef(target, ref, receiver, handler);\r\n        case ConnectedCallbackSymbol:\r\n          return () => connectedCallback(target, prop, receiver, handler);\r\n        case DisconnectedCallbackSymbol: \r\n          return () => disconnectedCallback(target, prop, receiver, handler);\r\n        case UpdatedCallbackSymbol:\r\n          return (refs: IStatePropertyRef[]) =>\r\n            updatedCallback(target, refs, receiver, handler);\r\n      }\r\n    } else {\r\n      // Unknown symbol, use default behavior\r\n      return Reflect.get(\r\n        target, \r\n        prop, \r\n        receiver\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * createReadonlyStateProxy.ts\r\n *\r\n * Creates a \"read-only\" proxy for StateClass.\r\n *\r\n * Main responsibilities:\r\n * - Creates a read-only Proxy for State objects\r\n * - get trap supports bindings/API calls/dependency resolution/renderer integration\r\n * - set trap always throws an exception to prohibit writes\r\n * - has trap exposes internal API symbols (GetByRefSymbol, etc.)\r\n *\r\n * Throws:\r\n * - STATE-202 Cannot set property ... of readonly state (set trap)\r\n */\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateHandler, IState, IReadonlyStateProxy } from \"./types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IRenderer, IUpdater } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { GetByRefSymbol, GetListIndexesByRefSymbol } from \"./symbols\";\r\nimport { get as trapGet } from \"./traps/get.js\";\r\n\r\n// Initial depth of the reference stack for tracking property access hierarchy\r\nconst STACK_DEPTH = 32;\r\n\r\n/**\r\n * StateHandler class implementing read-only Proxy traps for State objects.\r\n * \r\n * This handler intercepts property access and prohibits property modifications,\r\n * ensuring the State object remains immutable from the perspective of the proxy user.\r\n */\r\nclass StateHandler implements IReadonlyStateHandler {\r\n  readonly engine: IComponentEngine;\r\n  readonly updater: IUpdater;\r\n  readonly renderer: IRenderer | null;\r\n  readonly refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null) as (IStatePropertyRef | null)[];\r\n  refIndex: number = -1;\r\n  lastRefStack: IStatePropertyRef | null = null;\r\n  loopContext: ILoopContext | null | undefined = undefined;\r\n  readonly symbols: Set<PropertyKey> = new Set<PropertyKey>([ GetByRefSymbol, GetListIndexesByRefSymbol ]);\r\n  readonly apis: Set<PropertyKey> = new Set<PropertyKey>([ \r\n    \"$resolve\", \"$getAll\", \"$trackDependency\", \"$navigate\", \"$component\" \r\n  ]);\r\n\r\n  /**\r\n   * Constructs a new StateHandler for read-only state proxy.\r\n   * \r\n   * @param engine - Component engine containing state management infrastructure\r\n   * @param updater - Updater for tracking state changes\r\n   * @param renderer - Optional renderer for UI updates, null if not rendering\r\n   */\r\n  constructor(engine: IComponentEngine, updater: IUpdater, renderer: IRenderer | null) {\r\n    this.engine = engine;\r\n    this.updater = updater;\r\n    this.renderer = renderer;\r\n  }\r\n\r\n  /**\r\n   * Proxy get trap for property access.\r\n   * \r\n   * Delegates to the shared get trap handler that supports bindings, API calls,\r\n   * and dependency tracking.\r\n   * \r\n   * @param target - State object being accessed\r\n   * @param prop - Property key being accessed\r\n   * @param receiver - Proxy object\r\n   * @returns Value of the accessed property\r\n   */\r\n  get(\r\n    target  : object, \r\n    prop    : PropertyKey, \r\n    receiver: IReadonlyStateProxy\r\n  ): unknown {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  /**\r\n   * Proxy set trap for property assignment.\r\n   * \r\n   * Always throws an error to prohibit modifications to the read-only state.\r\n   * \r\n   * @param target - State object being modified\r\n   * @param prop - Property key being set\r\n   * @param value - Value attempting to be assigned\r\n   * @param receiver - Proxy object\r\n   * @returns Never returns (always throws)\r\n   * @throws {Error} STATE-202 - Always thrown to prevent writes to readonly state\r\n   */\r\n  set(\r\n    _target  : object, \r\n    prop    : PropertyKey, \r\n    _value   : unknown, \r\n    _receiver: IReadonlyStateProxy\r\n  ): boolean {\r\n    raiseError({\r\n      code: 'STATE-202',\r\n      message: `Cannot set property ${String(prop)} of readonly state`,\r\n      context: { where: 'createReadonlyStateProxy.set', prop: String(prop) },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Proxy has trap for property existence checking.\r\n   * \r\n   * Returns true if the property exists in the target, or is a known symbol/API.\r\n   * \r\n   * @param target - State object being checked\r\n   * @param prop - Property key being checked for existence\r\n   * @returns true if property exists in target or is a known symbol/API\r\n   */\r\n  has(\r\n    target: object, \r\n    prop  : PropertyKey\r\n  ): boolean {\r\n    return Reflect.has(target, prop) || this.symbols.has(prop) || this.apis.has(prop);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a read-only state handler instance.\r\n * \r\n * @param engine - Component engine containing state management infrastructure\r\n * @param updater - Updater for tracking state changes\r\n * @param renderer - Optional renderer for UI updates, null if not rendering\r\n * @returns New readonly state handler instance\r\n */\r\nexport function createReadonlyStateHandler(\r\n  engine: IComponentEngine, \r\n  updater: IUpdater, \r\n  renderer: IRenderer | null\r\n): IReadonlyStateHandler {\r\n  return new StateHandler(engine, updater, renderer);\r\n}\r\n\r\n/**\r\n * Creates a read-only proxy for a State object.\r\n * \r\n * The returned proxy allows property reading but throws an error on unknown write attempt.\r\n * Supports special properties ($resolve, $getAll, etc.) and internal API symbols.\r\n * \r\n * @param state - State object to wrap in a read-only proxy\r\n * @param handler - Read-only state handler implementing proxy traps\r\n * @returns Read-only proxy wrapping the state object\r\n */\r\nexport function createReadonlyStateProxy(\r\n  state: IState,\r\n  handler: IReadonlyStateHandler,\r\n): IReadonlyStateProxy {\r\n  return new Proxy<IState>(state, handler) as IReadonlyStateProxy;\r\n}\r\n","/**\r\n * set.ts\r\n *\r\n * Implementation of the set function as a Proxy trap for StateClass,\r\n * handling property setting and value assignment.\r\n *\r\n * Main responsibilities:\r\n * - For string properties, resolves path info via getResolvedPathInfo and retrieves list index via getListIndex\r\n * - Executes value setting corresponding to structured path and list index via setByRef\r\n * - For other cases (symbols, etc.), executes normal property setting via Reflect.set\r\n *\r\n * Design points:\r\n * - Flexibly supports bindings, nested loops, and paths with wildcards\r\n * - By utilizing setByRef, side effects like dependency resolution and re-rendering are centrally managed\r\n * - Ensures compatibility with standard property setting via Reflect.set\r\n */\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { IStateProxy, IStateHandler } from \"../types\";\r\n\r\n/**\r\n * Proxy trap handler for property setting on State objects.\r\n * \r\n * This function intercepts property assignments and handles:\r\n * - String properties: Resolves path info, retrieves list index, and sets value via setByRef\r\n * - Other properties: Falls back to default Reflect.set behavior\r\n * \r\n * The setByRef call ensures proper handling of wildcards, nested loops, dependency tracking,\r\n * and triggers necessary re-rendering and update callbacks.\r\n * \r\n * @param target - State object being modified\r\n * @param prop - Property key being set (string, symbol, or other)\r\n * @param value - Value to assign to the property\r\n * @param receiver - Proxy object that triggered this trap\r\n * @param handler - State handler containing context and configuration\r\n * @returns true if the property was successfully set, false otherwise\r\n */\r\nexport function set(\r\n  target  : object, \r\n  prop    : PropertyKey, \r\n  value   : unknown, \r\n  receiver: IStateProxy,\r\n  handler : IStateHandler\r\n): boolean {\r\n  if (typeof prop === \"string\") {\r\n    // Resolve path information and list index for structured property access\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    // Set value via setByRef to handle dependencies and updates\r\n    setByRef(\r\n      target, \r\n      ref,\r\n      value, \r\n      receiver,\r\n      handler\r\n    );\r\n    return true;\r\n  } else {\r\n    // For non-string properties (symbols, etc.), use default behavior\r\n    return Reflect.set(\r\n      target, \r\n      prop, \r\n      value, \r\n      receiver\r\n    );\r\n  }\r\n}\r\n","/**\r\n * setLoopContext.ts\r\n *\r\n * Internal API function for StateClass that temporarily sets a loop context (ILoopContext)\r\n * and executes a specified async callback within that scope.\r\n *\r\n * Main responsibilities:\r\n * - Temporarily sets loop context in handler.loopContext\r\n * - Throws error if loop context is already set\r\n * - If loopContext exists, sets scope with asyncSetStatePropertyRef and executes callback\r\n * - If loopContext is null, executes callback directly\r\n * - Always resets loopContext to null in finally block to prevent scope leakage\r\n *\r\n * Design points:\r\n * - Safely manages scope during loop bindings and nested loops\r\n * - Guarantees state restoration in finally block, safe even when exceptions occur\r\n * - Supports async operations\r\n */\r\nimport { ILoopContext } from \"../../LoopContext/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IWritableStateHandler } from \"../types\";\r\n\r\n/**\r\n * Temporarily sets a loop context and executes a callback within that scope.\r\n * \r\n * This function manages loop context scope for loop bindings and nested loops, ensuring\r\n * proper context isolation. It handles both synchronous and asynchronous callbacks,\r\n * guaranteeing context cleanup even if exceptions occur.\r\n * \r\n * @param handler - Writable state handler containing loop context state\r\n * @param loopContext - Loop context to set, or null to execute without loop context\r\n * @param callback - Callback function to execute within the loop context scope\r\n * @returns Result of the callback execution\r\n * @throws {Error} STATE-301 - When loop context is already set (nested context not allowed)\r\n * @throws {Error} STC-002 - When ref stack is empty but loop context exists\r\n */\r\nexport function setLoopContext<R>(\r\n  handler: IWritableStateHandler,\r\n  loopContext: ILoopContext | null,\r\n  callback: () => R\r\n): R {\r\n  // Ensure no existing loop context (prevent nested contexts)\r\n  // handler.loopContext can be:\r\n  // - undefined: slot is empty (not occupied)\r\n  // - null: slot is occupied but no loop context\r\n  // - ILoopContext: slot is occupied with a loop context\r\n  // Occupied check: only \"undefined\" means the slot is not occupied\r\n  if (handler.loopContext !== undefined) {\r\n    raiseError({\r\n      code: 'STATE-301',\r\n      message: 'already in loop context',\r\n      context: { where: 'setLoopContext', handlerHasContext: true },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n      hint: 'Ensure handler.loopContext is cleared before invoking setLoopContext again.',\r\n      severity: 'error',\r\n    });\r\n  }\r\n  // Set the new loop context\r\n  let resultPromise: R | undefined; \r\n  if (loopContext) {\r\n    handler.loopContext = loopContext;\r\n    // ref stack always has 32 elements or more\r\n    // Push loop context ref onto stack for scope tracking\r\n    handler.refIndex++;\r\n    if (handler.refIndex >= handler.refStack.length) {\r\n      handler.refStack.push(null);\r\n    }\r\n    handler.refStack[handler.refIndex] = handler.lastRefStack = loopContext.ref;\r\n    try {\r\n      // Execute callback within loop context scope\r\n      resultPromise = callback();\r\n    } catch (error) {\r\n      // Cleanup on synchronous error\r\n      handler.refStack[handler.refIndex] = null;\r\n      handler.refIndex--;\r\n      handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      handler.loopContext = undefined;\r\n      throw error;\r\n    }\r\n    // Cleanup after async completion\r\n    if (resultPromise instanceof Promise) {\r\n      return resultPromise.finally(() => {\r\n        handler.refStack[handler.refIndex] = null;\r\n        handler.refIndex--;\r\n        handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n        handler.loopContext = undefined;\r\n      }) as R;\r\n    }\r\n    // Synchronous cleanup\r\n    handler.refStack[handler.refIndex] = null;\r\n    handler.refIndex--;\r\n    handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n    handler.loopContext = undefined;\r\n  } else {\r\n    handler.loopContext = loopContext;\r\n    // No loop context, execute callback directly\r\n    try {\r\n      resultPromise = callback();\r\n    } catch (error) {\r\n      // Cleanup on synchronous error\r\n      handler.loopContext = undefined;\r\n      throw error;\r\n    }\r\n    // Cleanup after async completion\r\n    if (resultPromise instanceof Promise) {\r\n      return resultPromise.finally(() => {\r\n        handler.loopContext = undefined;\r\n      }) as R;\r\n    }\r\n    // Synchronous cleanup\r\n    handler.loopContext = undefined;\r\n  }\r\n  return resultPromise;\r\n}\r\n","/**\r\n * createWritableStateProxy.ts\r\n *\r\n * Implementation file for creating \"writable\" proxies for StateClass.\r\n *\r\n * Main responsibilities:\r\n * - Creates a writable Proxy for State objects\r\n * - StateHandler class implements various APIs and traps (get/set)\r\n * - get trap supports bindings, API calls, dependency resolution, etc.\r\n * - set trap centrally manages value writes and side effects (dependency resolution, re-rendering)\r\n *\r\n * Design points:\r\n * - StateHandler implements IWritableStateHandler and serves as the foundation for state management and API calls\r\n * - Maps various API symbols and functions to callableApi for flexible API extension\r\n * - Enables consistent creation and usage via createWritableStateProxy\r\n * - Multi-functional design including dependency resolution, caching, loop/property reference scope management\r\n */\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IState, IWritableStateHandler, IWritableStateProxy } from \"./types\";\r\nimport { set as trapSet } from \"./traps/set.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { setLoopContext } from \"./methods/setLoopContext\";\r\nimport { IRenderer, IUpdater } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, GetListIndexesByRefSymbol, SetByRefSymbol, UpdatedCallbackSymbol } from \"./symbols\";\r\nimport { get as trapGet } from \"./traps/get.js\";\r\n\r\n// Initial depth of the reference stack for tracking property access hierarchy\r\nconst STACK_DEPTH = 32;\r\n\r\n/**\r\n * StateHandler class implementing writable Proxy traps for State objects.\r\n * \r\n * This handler intercepts property access and modifications, supporting full\r\n * read-write operations with dependency tracking, re-rendering, and update propagation.\r\n */\r\nclass StateHandler implements IWritableStateHandler {\r\n  readonly engine: IComponentEngine;\r\n  readonly updater: IUpdater;\r\n  readonly renderer: IRenderer | null = null;\r\n  readonly refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null) as (IStatePropertyRef | null)[];\r\n  refIndex: number = -1;\r\n  lastRefStack: IStatePropertyRef | null = null;\r\n  loopContext: ILoopContext | null | undefined = undefined;\r\n  readonly symbols: Set<PropertyKey> = new Set<PropertyKey>([ \r\n    GetByRefSymbol, SetByRefSymbol, GetListIndexesByRefSymbol, \r\n    ConnectedCallbackSymbol, DisconnectedCallbackSymbol,\r\n    UpdatedCallbackSymbol\r\n  ]);\r\n  readonly apis: Set<PropertyKey> = new Set<PropertyKey>([ \r\n    \"$resolve\", \"$getAll\", \"$trackDependency\", \"$navigate\", \"$component\", \"$invoke\", \"$wrap\", \"$updateComplete\" \r\n  ]);\r\n  \r\n  /**\r\n   * Constructs a new StateHandler for writable state proxy.\r\n   * \r\n   * @param engine - Component engine containing state management infrastructure\r\n   * @param updater - Updater for tracking and propagating state changes\r\n   */\r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this.engine = engine;\r\n    this.updater = updater;\r\n  }\r\n\r\n  /**\r\n   * Proxy get trap for property access.\r\n   * \r\n   * Delegates to the shared get trap handler that supports bindings, API calls,\r\n   * and dependency tracking.\r\n   * \r\n   * @param target - State object being accessed\r\n   * @param prop - Property key being accessed\r\n   * @param receiver - Proxy object\r\n   * @returns Value of the accessed property\r\n   */\r\n  get(\r\n    target  : object, \r\n    prop    : PropertyKey, \r\n    receiver: IWritableStateProxy\r\n  ): unknown {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  /**\r\n   * Proxy set trap for property assignment.\r\n   * \r\n   * Delegates to the shared set trap handler that handles value updates,\r\n   * dependency tracking, and triggers re-rendering.\r\n   * \r\n   * @param target - State object being modified\r\n   * @param prop - Property key being set\r\n   * @param value - Value to assign\r\n   * @param receiver - Proxy object\r\n   * @returns true if the property was successfully set\r\n   */\r\n  set(\r\n    target  : object, \r\n    prop    : PropertyKey, \r\n    value   : unknown, \r\n    receiver: IWritableStateProxy\r\n  ): boolean {\r\n    return trapSet(target, prop, value, receiver, this);\r\n  }\r\n\r\n  /**\r\n   * Proxy has trap for property existence checking.\r\n   * \r\n   * Returns true if the property exists in the target, or is a known symbol/API.\r\n   * \r\n   * @param target - State object being checked\r\n   * @param prop - Property key being checked for existence\r\n   * @returns true if property exists in target or is a known symbol/API\r\n   */\r\n  has(\r\n    target: object, \r\n    prop  : PropertyKey\r\n  ): boolean {\r\n    return Reflect.has(target, prop) || this.symbols.has(prop) || this.apis.has(prop);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a writable state proxy and executes a callback within a loop context scope.\r\n * \r\n * This function creates a temporary writable proxy for the state object, sets up a loop context\r\n * (if provided), and executes the callback with the proxy and handler. The loop context is\r\n * automatically cleaned up after callback execution, even if an exception occurs.\r\n * \r\n * Supports both synchronous and asynchronous callbacks.\r\n * \r\n * @param engine - Component engine containing state management infrastructure\r\n * @param updater - Updater for tracking and propagating state changes\r\n * @param state - State object to wrap in a writable proxy\r\n * @param loopContext - Optional loop context for nested loop bindings, null if not in a loop\r\n * @param callback - Function to execute with the writable state proxy\r\n * @returns Result of the callback execution\r\n */\r\nexport function useWritableStateProxy<R>(\r\n  engine: IComponentEngine, \r\n  updater: IUpdater,\r\n  state: IState,\r\n  loopContext: ILoopContext | null,\r\n  callback: (stateProxy: IWritableStateProxy, handler: IWritableStateHandler) => R\r\n): R {\r\n  // Create handler and proxy for writable state access\r\n  const handler = new StateHandler(engine, updater);\r\n  const stateProxy = new Proxy<IState>(state, handler) as IWritableStateProxy;\r\n  // Execute callback within loop context scope (automatically cleaned up)\r\n  return setLoopContext<R>(handler, loopContext, () => {\r\n    return callback(stateProxy, handler);\r\n  });\r\n}\r\n\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { WILDCARD } from \"../constants\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { findPathNodeByInfo } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createReadonlyStateHandler, createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy\";\r\nimport { GetListIndexesByRefSymbol } from \"../StateClass/symbols\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy } from \"../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\nimport { IListSnapshot, IRenderer, IRenderReport, IUpdater, ReadonlyStateCallback, RenderPhase } from \"./types\";\r\n\r\nconst EMPTY_LIST_INDEX_SET = new Set<IListIndex>();\r\n\r\n/**\r\n * Renderer is a coordinator that responds to State changes (a set of IStatePropertyRef references)\r\n * by traversing the PathTree and delegating applyChange to each Binding (IBinding).\r\n *\r\n * Main responsibilities\r\n * - reorderList: Collects element-level reordering requests and converts them to parent list-level diffs (IListDiff) for application\r\n * - render: Entry point. Creates ReadonlyState and executes in order: reorder → rendering each ref (renderItem)\r\n * - renderItem: Updates bindings tied to specified ref and recursively traverses static dependencies (child PathNodes) and dynamic dependencies\r\n *\r\n * Contract\r\n * - Binding#applyChange(renderer): If there are changes, must add itself to renderer.updatedBindings\r\n * - readonlyState[GetByRefSymbol](ref): Returns the new value (read-only view) of ref\r\n *\r\n * Thread/Reentrancy\r\n * - Assumes synchronous execution.\r\n *\r\n * Common exceptions\r\n * - UPD-001/002: Engine/ReadonlyState not initialized\r\n * - UPD-003/004/005/006: ListIndex/ParentInfo/OldList* inconsistency or ListDiff not generated\r\n * - PATH-101: PathNode not found\r\n */\r\nclass Renderer implements IRenderer {\r\n  readonly updatedBindings: Set<IBinding> = new Set();\r\n  readonly processedRefs: Set<IStatePropertyRef> = new Set();\r\n  readonly lastListInfoByRef: Map<IStatePropertyRef, IListSnapshot> = new Map();\r\n\r\n  private _engine: IComponentEngine;\r\n  private _updater: IUpdater;\r\n  private _updatingRefSet: Set<IStatePropertyRef> = new Set();\r\n  private _readonlyState: IReadonlyStateProxy | null = null;\r\n  private _readonlyHandler : IReadonlyStateHandler | null = null;\r\n  private _renderPhase: RenderPhase = 'build';\r\n  private _applyPhaseBinidings: IBinding[] = [];\r\n  private _applySelectPhaseBinidings: IBinding[] = [];\r\n\r\n  /**\r\n   * Constructs a new Renderer instance.\r\n   * \r\n   * @param {IComponentEngine} engine - The component engine to render\r\n   * @param {IUpdater} updater - The updater managing this renderer\r\n   */\r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this._engine = engine;\r\n    this._updater = updater;\r\n  }\r\n\r\n  get updatingRefSet(): Set<IStatePropertyRef> {\r\n    return this._updatingRefSet;\r\n  }\r\n\r\n  get applyPhaseBinidings(): IBinding[] {\r\n    return this._applyPhaseBinidings;\r\n  }\r\n\r\n  get applySelectPhaseBinidings(): IBinding[] {\r\n    return this._applySelectPhaseBinidings;\r\n  }\r\n  /**\r\n   * Gets the read-only State view. Throws exception if not during render execution.\r\n   * Throws: UPD-002\r\n   */\r\n  get readonlyState(): IReadonlyStateProxy {\r\n    if (!this._readonlyState) {\r\n      raiseError({\r\n        code: \"UPD-002\",\r\n        message: \"ReadonlyState not initialized\",\r\n        context: { where: \"Updater.Renderer.readonlyState\" },\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this._readonlyState;\r\n  }\r\n\r\n  get readonlyHandler(): IReadonlyStateHandler {\r\n    if (!this._readonlyHandler) {\r\n      raiseError({\r\n        code: \"UPD-002\",\r\n        message: \"ReadonlyHandler not initialized\",\r\n        context: { where: \"Updater.Renderer.readonlyHandler\" },\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this._readonlyHandler;\r\n  }\r\n\r\n  get renderPhase(): RenderPhase {\r\n    return this._renderPhase;\r\n  }\r\n\r\n  /**\r\n   * Creates a read-only state and passes it to the callback\r\n   * @param callback \r\n   * @returns \r\n   */\r\n  createReadonlyState<R>(callback: ReadonlyStateCallback<R>): R {\r\n    const handler = createReadonlyStateHandler(this._engine, this._updater, this);\r\n    const stateProxy = createReadonlyStateProxy(this._engine.state, handler);\r\n    this._readonlyState = stateProxy;\r\n    this._readonlyHandler = handler;\r\n    try {\r\n      return callback(stateProxy, handler);\r\n    } finally {\r\n      this._readonlyState = null;\r\n      this._readonlyHandler = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Entry point for rendering. Creates ReadonlyState and\r\n   * processes in order: reordering → rendering each reference.\r\n   *\r\n   * Notes\r\n   * - readonlyState is only valid within this method's scope.\r\n   * - SetCacheableSymbol enables caching of reference resolution in bulk.\r\n   */\r\n  private _render(items: IStatePropertyRef[]): void {\r\n    this.processedRefs.clear();\r\n    this.updatedBindings.clear();\r\n    this._updatingRefSet = new Set(items);\r\n\r\n    // Implement actual rendering logic\r\n    this.createReadonlyState( () => {\r\n      // First, process list reordering\r\n      const remainItems: IStatePropertyRef[] = [];\r\n      const remainPathSet: Set<string> = new Set();\r\n      const itemsByListRef = new Map<IStatePropertyRef, Set<IStatePropertyRef>>();\r\n      const refSet = new Set<IStatePropertyRef>();\r\n      \r\n      // Phase 1: Classify refs into list elements and other refs\r\n      for(let i = 0; i < items.length; i++) {\r\n        const ref = items[i];\r\n        refSet.add(ref);\r\n        \r\n        // Check if this ref represents a list element\r\n        if (!this._engine.pathManager.elements.has(ref.info.pattern)) {\r\n          // Not a list element - handle later\r\n          remainItems.push(ref);\r\n          remainPathSet.add(ref.info.pattern);\r\n          continue;\r\n        }\r\n        \r\n        // This is a list element - group by parent list ref\r\n        const listRef = ref.parentRef ?? raiseError({\r\n          code: \"UPD-004\",\r\n          message: `ParentInfo is null for ref: ${ref.key}`,\r\n          context: {\r\n            where: \"Updater.Renderer.render\",\r\n            refKey: ref.key,\r\n            pattern: ref.info.pattern,\r\n          },\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n        \r\n        // Group element refs by their parent list\r\n        if (!itemsByListRef.has(listRef)) {\r\n          itemsByListRef.set(listRef, new Set());\r\n        }\r\n        itemsByListRef.get(listRef)!.add(ref);\r\n      }\r\n      \r\n      // Phase 2: Apply changes to list bindings (for list reordering)\r\n      for(const [listRef, refs] of itemsByListRef) {\r\n        // If the parent list itself is in the update set, skip individual elements\r\n        // (parent list update will handle all children)\r\n        if (refSet.has(listRef)) {\r\n          for(const ref of refs) {\r\n            this.processedRefs.add(ref); // Completed\r\n          }\r\n          continue; // Skip if parent list exists\r\n        }\r\n        \r\n        // Apply list bindings (e.g., for reordering)\r\n        const bindings = this._engine.getBindings(listRef);\r\n        for(let i = 0; i < bindings.length; i++) {\r\n          if (this.updatedBindings.has(bindings[i])) {continue;}\r\n          bindings[i].applyChange(this);\r\n        }\r\n        this.processedRefs.add(listRef);\r\n      }\r\n\r\n      // Phase 3: Process remaining refs (non-list-elements)\r\n      if (remainPathSet.intersection(this._engine.pathManager.buildables).size === 0) {\r\n        this._renderPhase = 'direct';\r\n      }\r\n      for(let i = 0; i < remainItems.length; i++) {\r\n        const ref = remainItems[i];\r\n        \r\n        // Find the PathNode for this ref pattern\r\n        const node = findPathNodeByInfo(this._engine.pathManager.rootNode, ref.info);\r\n        if (node === null) {\r\n          raiseError({\r\n            code: \"PATH-101\",\r\n            message: `PathNode not found: ${ref.info.pattern}`,\r\n            context: { where: \"Updater.Renderer.render\", pattern: ref.info.pattern },\r\n            docsUrl: \"./docs/error-codes.md#path\",\r\n          });\r\n        }\r\n        if (!this.processedRefs.has(ref)) {\r\n          this.renderItem(ref, node);\r\n        }\r\n      }\r\n      \r\n      // Phase 4: Notify child Structive components of changes\r\n      // This allows nested components to update based on parent state changes\r\n      if (this._engine.structiveChildComponents.size > 0) {\r\n        for(const structiveComponent of this._engine.structiveChildComponents) {\r\n          const structiveComponentBindings = \r\n            this._engine.bindingsByComponent.get(structiveComponent) ?? new Set<IBinding>();\r\n          for(const binding of structiveComponentBindings) {\r\n            // Notify each binding about refs that might affect it\r\n            binding.notifyRedraw(remainItems);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this._renderPhase !== 'direct') {\r\n        this._applyPhaseRender();\r\n      }\r\n      this._applySelectPhaseRender();\r\n    });\r\n  }\r\n\r\n  private _applyPhaseRender(): void {\r\n    this._renderPhase = 'apply';\r\n    for(let i = 0; i < this._applyPhaseBinidings.length; i++) {\r\n      if (!this._applyPhaseBinidings[i].bindingNode.renderable) {continue;}\r\n      this._applyPhaseBinidings[i].applyChange(this);\r\n    }\r\n  }\r\n\r\n  private _applySelectPhaseRender(): void {\r\n    this._renderPhase = 'applySelect';\r\n    for(let i = 0; i < this._applySelectPhaseBinidings.length; i++) {\r\n      if (!this._applySelectPhaseBinidings[i].bindingNode.renderable) {continue;}\r\n      this._applySelectPhaseBinidings[i].applyChange(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param items - Array of state property references to render\r\n   */\r\n  render(items: IStatePropertyRef[]): void {\r\n    const enableReporting = config.debug && config.debugReports.includes(\"render\");\r\n    const start = enableReporting ? performance.now() : 0;\r\n    this._render(items);\r\n    if (enableReporting) {\r\n      const end = performance.now();\r\n      const report: IRenderReport = {\r\n        renderedRefs: Array.from(this._updatingRefSet),\r\n        renderedBindings: Array.from(this.updatedBindings),\r\n        renderType: \"update\",\r\n        version: this._updater.version,\r\n        revision: this._updater.revision,\r\n        duration: end - start,\r\n      }\r\n      console.warn(\"[DebugReport][Render]\", report);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Renders a single reference ref and its corresponding PathNode.\r\n   *\r\n   * - First applies its own bindings\r\n   * - Then static dependencies (including wildcards)\r\n   * - Finally dynamic dependencies (wildcards are expanded hierarchically)\r\n   *\r\n   * Static dependencies (child nodes)\r\n   * - Otherwise: Inherit parent's listIndex to generate child reference and render recursively\r\n   *\r\n   * Dynamic dependencies\r\n   * - Based on paths registered in pathManager.dynamicDependencies, render recursively while expanding wildcards\r\n   *\r\n  * Throws\r\n  * - PATH-101: PathNode not detected for dynamic dependency\r\n   */\r\n  renderItem(\r\n    ref: IStatePropertyRef,\r\n    node: IPathNode,\r\n  ): void {\r\n    this.processedRefs.add(ref);\r\n\r\n    // Apply changes to bindings\r\n    // Bindings with changes must add themselves to updatedBindings (responsibility of applyChange implementation)\r\n    const bindings = this._engine.getBindings(ref);\r\n    for(let i = 0; i < bindings.length; i++) {\r\n      if (this.updatedBindings.has(bindings[i])) {continue;}\r\n      bindings[i].applyChange(this);\r\n    }\r\n\r\n    // Calculate which list indexes are new (added) since last render\r\n    // This optimization ensures we only traverse new list elements\r\n    let diffListIndexes: Set<IListIndex> = EMPTY_LIST_INDEX_SET;\r\n    if (this._engine.pathManager.lists.has(ref.info.pattern)) {\r\n      // Get current list indexes for this ref\r\n      const currentListIndexes = new Set(this.readonlyState[GetListIndexesByRefSymbol](ref) ?? []);\r\n      \r\n      // Get previous list indexes from last render\r\n      const { listIndexes } = this.lastListInfoByRef.get(ref) ?? {};\r\n      const lastListIndexSet = new Set(listIndexes ?? []);\r\n      \r\n      // Compute difference: new indexes = current - previous\r\n      diffListIndexes = currentListIndexes.difference(lastListIndexSet);\r\n    }\r\n\r\n    // Traverse static dependencies\r\n    for(const [ name, childNode ] of node.childNodeByName) {\r\n      const childInfo = getStructuredPathInfo(childNode.currentPath);\r\n      \r\n      if (name === WILDCARD) {\r\n        // Wildcard child: traverse only new list indexes\r\n        for(const listIndex of diffListIndexes) {\r\n          const childRef = getStatePropertyRef(childInfo, listIndex);\r\n          if (!this.processedRefs.has(childRef)) {\r\n            this.renderItem(childRef, childNode);\r\n          }\r\n        }\r\n      } else {\r\n        // Regular property child: inherit parent's listIndex\r\n        const childRef = getStatePropertyRef(childInfo, ref.listIndex);\r\n        if (!this.processedRefs.has(childRef)) {\r\n          this.renderItem(childRef, childNode);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Traverse dynamic dependencies\r\n    const deps = this._engine.pathManager.dynamicDependencies.get(ref.info.pattern);\r\n    if (deps) {\r\n      for(const depPath of deps) {\r\n        const depInfo = getStructuredPathInfo(depPath);\r\n        const depNode = findPathNodeByInfo(this._engine.pathManager.rootNode, depInfo);\r\n        if (depNode === null) {\r\n          raiseError({\r\n            code: \"PATH-101\",\r\n            message: `PathNode not found: ${depInfo.pattern}`,\r\n            context: { where: \"Updater.Renderer.renderItem\", pattern: depInfo.pattern },\r\n            docsUrl: \"./docs/error-codes.md#path\",\r\n          });\r\n        }\r\n        \r\n        if (depInfo.wildcardCount > 0) {\r\n          // Dynamic dependency has wildcards - need hierarchical expansion\r\n          const infos = depInfo.wildcardParentInfos;\r\n          \r\n          // Recursive walker to expand wildcards level by level\r\n          const walk = (depRef: IStatePropertyRef, index: number, nextInfo: IStructuredPathInfo) => {\r\n            // Get list indexes at current wildcard level\r\n            const listIndexes = this.readonlyState[GetListIndexesByRefSymbol](depRef) || [];\r\n            \r\n            if ((index + 1) < infos.length) {\r\n              // More wildcard levels to traverse\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const nextRef = getStatePropertyRef(nextInfo, listIndexes[i]);\r\n                // Recurse to next wildcard level\r\n                walk(nextRef, index + 1, infos[index + 1]);\r\n              }\r\n            } else {\r\n              // Reached final wildcard level - render all elements\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const subDepRef = getStatePropertyRef(depInfo, listIndexes[i]);\r\n                if (!this.processedRefs.has(subDepRef)) {\r\n                  this.renderItem(subDepRef, depNode);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          \r\n          // Start traversal from first wildcard parent\r\n          const startRef = getStatePropertyRef(depInfo.wildcardParentInfos[0], null);\r\n          walk(startRef, 0, depInfo.wildcardParentInfos[1] || null);\r\n        } else {\r\n          // No wildcards - simple direct dependency\r\n          const depRef = getStatePropertyRef(depInfo, null);\r\n          if (!this.processedRefs.has(depRef)) {\r\n            this.renderItem(depRef, depNode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  initialRender(root: IBindContent): void {\r\n    const enableReporting = config.debug && config.debugReports.includes(\"render\");\r\n    const start = enableReporting ? performance.now() : 0;\r\n    this.createReadonlyState( () => {\r\n      root.applyChange(this);\r\n      this._applyPhaseRender();\r\n      this._applySelectPhaseRender();\r\n    });\r\n    if (enableReporting) {\r\n      const end = performance.now();\r\n      const report: IRenderReport = {\r\n        renderedRefs: Array.from(this._updatingRefSet),\r\n        renderedBindings: Array.from(this.updatedBindings),\r\n        renderType: \"initial\",\r\n        version: this._updater.version,\r\n        revision: this._updater.revision,\r\n        duration: end - start,\r\n      }\r\n      console.warn(\"[DebugReport][Render]\", report);\r\n    }\r\n\r\n  }\r\n}\r\n\r\n/**\r\n * Convenience function. Creates a Renderer instance and calls render in one go.\r\n */\r\nexport function render(\r\n  refs: IStatePropertyRef[], \r\n  engine: IComponentEngine, \r\n  updater: IUpdater,\r\n  resolver: PromiseWithResolvers<void>\r\n): void {\r\n  const renderer = new Renderer(engine, updater);\r\n  try {\r\n    renderer.render(refs);\r\n  } finally {\r\n    resolver.resolve();\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a new Renderer instance.\r\n * \r\n * @param {IComponentEngine} engine - The component engine to render\r\n * @param {IUpdater} updater - The updater managing this renderer\r\n * @returns {IRenderer} A new renderer instance\r\n */\r\nexport function createRenderer(\r\n  engine: IComponentEngine, \r\n  updater: IUpdater\r\n): IRenderer {\r\n  return new Renderer(engine, updater);\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { render } from \"./Renderer\";\r\nimport { IRenderMain, IUpdater } from \"./types\";\r\n\r\nclass RenderMain implements IRenderMain {\r\n  private _engine: IComponentEngine;\r\n  private _updater: IUpdater;\r\n  private _waitResolver: PromiseWithResolvers<PromiseWithResolvers<boolean> | void> = \r\n    Promise.withResolvers<PromiseWithResolvers<boolean> | void>();\r\n  private _completedResolvers: PromiseWithResolvers<boolean>;\r\n\r\n  constructor(\r\n    engine: IComponentEngine,\r\n    updater: IUpdater,\r\n    completedResolvers: PromiseWithResolvers<boolean>,\r\n  ) {\r\n    this._engine = engine;\r\n    this._updater = updater;\r\n    this._completedResolvers = completedResolvers;\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    this._main();\r\n  }\r\n\r\n  private async _main() {\r\n    const renderPromises: Promise<void>[] = [];\r\n    let termResolver: PromiseWithResolvers<boolean> | null = null;\r\n    let result: boolean = true;\r\n    while(termResolver === null) {\r\n      termResolver = await this._waitResolver.promise ?? null;\r\n      // Retrieve current queue and reset for new items\r\n      const queue = this._updater.retrieveAndClearQueue();\r\n      if (queue.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      // Execute rendering for all refs in this batch\r\n      const resolver = Promise.withResolvers<void>();\r\n      renderPromises.push(resolver.promise);\r\n      try {\r\n        // Render the queued refs\r\n        render(queue, this._engine, this._updater, resolver);\r\n      } catch (e) {\r\n        console.error(\"Rendering error:\", e);\r\n        resolver.reject();\r\n      }\r\n    }\r\n    try {\r\n      await Promise.all(renderPromises);\r\n    } catch(_e) {\r\n      result = false;\r\n    } finally {\r\n      termResolver.resolve(result);\r\n    }\r\n  }\r\n\r\n  wakeup() {\r\n    this._waitResolver.resolve();\r\n    this._waitResolver = Promise.withResolvers<PromiseWithResolvers<boolean> | void>();\r\n  }\r\n\r\n  terminate() {\r\n    this._waitResolver.resolve(this._completedResolvers);\r\n  }\r\n}\r\n\r\nexport function createRenderMain(\r\n  engine: IComponentEngine,\r\n  updater: IUpdater,\r\n  completedResolvers: PromiseWithResolvers<boolean>,\r\n): IRenderMain {\r\n  return new RenderMain(engine, updater, completedResolvers);\r\n}","import { raiseError } from \"../utils\";\r\nimport { IRenderMain, IUpdateActivityTracker } from \"./types\";\r\n\r\nclass UpdateActivityTracker implements IUpdateActivityTracker  {\r\n  private _version: number = 0;\r\n  private _processResolvers: PromiseWithResolvers<void>[] = [];\r\n  private _observedResolvers: PromiseWithResolvers<void>[] = [];\r\n  private _waitResolver: PromiseWithResolvers<void> | null = null;\r\n  private _mainResolver: PromiseWithResolvers<void> | null = null;\r\n  private _renderMain: IRenderMain;\r\n  constructor(renderMain: IRenderMain) {\r\n    this._renderMain = renderMain;\r\n  }\r\n\r\n  createProcessResolver(): PromiseWithResolvers<void> {\r\n    const resolver = Promise.withResolvers<void>();\r\n    this._processResolvers.push(resolver);\r\n    if (this._waitResolver === null) {\r\n      if (this._mainResolver === null) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._main();\r\n      } else {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._mainResolver.promise.then(() => {\r\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n          this._main();\r\n        });\r\n      }\r\n    } else {\r\n      this._waitResolver.reject();\r\n    }\r\n    return resolver;\r\n  }\r\n\r\n  private _getVersionUp(): number {\r\n    this._version++;\r\n    return this._version;\r\n  }\r\n\r\n  private _nextWaitPromise(): Promise<void> {\r\n    const version = this._getVersionUp();\r\n    this._waitResolver = Promise.withResolvers<void>();\r\n    this._observedResolvers = this._observedResolvers.concat(...this._processResolvers);\r\n    this._processResolvers = [];\r\n    const observedResolvers = [...this._observedResolvers];\r\n    const observedPromises = this._observedResolvers.map(c => c.promise);\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    Promise.allSettled(observedPromises).then(() => {\r\n      if (this._version !== version) {\r\n        this._observedResolvers = this._observedResolvers.filter(r => !observedResolvers.includes(r));\r\n        return;\r\n      }\r\n      if (this._waitResolver === null) {\r\n        raiseError({\r\n          code: 'UPD-007',\r\n          message: 'UpdateActivityTracker waitResolver is null.',\r\n          context: { where: 'UpdateActivityTracker.nextWaitPromise' },\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n      }\r\n      this._observedResolvers = [];\r\n      this._waitResolver.resolve();\r\n    });\r\n    return this._waitResolver.promise;\r\n  }\r\n\r\n  private async _main() {\r\n    if (this._mainResolver !== null) {\r\n      return;\r\n    }\r\n    this._mainResolver = Promise.withResolvers<void>();\r\n    try {\r\n      while(true) {\r\n        const waitPromise = this._nextWaitPromise();\r\n        try {\r\n          await waitPromise;\r\n          this._waitResolver = null;\r\n          if (this._processResolvers.length === 0 && this._observedResolvers.length === 0) {\r\n            this._renderMain.terminate();\r\n            break;\r\n          }\r\n        } catch(_e) {\r\n          continue;\r\n        }\r\n      }\r\n    } finally {\r\n      // 終了処理\r\n      if (this._mainResolver !== null) {\r\n        this._mainResolver.resolve();\r\n      }\r\n      this._mainResolver = null;\r\n    }\r\n  }\r\n\r\n  get isProcessing(): boolean {\r\n    return this._mainResolver !== null;\r\n  }\r\n}\r\n\r\nexport function createUpdateActivityTracker(renderMain: IRenderMain): IUpdateActivityTracker {\r\n  return new UpdateActivityTracker(renderMain);\r\n}\r\n\r\n// Export for testing purposes only\r\nexport { UpdateActivityTracker as _UpdateActivityTracker };\r\n","import { IComponentEngine, IVersionRevision } from \"../ComponentEngine/types\";\r\nimport { IBindContent } from \"../DataBinding/types\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { findPathNodeByPath } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createReadonlyStateHandler, createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy\";\r\nimport { UpdatedCallbackSymbol } from \"../StateClass/symbols\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { useWritableStateProxy } from \"../StateClass/useWritableStateProxy\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\nimport { createRenderer } from \"./Renderer\";\r\nimport { createRenderMain } from \"./RenderMain\";\r\nimport { IListSnapshot, IRenderMain, IUpdater, IUpdateActivityTracker, UpdateCallback, UpdateComplete, IUpdateReport } from \"./types\";\r\nimport { createUpdateActivityTracker } from \"./UpdateActivityTracker\";\r\n\r\n\r\n/**\r\n * The Updater class plays a central role in state management and updates.\r\n * Instances are created on-demand when state updates are needed.\r\n * \r\n * Main features:\r\n * - Queues state property references that need updating\r\n * - Schedules and executes rendering cycles via microtasks\r\n * - Manages version/revision tracking for cache invalidation\r\n * - Collects dependent paths affected by state changes\r\n * - Provides read-only and writable state contexts\r\n * \r\n * @class Updater\r\n * @implements {IUpdater}\r\n */\r\nclass Updater implements IUpdater {\r\n  /** Map storing swap/reorder information for list elements */\r\n  readonly swapInfoByRef: Map<IStatePropertyRef, IListSnapshot> = new Map();\r\n\r\n  /** Queue of state property references waiting to be rendered */\r\n  private _queue: IStatePropertyRef[] = [];\r\n  \r\n  /** Flag indicating if rendering is currently in progress */\r\n  private _rendering: boolean = false;\r\n  \r\n  /** Reference to the component engine being updated */\r\n  private _engine: IComponentEngine;\r\n  \r\n  /** Current version number for this update cycle */\r\n  private _version: number;\r\n  \r\n  /** Current revision number within the version */\r\n  private _revision: number = 0;\r\n  \r\n  /** Queue of refs saved for deferred updated callbacks */\r\n  private _saveQueue: IStatePropertyRef[] = [];\r\n  \r\n  /** Cache mapping paths to their dependent paths for optimization */\r\n  private _cacheUpdatedPathsByPath: Map<string, Set<string>> = new Map();\r\n\r\n  private _completedResolvers: PromiseWithResolvers<boolean> = Promise.withResolvers<boolean>();\r\n\r\n  private _renderMain: IRenderMain;\r\n\r\n  private _isAlive: boolean = true;\r\n\r\n  private _tracker: IUpdateActivityTracker;\r\n  /**\r\n   * Constructs a new Updater instance.\r\n   * Automatically increments the engine's version number.\r\n   * \r\n   * @param {IComponentEngine} engine - The component engine to manage updates for\r\n   */\r\n  constructor(engine: IComponentEngine) {\r\n    this._engine = engine;\r\n    this._version = engine.versionUp();\r\n    this._renderMain = createRenderMain(engine, this, this._completedResolvers);\r\n    this._tracker = createUpdateActivityTracker(this._renderMain);\r\n    engine.updateCompleteQueue.enqueue(this._completedResolvers.promise);\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    this._completedResolvers.promise.finally(() => {\r\n      this._isAlive = false;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the current version number.\r\n   * Version is incremented each time a new Updater is created.\r\n   * \r\n   * @returns {number} Current version number\r\n   */\r\n  get version(): number {\r\n    return this._version;\r\n  }\r\n\r\n  /**\r\n   * Gets the current revision number.\r\n   * Revision is incremented with each enqueueRef call within the same version.\r\n   * \r\n   * @returns {number} Current revision number\r\n   */\r\n  get revision(): number {\r\n    return this._revision;\r\n  }\r\n\r\n  /**\r\n   * Gets a promise that resolves when all updates are complete.\r\n   * The promise resolves to true if all updates succeeded, false if any failed.\r\n   * \r\n   * @returns {UpdateComplete} Promise resolving when updates are complete\r\n   */\r\n  get updateComplete(): UpdateComplete {\r\n    return this._completedResolvers.promise;\r\n  }\r\n\r\n  private _rebuild() {\r\n    if (this._isAlive) {\r\n      raiseError({\r\n        code: 'UPD-006',\r\n        message: 'Updater has already been used. Create a new Updater instance for rebuild.',\r\n        context: { where: 'Updater._rebuild' },\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    this._isAlive = true;\r\n    this._completedResolvers = Promise.withResolvers<boolean>();\r\n    this._version = this._engine.versionUp();\r\n    this._renderMain = createRenderMain(this._engine, this, this._completedResolvers);\r\n    this._tracker = createUpdateActivityTracker(this._renderMain);\r\n    this._engine.updateCompleteQueue.enqueue(this._completedResolvers.promise);\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    this._completedResolvers.promise.finally(() => {\r\n      this._isAlive = false;\r\n    });\r\n  }\r\n  /**\r\n   * Adds a state property reference to the update queue and schedules rendering.\r\n   * Increments revision, collects dependent paths, and schedules async rendering via microtask.\r\n   * If rendering is already in progress, the ref is queued but no new render is scheduled.\r\n   * \r\n   * @param {IStatePropertyRef} ref - The state property reference that changed\r\n   * @returns {void}\r\n   * \r\n   * @example\r\n   * updater.enqueueRef(getStatePropertyRef(pathInfo, listIndex));\r\n   */\r\n  enqueueRef(ref: IStatePropertyRef): void {\r\n    // Increment revision to track sub-updates within this version\r\n    this._revision++;\r\n    \r\n    // Add to both queues: render queue and save queue for callbacks\r\n    this._queue.push(ref);\r\n    this._saveQueue.push(ref);\r\n    \r\n    // Collect all paths that might be affected by this change\r\n    this.collectMaybeUpdates(this._engine, ref.info.pattern, this._engine.versionRevisionByPath, this._revision);\r\n    \r\n    this._renderMain.wakeup();\r\n  }\r\n\r\n  /**\r\n   * Executes a state update operation within a writable state context.\r\n   * Creates a writable proxy, executes the callback, and handles updated callbacks.\r\n   * Supports both synchronous and asynchronous update operations.\r\n   * \r\n   * @template R - The return type of the callback\r\n   * @param {ILoopContext | null} loopContext - Loop context for wildcard resolution, or null for root\r\n   * @param {function} callback - Callback that performs state modifications\r\n   * @returns {R} The result returned by the callback (may be a Promise)\r\n   * \r\n   * @example\r\n   * updater.update(null, (state) => {\r\n   *   state.count = 42;\r\n   * });\r\n   */\r\n  private _update<R>(\r\n    loopContext: ILoopContext | null, \r\n    callback: UpdateCallback<R>,\r\n    processResolvers: PromiseWithResolvers<void>\r\n  ): R {\r\n    // Create writable state proxy and execute update callback\r\n    const resultPromise: R = useWritableStateProxy<R>(this._engine, this, this._engine.state, loopContext, \r\n      (state:IWritableStateProxy, handler:IWritableStateHandler): R => {\r\n        // Execute user's state modification callback\r\n        return callback(state, handler);\r\n      }\r\n    );\r\n    \r\n    // Handler to process updated callbacks after state changes\r\n    const updatedCallbackHandler = () =>{\r\n      // If there are updated callbacks registered and refs in save queue\r\n      if (this._engine.pathManager.hasUpdatedCallback && this._saveQueue.length > 0) {\r\n        const saveQueue = this._saveQueue;\r\n        this._saveQueue = [];\r\n        \r\n        // Schedule updated callbacks in next microtask\r\n        queueMicrotask(() => {\r\n          const updatedPromise = this.update<Promise<void> | void>(null, (state, ): Promise<void> | void => {\r\n            // Invoke updated callbacks with the saved refs\r\n            return state[UpdatedCallbackSymbol](saveQueue);\r\n          });\r\n          if (updatedPromise instanceof Promise) {\r\n            updatedPromise.catch(() => {\r\n              raiseError({\r\n                code: 'UPD-005',\r\n                message: 'An error occurred during asynchronous state update.',\r\n                context: { where: 'Updater.update.updatedCallback' },\r\n                docsUrl: \"./docs/error-codes.md#upd\",\r\n              });\r\n            });\r\n          }\r\n        });\r\n      } else {\r\n        processResolvers.resolve();\r\n      }\r\n    };\r\n    \r\n    // Handle both Promise and non-Promise results\r\n    if (resultPromise instanceof Promise) {\r\n      // For async updates, run handler after promise completes\r\n      return resultPromise.finally(() => {\r\n        updatedCallbackHandler();\r\n      }) as R;\r\n    } else {\r\n      // For sync updates, run handler immediately\r\n      updatedCallbackHandler();\r\n    }\r\n    return resultPromise;\r\n  }\r\n\r\n  update<R>(\r\n    loopContext: ILoopContext | null,\r\n    callback: UpdateCallback<R>\r\n  ): R {\r\n    const enableReporting = config.debug && config.debugReports.includes(\"update\");\r\n    const start = enableReporting ? performance.now() : 0;\r\n    const processResolvers = this._tracker.createProcessResolver();\r\n    if (enableReporting) {\r\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n      processResolvers.promise.finally(() => {\r\n        const report: IUpdateReport = {\r\n          duration: performance.now() - start,\r\n          version: this._version,\r\n          revision: this._revision,\r\n        }\r\n        console.warn(\"[DebugReport][update]\", report);\r\n      });\r\n    }\r\n\r\n    return this._update<R>(loopContext, callback, processResolvers);\r\n  }\r\n\r\n  /**\r\n   * Retrieves and clears the queue of state property references pending update.\r\n   * \r\n   * @returns {IStatePropertyRef[]} Array of state property references to be updated\r\n   */\r\n  retrieveAndClearQueue(): IStatePropertyRef[] {\r\n    const queue = this._queue;\r\n    this._queue = [];\r\n    return queue;\r\n  }\r\n\r\n  /**\r\n   * Performs the initial rendering of the component.\r\n   * Creates a renderer and passes it to the callback for setup.\r\n   * \r\n   * @param {IBindContent} root - The root BindContent for initial rendering\r\n   * @returns {void}\r\n   */\r\n  initialRender(root: IBindContent): void {\r\n    const enableReporting = config.debug && config.debugReports.includes(\"update\");\r\n    const start = enableReporting ? performance.now() : 0;\r\n    const processResolvers = this._tracker.createProcessResolver();\r\n    if (enableReporting) {\r\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n      processResolvers.promise.finally(() => {\r\n        const report: IUpdateReport = {\r\n          duration: performance.now() - start,\r\n          version: this._version,\r\n          revision: this._revision,\r\n        }\r\n        console.warn(\"[DebugReport][update]\", report);\r\n      });\r\n    }\r\n    const renderer = createRenderer(this._engine, this);\r\n    try {\r\n      renderer.initialRender(root);\r\n    } finally {\r\n      // 2フェイズレンダリング対応時、この行は不要になる可能性あり\r\n      processResolvers.resolve();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param callback \r\n   * @returns \r\n   */\r\n  invoke<T>(callback: () => T): T {\r\n    if (!this._isAlive) {\r\n      this._rebuild();\r\n    }\r\n    const processResolvers = this._tracker.createProcessResolver();\r\n    try {\r\n      return callback();\r\n    } finally {\r\n      processResolvers.resolve();\r\n    }\r\n\r\n  }\r\n  /**\r\n   * Recursively collects all paths that may be affected by a change to the given path.\r\n   * Traverses child nodes and dynamic dependencies to build a complete dependency graph.\r\n   * Uses visitedInfo set to prevent infinite recursion on circular dependencies.\r\n   * \r\n   * @param {IComponentEngine} engine - The component engine\r\n   * @param {string} path - The path that changed\r\n   * @param {IPathNode} node - The PathNode corresponding to the path\r\n   * @param {Set<string>} visitedInfo - Set tracking already visited paths\r\n   * @param {boolean} isSource - True if this is the source path that changed\r\n   * @returns {void}\r\n   */\r\n  recursiveCollectMaybeUpdates(\r\n    engine: IComponentEngine,\r\n    path: string,\r\n    node: IPathNode,\r\n    visitedInfo: Set<string>,\r\n    isSource: boolean\r\n  ): void {\r\n    // Skip if already processed this path\r\n    if (visitedInfo.has(path)) {return;}\r\n    \r\n    // Skip list elements when processing source to avoid redundant updates\r\n    // (list container updates will handle elements)\r\n    if (isSource && engine.pathManager.elements.has(path)) {\r\n      return;\r\n    }\r\n    \r\n    // Mark as visited\r\n    visitedInfo.add(path);\r\n\r\n    // Collect all static child dependencies\r\n    for(const [, childNode] of node.childNodeByName.entries()) {\r\n      const childPath = childNode.currentPath;\r\n      this.recursiveCollectMaybeUpdates(engine, childPath, childNode, visitedInfo, false);\r\n    }\r\n\r\n    // Collect all dynamic dependencies (registered via data-bind)\r\n    const deps = engine.pathManager.dynamicDependencies.get(path) ?? [];\r\n    for(const depPath of deps) {\r\n      const depNode = findPathNodeByPath(engine.pathManager.rootNode, depPath);\r\n      if (depNode === null) {\r\n        raiseError({\r\n          code: \"UPD-004\",\r\n          message: `Path node not found for pattern: ${depPath}`,\r\n          context: { where: 'Updater.recursiveCollectMaybeUpdates', depPath },\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n      }\r\n      this.recursiveCollectMaybeUpdates(engine, depPath, depNode, visitedInfo, false);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collects all paths that might need updating based on a changed path.\r\n   * Uses caching to avoid redundant dependency traversal for the same paths.\r\n   * Updates the versionRevisionByPath map for cache invalidation.\r\n   * \r\n   * @param {IComponentEngine} engine - The component engine\r\n   * @param {string} path - The path that changed\r\n   * @param {Map<string, IVersionRevision>} versionRevisionByPath - Map to update with version info\r\n   * @param {number} revision - Current revision number\r\n   * @returns {void}\r\n   * @throws {Error} Throws UPD-003 if path node not found\r\n   */\r\n  collectMaybeUpdates(\r\n    engine: IComponentEngine, \r\n    path: string, \r\n    versionRevisionByPath: Map<string, IVersionRevision>, \r\n    revision: number\r\n  ): void {\r\n    const node = findPathNodeByPath(engine.pathManager.rootNode, path);\r\n    if (node === null) {\r\n      raiseError({\r\n        code: \"UPD-003\",\r\n        message: `Path node not found for pattern: ${path}`,\r\n        context: { where: 'Updater.collectMaybeUpdates', path },\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n\r\n    // Check cache for previously computed dependencies\r\n    let updatedPaths = this._cacheUpdatedPathsByPath.get(path);\r\n    if (typeof updatedPaths === \"undefined\") {\r\n      // Cache miss: compute dependencies recursively\r\n      updatedPaths = new Set<string>();\r\n      this.recursiveCollectMaybeUpdates(engine, path, node, updatedPaths, true);\r\n    }\r\n    \r\n    // Create version/revision marker for cache invalidation\r\n    const versionRevision = {\r\n      version: this.version,\r\n      revision: revision,\r\n    } \r\n    \r\n    // Update version info for all affected paths\r\n    for(const updatedPath of updatedPaths) {\r\n      versionRevisionByPath.set(updatedPath, versionRevision);\r\n    }\r\n    \r\n    // Cache the computed dependencies for future use\r\n    this._cacheUpdatedPathsByPath.set(path, updatedPaths);\r\n  }\r\n\r\n  /**\r\n   * Creates a read-only state context and executes a callback within it.\r\n   * Provides safe read access to state without modification capabilities.\r\n   * \r\n   * @template R - The return type of the callback\r\n   * @param {function} callback - Callback receiving read-only state and handler\r\n   * @returns {R} The result returned by the callback\r\n   * \r\n   * @example\r\n   * const value = updater.createReadonlyState((state) => {\r\n   *   return state.someProperty;\r\n   * });\r\n   */\r\n  createReadonlyState<R>(\r\n    callback: (state: IReadonlyStateProxy, handler: IReadonlyStateHandler) => R\r\n  ): R {\r\n    // Create read-only handler and proxy\r\n    const handler = createReadonlyStateHandler(this._engine, this, null);\r\n    const stateProxy = createReadonlyStateProxy(this._engine.state, handler);\r\n    \r\n    // Execute callback with read-only state\r\n    return callback(stateProxy, handler);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a new Updater instance and passes it to a callback.\r\n * This pattern provides clear scope management for update operations.\r\n * The updater is created with an incremented version number.\r\n * \r\n * @template R - The return type of the callback\r\n * @param {IComponentEngine} engine - The component engine to create updater for\r\n * @param {function(IUpdater): R} callback - Callback receiving the updater instance\r\n * @returns {R} The result returned by the callback\r\n * \r\n * @example\r\n * createUpdater(engine, (updater) => {\r\n *   updater.update(null, (state) => {\r\n *     state.count++;\r\n *   });\r\n * });\r\n */\r\nexport function createUpdater<R>(\r\n  engine: IComponentEngine, \r\n  callback: (updater: IUpdater) => R\r\n): R {\r\n  const updater = new Updater(engine);\r\n  return callback(updater);\r\n}","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeCheckbox class implements binding for checkboxes (input[type=\"checkbox\"]).\r\n * Controls checked state by comparing array value with checkbox value.\r\n * Supports bidirectional binding and readonly mode.\r\n *\r\n * @throws BIND-201 Value is not array: When non-array value is passed\r\n * @throws BIND-201 Decorator conflict: When multiple decorators are specified\r\n */\r\nclass BindingNodeCheckbox extends BindingNode {\r\n  /**\r\n   * Returns raw value attribute of checkbox input element.\r\n   * \r\n   * @returns Value attribute string\r\n   */\r\n  get value(): unknown {\r\n    const element = this.node as HTMLInputElement;\r\n    return element.value;\r\n  }\r\n  \r\n  /**\r\n   * Returns value with all filters applied.\r\n   * \r\n   * @returns Filtered value\r\n   */\r\n  get filteredValue(): unknown {\r\n    let value = this.value;\r\n    for (let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  \r\n  /**\r\n   * Sets up bidirectional binding with event listener.\r\n   * Event name: \"input\" (default), \"change\" (if onchange/change decorator), or none (if readonly/ro).\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node (should be HTMLInputElement with type=\"checkbox\")\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n  * @throws BIND-201 Decorator conflict\r\n   */\r\n  constructor(\r\n    binding: IBinding,\r\n    node: Node,\r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[],\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n\r\n    const isInputElement = this.node instanceof HTMLInputElement;\r\n    if (!isInputElement) {return;}\r\n    const inputElement = this.node;\r\n    if (inputElement.type !== \"checkbox\") {return;}\r\n    \r\n    if (decorates.length > 1) {\r\n      raiseError({\r\n        code: \"BIND-201\",\r\n        message: \"Checkbox binding has multiple decorators\",\r\n        context: { where: \"BindingNodeCheckbox.constructor\", name: this.name, decoratesCount: decorates.length },\r\n        docsUrl: \"./docs/error-codes.md#bind\",\r\n        severity: \"error\",\r\n      });\r\n    }\r\n    \r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? \"input\";\r\n    \r\n    if (eventName === \"readonly\" || eventName === \"ro\") {return;}\r\n    \r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, (_e) => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      createUpdater<void>(engine, (updater) => {\r\n        updater.update(loopContext, (state, handler) => {\r\n          binding.updateStateValue(state, handler, this.filteredValue);\r\n        });\r\n      });\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Sets checked state based on whether array includes filteredValue.\r\n   * \r\n   * @param value - Array of checked values\r\n   * @throws BIND-201 Value is not array\r\n   */\r\n  assignValue(value: unknown) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Checkbox value is not array',\r\n        context: { where: 'BindingNodeCheckbox.update', receivedType: typeof value },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.includes(this.filteredValue);\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate checkbox binding node.\r\n * \r\n * @param name - Binding name\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n * @returns Function that creates BindingNodeCheckbox with binding, node, and filters\r\n */\r\nexport const createBindingNodeCheckbox: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      return new BindingNodeCheckbox(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassList class implements binding for class attribute (classList).\r\n * Converts array value to space-separated string and sets to className.\r\n * One-way binding only.\r\n *\r\n * @throws BIND-201 Value is not array: When non-array value is passed\r\n */\r\nclass BindingNodeClassList extends BindingNode {\r\n  /**\r\n   * Converts array to space-separated string and sets to element.className.\r\n   * \r\n   * @param value - Array of class names\r\n   * @throws BIND-201 Value is not array\r\n   */\r\n  assignValue(value: unknown) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ClassList value is not array',\r\n        context: { where: 'BindingNodeClassList.update', receivedType: typeof value },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    const element = this.node as Element;\r\n    element.className = value.join(\" \");\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate classList binding node.\r\n * \r\n * @param name - Binding name (\"class\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeClassList with binding, node, and filters\r\n */\r\nexport const createBindingNodeClassList: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      return new BindingNodeClassList(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassName class implements toggle control for individual class names.\r\n * Uses classList.toggle based on boolean value.\r\n *\r\n * @throws BIND-201 Value is not boolean: When non-boolean value is passed\r\n */\r\nclass BindingNodeClassName extends BindingNode {\r\n  /**\r\n   * Adds or removes class based on boolean value using classList.toggle.\r\n   * \r\n   * @param value - Boolean value (true: add class, false: remove class)\r\n   * @throws BIND-201 Value is not boolean\r\n   */\r\n  assignValue(value: unknown) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ClassName value is not boolean',\r\n        context: { where: 'BindingNodeClassName.update', receivedType: typeof value },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    const element = this.node as Element;\r\n    element.classList.toggle(this.subName, value);\r\n  }\r\n}\r\n\r\nconst subNameByName: Record<string, string> = {};\r\n\r\n/**\r\n * Factory function to generate class name binding node.\r\n * \r\n * @param name - Binding name (e.g., \"class.active\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeClassName with binding, node, and filters\r\n */\r\nexport const createBindingNodeClassName: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      const subName = subNameByName[name] ?? (subNameByName[name] = name.split(\".\")[1]);\r\n      return new BindingNodeClassName(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeEvent class implements event binding (onClick, onInput, etc.).\r\n * Extracts event name from binding name (\"onClick\" → \"click\") and registers as event listener.\r\n * Supports preventDefault/stopPropagation decorators and passes loop indexes to handlers.\r\n *\r\n * @throws BIND-201 Binding value is not a function: When handler is missing\r\n */\r\nclass BindingNodeEvent extends BindingNode {\r\n  readonly renderable: boolean;\r\n  /**\r\n   * Registers event listener once at initialization.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node to attach event listener\r\n   * @param name - Binding name (e.g., \"onClick\", \"onInput\")\r\n   * @param subName - Event name extracted from binding name (e.g., \"click\", \"input\")\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (\"preventDefault\", \"stopPropagation\")\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    this.renderable = false;\r\n    \r\n    const element = node as HTMLElement;\r\n    element.addEventListener(this.subName, (e:Event) => this.handler(e));\r\n  }\r\n\r\n  /**\r\n   * Event binding does nothing on state change.\r\n   */\r\n  update() {\r\n  }\r\n\r\n  /**\r\n   * Executes bound function with event object and loop indexes as arguments.\r\n   * Supports preventDefault/stopPropagation decorators.\r\n   * \r\n   * @param e - DOM event object\r\n   * @returns Promise if handler returns Promise, void otherwise\r\n   * @throws BIND-201 Binding value is not a function\r\n   */\r\n  handler(e: Event): void {\r\n    const engine = this.binding.engine;\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const indexes = loopContext?.serialize().map((context) => context.listIndex.index) ?? [];\r\n    const options = this.decorates;\r\n    \r\n    if (options.includes(\"preventDefault\")) {\r\n      e.preventDefault();\r\n    }\r\n    if (options.includes(\"stopPropagation\")) {\r\n      e.stopPropagation();\r\n    }\r\n    \r\n    const resultPromise = createUpdater<Promise<void> | void>(engine, (updater) => {\r\n      return updater.update<Promise<void> | void>(loopContext, (state, handler) => {\r\n        const func = this.binding.bindingState.getValue(state, handler);\r\n        if (typeof func === \"function\") {\r\n          return Reflect.apply(func, state, [e, ...indexes]) as void | Promise<void>;\r\n        }\r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'Binding value is not a function',\r\n          context: {\r\n            where: 'BindingNodeEvent.handler',\r\n            bindName: this.name,\r\n            eventName: this.subName,\r\n            receivedType: typeof func,\r\n          },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n          severity: 'error',\r\n        });\r\n      });\r\n    });\r\n    \r\n    if (resultPromise instanceof Promise) {\r\n      resultPromise.catch((error: unknown) => {\r\n        const cause = error instanceof Error ? error : new Error(String(error));\r\n        raiseError({\r\n          code: 'BIND-202',\r\n          message: 'Event handler rejected',\r\n          context: { where: 'BindingNodeEvent.handler', bindName: this.name, eventName: this.subName },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n          severity: 'error',\r\n          cause,\r\n        });\r\n      });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Event binding does nothing on state change.\r\n   * \r\n   * @param renderer - Renderer instance (unused)\r\n   */\r\n  applyChange(_renderer: IRenderer): void {\r\n  }\r\n}\r\n\r\nconst subNameByName: Record<string, string> = {};\r\n\r\n/**\r\n * Factory function to generate event binding node.\r\n * \r\n * @param name - Binding name (e.g., \"onClick\", \"onInput\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (\"preventDefault\", \"stopPropagation\")\r\n * @returns Function that creates BindingNodeEvent with binding, node, and filters\r\n */\r\nexport const createBindingNodeEvent: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      const subName = subNameByName[name] ?? (subNameByName[name] = name.slice(2));\r\n      return new BindingNodeEvent(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","import { COMMENT_TEMPLATE_MARK } from \"../../constants.js\";\r\nimport { Filters } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\n\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * BindingNodeBlock is the base class for template blocks (for, if, etc.).\r\n * Extracts and validates template ID from comment node format: \"@@|<id> <pattern>\"\r\n * \r\n * Validation: Non-negative integer only, no leading zeros.\r\n *\r\n * @throws BIND-201 Invalid node: When ID cannot be extracted from comment node\r\n */\r\nexport class BindingNodeBlock extends BindingNode {\r\n  private _id: number;\r\n  readonly buildable: boolean;\r\n  \r\n  /**\r\n   * Returns template ID extracted from comment node.\r\n   * \r\n   * @returns Template ID (non-negative integer)\r\n   */\r\n  get id(): number {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Extracts and validates template ID from comment node.\r\n   * Rejects leading zeros, decimals, negatives, NaN, and Infinity.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Comment node containing template ID\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators\r\n   * @throws BIND-201 Invalid node (cannot extract valid template ID)\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    this.buildable = true;\r\n    \r\n    const commentText = this.node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN) ?? raiseError({\r\n      code: 'BIND-201',\r\n      message: 'Invalid node',\r\n      context: { where: 'BindingNodeBlock.id', textContent: this.node.textContent ?? null },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n      severity: 'error',\r\n    });\r\n    \r\n    const [ id,  ] = commentText.split(' ', 2);\r\n    const numId = Number(id);\r\n    \r\n    if (numId.toString() !== id || isNaN(numId) || !isFinite(numId) || !Number.isInteger(numId) || numId < 0) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Invalid node',\r\n        context: { where: 'BindingNodeBlock.id', textContent: this.node.textContent },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    \r\n    this._id = numId;\r\n  }\r\n    \r\n}","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNode for conditional rendering (if binding).\r\n * Controls BindContent mount/unmount based on boolean value.\r\n * Uses comment node as marker to insert/remove content.\r\n *\r\n * @throws BIND-201 assignValue not implemented\r\n * @throws BIND-201 Value must be boolean\r\n * @throws BIND-201 ParentNode is null\r\n */\r\nclass BindingNodeIf extends BindingNodeBlock {\r\n  private _bindContent: IBindContent;\r\n  private _trueBindContents: IBindContent[];\r\n  private _falseBindContents: IBindContent[] = [];\r\n  private _bindContents: IBindContent[];\r\n\r\n  /**\r\n   * Initializes BindContent with blank reference.\r\n   * Initial state treated as false (unmounted).\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Comment node as marker\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string, \r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    const blankInfo = getStructuredPathInfo(\"\");\r\n    const blankRef = getStatePropertyRef(blankInfo, null);\r\n    \r\n    this._bindContent = createBindContent(\r\n      this.binding, \r\n      this.id, \r\n      this.binding.engine,\r\n      blankRef, \r\n    );\r\n    \r\n    this._trueBindContents = [this._bindContent];\r\n    this._bindContents = this._falseBindContents;\r\n  }\r\n\r\n  /**\r\n   * Returns active BindContent array (true: [_bindContent], false: []).\r\n   * \r\n   * @returns Array of active IBindContent instances\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return this._bindContents;\r\n  }\r\n\r\n  /**\r\n   * Not implemented. Use applyChange for mount/unmount control.\r\n   * \r\n   * @param value - Value (unused)\r\n   * @throws BIND-201 Not implemented\r\n   */\r\n  assignValue(_value: unknown): void {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Binding assignValue not implemented',\r\n      context: { where: 'BindingNodeIf.assignValue', bindName: this.name },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Validates boolean value and controls mount/unmount.\r\n   * True: activate + mount + applyChange\r\n   * False: unmount + inactivate\r\n   * \r\n   * @param renderer - Renderer instance for state access\r\n   * @throws BIND-201 Value is not boolean\r\n   * @throws BIND-201 ParentNode is null\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    const baseContext = {\r\n      where: 'BindingNodeIf.applyChange',\r\n      bindName: this.name,\r\n    };\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState, renderer.readonlyHandler);\r\n    if (typeof filteredValue !== \"boolean\") {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'If binding value is not boolean',\r\n        context: { ...baseContext, receivedType: typeof filteredValue },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    \r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode === null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Parent node not found',\r\n        context: { ...baseContext, nodeType: this.node.nodeType },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    \r\n    if (filteredValue) {\r\n      this._bindContent.activate();\r\n      this._bindContent.mountAfter(parentNode, this.node);\r\n      this._bindContent.applyChange(renderer);\r\n      this._bindContents = this._trueBindContents;\r\n    } \r\n    else {\r\n      this._bindContent.unmount();\r\n      this._bindContent.inactivate();\r\n      this._bindContents = this._falseBindContents;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup: unmount and inactivate content.\r\n   */\r\n  inactivate(): void {\r\n    this._bindContent.unmount();\r\n    this._bindContent.inactivate();\r\n    this._bindContents = this._falseBindContents;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create BindingNodeIf instances.\r\n * \r\n * @param name - Binding name\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeIf with binding, node, and filters\r\n */\r\nexport const createBindingNodeIf: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      return new BindingNodeIf(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { GetByRefSymbol, GetListIndexesByRefSymbol } from \"../../StateClass/symbols.js\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\ntype BindContext = {\r\n  where: string;\r\n  bindName: string;\r\n  statePath: string;\r\n};\r\n\r\ntype ListDiffResult = {\r\n  hasRemoves: boolean; // at least one remove\r\n  willRemoveAll: boolean; // all items will be removed\r\n  hasAdds: boolean; // at least one add\r\n  isAllNew: boolean; // all items are new\r\n}\r\n\r\ntype ElementsResult = {\r\n  changes: IListIndex[];\r\n  overwrites: IListIndex[];\r\n}\r\n\r\nconst TOO_MANY_BIND_CONTENTS_THRESHOLD = 1000;\r\n\r\n// Reusable DocumentFragment for DOM operations, minimizes GC overhead\r\nconst workFragment = document.createDocumentFragment();\r\n\r\n/**\r\n * BindingNode for loop rendering (for binding).\r\n * Manages BindContent instances for each list element with efficient diff detection and pooling.\r\n */\r\nclass BindingNodeFor extends BindingNodeBlock {\r\n  private _bindContents: IBindContent[] = [];\r\n  private _bindContentByListIndex: WeakMap<IListIndex, IBindContent> = new WeakMap();\r\n  private _bindContentPool: (IBindContent | null)[] = [];\r\n  private _bindContentPoolIndex: number = -1;\r\n  private _cacheLoopInfo: IStructuredPathInfo | undefined = undefined;\r\n  private _oldListIndexes: IListIndex[] = [];\r\n  private _oldListIndexSet: Set<IListIndex> = new Set();\r\n  private _oldIndexByListIndex: Map<IListIndex, number> = new Map();\r\n\r\n  /**\r\n   * Returns array of active BindContent instances for each list element.\r\n   * \r\n   * @returns Array of IBindContent instances\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return this._bindContents;\r\n  }\r\n\r\n  /**\r\n   * Returns structured path info for loop with wildcard (lazy-initialized).\r\n   * \r\n   * @returns IStructuredPathInfo for loop elements\r\n   */\r\n  private get _loopInfo(): IStructuredPathInfo {\r\n    if (typeof this._cacheLoopInfo === \"undefined\") {\r\n      this._cacheLoopInfo = getStructuredPathInfo(this._elementsPath);\r\n    }\r\n    return this._cacheLoopInfo;\r\n  }\r\n\r\n  /**\r\n   * Returns elements path for loop elements.\r\n   * \r\n   * @returns String path for loop elements\r\n   */\r\n  private get _elementsPath(): string {\r\n    return `${this.binding.bindingState.info.pattern}.*`;\r\n  }\r\n\r\n  private _getBindContentFromPool(): IBindContent | null {\r\n    if (this._bindContentPoolIndex >= 0) {\r\n      const bindContent = this._bindContentPool[this._bindContentPoolIndex];\r\n      this._bindContentPool[this._bindContentPoolIndex] = null;\r\n      this._bindContentPoolIndex--;\r\n      return bindContent;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Creates or reuses BindContent from pool for given list index.\r\n   * \r\n   * @param renderer - Renderer instance (unused)\r\n   * @param listIndex - List index for new BindContent\r\n   * @returns Created or reused IBindContent instance\r\n   */\r\n  private _createBindContent(listIndex: IListIndex): IBindContent {\r\n    let bindContent: IBindContent | null = this._getBindContentFromPool();\r\n    if (bindContent !== null) {\r\n      bindContent.assignListIndex(listIndex);\r\n    } else {\r\n      const loopRef = getStatePropertyRef(this._loopInfo, listIndex);\r\n      bindContent = createBindContent(\r\n        this.binding,\r\n        this.id,\r\n        this.binding.engine,\r\n        loopRef\r\n      );\r\n    }\r\n    this._bindContentByListIndex.set(listIndex, bindContent);\r\n    bindContent.activate();\r\n    return bindContent;\r\n  }\r\n\r\n  /**\r\n   * Unmounts and inactivates BindContent (returned to pool later).\r\n   * \r\n   * @param bindContent - BindContent to delete\r\n   */\r\n  private _deleteBindContent(bindContent: IBindContent): void {\r\n    bindContent.unmount();\r\n    bindContent.inactivate();\r\n  }\r\n\r\n  /**\r\n   * Not implemented. Use applyChange for list updates.\r\n   * \r\n   * @param value - Value (unused)\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  assignValue(_value: unknown) {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Binding assignValue not implemented',\r\n      context: { where: 'BindingNodeFor.assignValue' },\r\n      hint: 'Call applyChange to update loop bindings',\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Removes all BindContents and resets state.\r\n   * \r\n   * @param parentNode - Parent node containing the node\r\n   * @param lastContent - Last BindContent in the current list\r\n   * @returns Boolean indicating if removal was successful\r\n   */\r\n  private _allRemove(\r\n    parentNode: ParentNode, \r\n    lastContent: IBindContent\r\n  ): boolean {\r\n    let workFirstNode: Node | null = parentNode.firstChild;\r\n    while(workFirstNode && workFirstNode.nodeType === Node.TEXT_NODE && workFirstNode.textContent?.trim() === \"\") {\r\n      workFirstNode = workFirstNode.nextSibling;\r\n    }\r\n    let workLastNode: Node | null = parentNode.lastChild;\r\n    while(workLastNode && workLastNode.nodeType === Node.TEXT_NODE && workLastNode.textContent?.trim() === \"\") {\r\n      workLastNode = workLastNode.previousSibling;\r\n    }\r\n    if (workFirstNode === this.node && workLastNode === lastContent.lastNode) {\r\n      // safe to clear all, needless to unmount each\r\n      parentNode.textContent = \"\";\r\n      parentNode.append(this.node);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Partially removes BindContents for removed list indexes.\r\n   *\r\n   * @param newListIndexesSet - Set of new list indexes\r\n   * @param oldListIndexesSet - Set of old list indexes\r\n   * @param bindContentByListIndex - WeakMap of list indexes to BindContents\r\n   * @param baseContext - Context for error reporting\r\n   * @returns Array of removed IBindContent instances\r\n   */\r\n  private _partialRemove(\r\n    newListIndexesSet: Set<IListIndex>, \r\n    oldListIndexesSet: Set<IListIndex>, \r\n    bindContentByListIndex: WeakMap<IListIndex, IBindContent>,\r\n    baseContext: BindContext\r\n  ): IBindContent[] {\r\n    const removeBindContents: IBindContent[] = [];\r\n    for(const oldListIndex of oldListIndexesSet) {\r\n      if (!newListIndexesSet.has(oldListIndex)) {\r\n        const bindContent = bindContentByListIndex.get(oldListIndex);\r\n        if (typeof bindContent === \"undefined\") {\r\n          raiseError({\r\n            code: 'BIND-201',\r\n            message: 'BindContent not found',\r\n            context: { ...baseContext, phase: 'initial removes', listIndex: oldListIndex.index },\r\n            docsUrl: './docs/error-codes.md#bind',\r\n          });\r\n        }\r\n        this._deleteBindContent(bindContent);\r\n        removeBindContents.push(bindContent);\r\n      }\r\n    }\r\n    return removeBindContents;\r\n  }\r\n\r\n  /**\r\n   * Pools BindContent instances for future reuse.\r\n   * \r\n   * @param bindContents - Array of IBindContent instances to pool\r\n   */\r\n  private _poolBindContents(bindContents: IBindContent[]): void {\r\n    // exhaust pool first\r\n    if (this._bindContentPoolIndex === -1) {\r\n      this._bindContentPool = bindContents;\r\n      this._bindContentPoolIndex = bindContents.length - 1;\r\n      return;\r\n    }\r\n    // full pool expansion\r\n    if (this._bindContentPool.length === (this._bindContentPoolIndex + 1)) {\r\n      if (bindContents.length > TOO_MANY_BIND_CONTENTS_THRESHOLD) {\r\n        // large batch, concat for stack overflow safety\r\n        this._bindContentPool = this._bindContentPool.concat(bindContents);\r\n      } else {\r\n        this._bindContentPool.push(...bindContents);\r\n      }\r\n      this._bindContentPoolIndex += bindContents.length;\r\n      return;\r\n    }\r\n    const availableSpace = this._bindContentPool.length - (this._bindContentPoolIndex + 1);\r\n    const neededSpace = bindContents.length;\r\n    if (neededSpace <= availableSpace) {\r\n      // enough space available\r\n      for(let i = 0; i < bindContents.length; i++) {\r\n        this._bindContentPoolIndex++;\r\n        this._bindContentPool[this._bindContentPoolIndex] = bindContents[i];\r\n      }\r\n    } else {\r\n      // expand pool\r\n      for(let i = 0; i < bindContents.length; i++) {\r\n        this._bindContentPoolIndex++;\r\n        if (this._bindContentPoolIndex >= this._bindContentPool.length) {\r\n          this._bindContentPool.push(bindContents[i]);\r\n        } else {\r\n          this._bindContentPool[this._bindContentPoolIndex] = bindContents[i];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears all active BindContents.\r\n   * for _allRemove optimization.\r\n   * needless to unmount each BindContent.\r\n   */\r\n  private _clearBindContents(): void {\r\n    for(let i = 0; i < this._bindContents.length; i++) {\r\n      this._bindContents[i].inactivate();\r\n    }\r\n    this._poolBindContents(this._bindContents);\r\n    this._bindContents = [];\r\n  }\r\n\r\n  /**\r\n   * Applies changes to the loop binding using diff detection.\r\n   * Efficiently handles adds, removes, reorders, and overwrites.\r\n   * @param newListIndexSet - Set of new list indexes\r\n   * @param oldListIndexSet - Set of old list indexes\r\n   * @returns ListDiffResult indicating the types of changes detected\r\n   */\r\n  private _getListDiffResult(\r\n    newListIndexSet: Set<IListIndex>, \r\n    oldListIndexSet: Set<IListIndex>\r\n  ): ListDiffResult {\r\n    const oldSize = oldListIndexSet.size;\r\n    const newSize = newListIndexSet.size;\r\n\r\n    // edge case for empty lists\r\n    if (oldSize === 0 && newSize === 0) {\r\n      return { hasRemoves: false, willRemoveAll: false, hasAdds: false, isAllNew: false };\r\n    }\r\n    if (oldSize === 0) {\r\n      return { hasRemoves: false, willRemoveAll: false, hasAdds: true, isAllNew: true };\r\n    }\r\n    if (newSize === 0) {\r\n      return { hasRemoves: true, willRemoveAll: true, hasAdds: false, isAllNew: false };\r\n    }\r\n\r\n    // calculate removes and retains\r\n    let removedCount = 0;\r\n    let retainedCount = 0;\r\n    \r\n    for (const oldIndex of oldListIndexSet) {\r\n      if (newListIndexSet.has(oldIndex)) {\r\n        retainedCount++;\r\n      } else {\r\n        removedCount++;\r\n      }\r\n      // early exit: both remove and retain detected\r\n      if (removedCount > 0 && retainedCount > 0) {\r\n        break;\r\n      }\r\n    }\r\n    \r\n    const hasRemoves = removedCount > 0;\r\n    const willRemoveAll = retainedCount === 0;\r\n    \r\n    // detect adds\r\n    let addedCount = 0;\r\n    for (const newIndex of newListIndexSet) {\r\n      if (!oldListIndexSet.has(newIndex)) {\r\n        addedCount++;\r\n        break; // early exit: at least one add detected\r\n      }\r\n    }\r\n    \r\n    const hasAdds = addedCount > 0;\r\n    const isAllNew = willRemoveAll && newSize > 0;\r\n\r\n    return { hasRemoves, willRemoveAll, hasAdds, isAllNew };\r\n  }\r\n\r\n  /**\r\n   * Retrieves elements result based on renderer updates.\r\n   * \r\n   * @param renderer - Renderer instance\r\n   * @param elementsPath - Path to elements\r\n   * @param oldListIndexSet - Set of old list indexes\r\n   * @param baseContext - Context for error reporting\r\n   * @returns ElementsResult containing changes and overwrites\r\n   */\r\n  private _getElementsResult(\r\n    renderer: IRenderer, \r\n    elementsPath: string, \r\n    oldListIndexSet: Set<IListIndex>,\r\n    baseContext: BindContext\r\n  ): ElementsResult {\r\n    const changes: IListIndex[] = [];\r\n    const overwrites: IListIndex[] = [];\r\n    for(const updatingRef of renderer.updatingRefSet) {\r\n      if (updatingRef.info.pattern !== elementsPath) {continue;}\r\n      /* v8 ignore start -- branch covered by tests but v8 reports partial coverage */\r\n      if (renderer.processedRefs.has(updatingRef)) {continue;}\r\n      /* v8 ignore stop */\r\n      const listIndex = updatingRef.listIndex;\r\n      if (listIndex === null) {\r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'ListIndex is null',\r\n          context: { ...baseContext, refPattern: updatingRef.info.pattern },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n        });\r\n      }\r\n      if (oldListIndexSet.has(listIndex)) {\r\n        changes.push(listIndex);\r\n      } else {\r\n        overwrites.push(listIndex);\r\n      }\r\n      renderer.processedRefs.add(updatingRef);\r\n    }\r\n    return { changes, overwrites };\r\n  }\r\n\r\n  /**\r\n   * Applies changes using document fragment for efficient DOM updates.\r\n   * \r\n   * @param renderer - Renderer instance\r\n   * @param parentNode - Parent DOM node\r\n   * @param firstNode - First child node of the parent\r\n   * @param oldListIndexes - Array of old list indexes\r\n   * @param oldListIndexSet - Set of old list indexes\r\n   * @param newListIndexes - Array of new list indexes\r\n   * @param bindContentByListIndex - WeakMap of list indexes to bind contents\r\n   * @param bindingsByListIndex - WeakMap of list indexes to bindings\r\n   * @param baseContext - Context for error reporting\r\n   * @returns Array of new bind contents\r\n   */\r\n  private _applyChange(\r\n    renderer: IRenderer,\r\n    parentNode: ParentNode,\r\n    firstNode: Node,\r\n    oldListIndexes: IListIndex[],\r\n    oldListIndexSet: Set<IListIndex>,\r\n    newListIndexes: IListIndex[],\r\n    bindContentByListIndex: WeakMap<IListIndex, IBindContent>,\r\n    bindingsByListIndex: WeakMap<IListIndex, Set<IBinding>>,\r\n    baseContext: BindContext\r\n  ): IBindContent[] {\r\n    const newBindContents: IBindContent[] = [];\r\n    let lastBindContent = null;\r\n\r\n    // Rebuild path: create/reuse BindContents in new order\r\n    this._oldIndexByListIndex.clear();\r\n    for(let i = 0; i < oldListIndexes.length; i++) {\r\n      this._oldIndexByListIndex.set(oldListIndexes[i], i);\r\n    }\r\n    const changeListIndexes: IListIndex[] = [];\r\n    for(let i = 0; i < newListIndexes.length; i++) {\r\n      const listIndex = newListIndexes[i];\r\n      const lastNode = lastBindContent?.lastNode ?? firstNode;\r\n      let bindContent;\r\n      if (!oldListIndexSet.has(listIndex)) {\r\n        bindContent = this._createBindContent(listIndex);\r\n        bindContent.mountAfter(parentNode, lastNode);\r\n        bindContent.applyChange(renderer);\r\n      } else {\r\n        bindContent = bindContentByListIndex.get(listIndex);\r\n        if (typeof bindContent === \"undefined\") {\r\n          raiseError({\r\n            code: 'BIND-201',\r\n            message: 'BindContent not found',\r\n            context: { ...baseContext, phase: 'reuse', listIndex: listIndex.index },\r\n            docsUrl: './docs/error-codes.md#bind',\r\n          });\r\n        }\r\n        if (lastNode?.nextSibling !== bindContent.firstChildNode) {\r\n          bindContent.mountAfter(parentNode, lastNode);\r\n        }\r\n        const oldIndex = this._oldIndexByListIndex.get(listIndex);\r\n        if (typeof oldIndex !== \"undefined\" && oldIndex !== i) {\r\n          changeListIndexes.push(listIndex);\r\n        }\r\n      }\r\n      newBindContents.push(bindContent);\r\n      lastBindContent = bindContent;\r\n    }\r\n    for(const listIndex of changeListIndexes) {\r\n      const bindings = bindingsByListIndex.get(listIndex) ?? [];\r\n      for(const binding of bindings) {\r\n        if (!binding.bindingNode.renderable) {continue;}\r\n        if (renderer.updatedBindings.has(binding)) {continue;}\r\n        binding.applyChange(renderer);\r\n      }\r\n    }\r\n    return newBindContents;\r\n  }\r\n\r\n  /**\r\n   *  Reorders BindContents based on detected changes.\r\n   * \r\n   * @param parentNode - Parent DOM node\r\n   * @param firstNode - First child node of the parent\r\n   * @param changes - List of changes detected\r\n   * @param bindContents - Current array of bind contents\r\n   * @param bindContentByListIndex - WeakMap of list indexes to bind contents\r\n   * @param baseContext - Context for error reporting\r\n   */\r\n  private _reorder(\r\n    parentNode: ParentNode,\r\n    firstNode: Node,\r\n    changes: IListIndex[],\r\n    bindContents: IBindContent[],\r\n    bindContentByListIndex: WeakMap<IListIndex, IBindContent>,\r\n    baseContext: BindContext\r\n  ): void {\r\n    const changeIndexes = changes;\r\n    changeIndexes.sort((a, b) => a.index - b.index);\r\n    for(const listIndex of changeIndexes) {\r\n      const bindContent = bindContentByListIndex.get(listIndex);\r\n      if (typeof bindContent === \"undefined\") {\r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'BindContent not found',\r\n          context: { ...baseContext, phase: 'reorder', listIndex: listIndex.index },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n        });\r\n      }\r\n      bindContents[listIndex.index] = bindContent;\r\n      const lastNode = bindContents[listIndex.index - 1]?.lastNode ?? firstNode;\r\n      bindContent.mountAfter(parentNode, lastNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Applies overwrites to BindContents based on detected changes.\r\n   * \r\n   * @param renderer - Renderer instance\r\n   * @param overwrites - List of changes detected\r\n   * @param bindContents - Current array of bind contents\r\n   * @param bindContentByListIndex - WeakMap of list indexes to bind contents\r\n   * @param baseContext - Context for error reporting\r\n   */\r\n  private _overwrite(\r\n    renderer: IRenderer,\r\n    overwrites: IListIndex[],\r\n    bindContentByListIndex: WeakMap<IListIndex, IBindContent>,\r\n    baseContext: BindContext\r\n  ): void {\r\n    for(let i = 0; i < overwrites.length; i++) {\r\n      const listIndex = overwrites[i];\r\n      const bindContent = bindContentByListIndex.get(listIndex);\r\n      /* v8 ignore start -- defensive: unreachable when isReorder=true requires hasAdds=false */\r\n      if (typeof bindContent === \"undefined\") {\r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'BindContent not found',\r\n          context: { ...baseContext, phase: 'overwrites', listIndex: listIndex.index },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n        });\r\n      }\r\n      /* v8 ignore stop */\r\n      bindContent.applyChange(renderer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * replaces BindContents optimally when all items are new.\r\n   * \r\n   * @param parentNode - Parent DOM node\r\n   * @param firstNode - First child node of the parent\r\n   * @param renderer - Renderer instance\r\n   * @param oldListIndexes - Previous list indexes\r\n   * @param newListIndexes - New list indexes\r\n   * @param bindContentByListIndex - WeakMap of list indexes to bind contents\r\n   * @param bindContents - Current array of bind contents\r\n   * @param baseContext - Context for error reporting\r\n   * @returns removed IBindContent instances\r\n   */\r\n  private _optimizedReplace(\r\n    parentNode: ParentNode,\r\n    firstNode: Node,\r\n    renderer: IRenderer,\r\n    oldListIndexes: IListIndex[],\r\n    newListIndexes: IListIndex[],\r\n    bindContentByListIndex: WeakMap<IListIndex, IBindContent>,\r\n    bindContents: IBindContent[],\r\n    baseContext: BindContext\r\n  ): IBindContent[] {\r\n    const removeBindContents: IBindContent[] = [];\r\n    // Note: isAllNew is only true when newListIndexes.length > 0\r\n    // so oldListIndexes.length === 0 && newListIndexes.length === 0 case is unreachable\r\n    if (oldListIndexes.length > newListIndexes.length) {\r\n      for(let i = newListIndexes.length; i < oldListIndexes.length; i++) {\r\n        const listIndex = oldListIndexes[i];\r\n        const bindContent = bindContentByListIndex.get(listIndex);\r\n        if (typeof bindContent === \"undefined\") {\r\n          raiseError({\r\n            code: 'BIND-201',\r\n            message: 'BindContent not found',\r\n            context: { ...baseContext, phase: 'optimized replace', listIndex: listIndex.index },\r\n            docsUrl: './docs/error-codes.md#bind',\r\n          });\r\n        }\r\n        this._deleteBindContent(bindContent);\r\n        removeBindContents.push(bindContent);\r\n      }\r\n      bindContents.length = newListIndexes.length;\r\n    }\r\n    const minBindContentsLength = Math.min(oldListIndexes.length, newListIndexes.length);\r\n    for(let i = 0; i < minBindContentsLength; i++) {\r\n      const listIndex = newListIndexes[i];\r\n      const bindContent = bindContents[i];\r\n      bindContent.assignListIndex(listIndex);\r\n      bindContent.activate();\r\n      bindContent.applyChange(renderer);\r\n      bindContentByListIndex.set(listIndex, bindContent);\r\n    }\r\n    if (oldListIndexes.length < newListIndexes.length) {\r\n      let replaceParentNode: ParentNode = parentNode;\r\n      const useFragement = oldListIndexes.length === 0 && parentNode.isConnected;\r\n      if (useFragement) {\r\n        workFragment.textContent = \"\";\r\n        replaceParentNode = workFragment;\r\n        replaceParentNode.append(firstNode);\r\n      }\r\n      let lastBindContent: IBindContent | null = null;\r\n      for(let i = oldListIndexes.length; i < newListIndexes.length; i++) {\r\n        const listIndex = newListIndexes[i];\r\n        const lastNode = lastBindContent?.lastNode ?? firstNode;\r\n        const bindContent = this._createBindContent(listIndex);\r\n        bindContent.mountAfter(replaceParentNode, lastNode);\r\n        bindContent.applyChange(renderer);\r\n        bindContents.push(bindContent);\r\n        lastBindContent = bindContent;\r\n      }\r\n      if (useFragement) {\r\n        parentNode.append(replaceParentNode);\r\n      }\r\n    }\r\n    return removeBindContents;\r\n  }\r\n  /**\r\n   * Applies list changes using diff detection algorithm.\r\n   * Handles adds, removes, reorders, and overwrites efficiently.\r\n   * \r\n   * @param renderer - Renderer instance for state access\r\n   * @throws BIND-201 ListIndex is null, BindContent not found, ParentNode is null, Last content is null\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    const baseContext = {\r\n      where: 'BindingNodeFor.applyChange',\r\n      bindName: this.name,\r\n      statePath: this.binding.bindingState.pattern,\r\n    };\r\n\r\n    // Ensure parent node exists\r\n    const parentNode = this.node.parentNode ?? raiseError({\r\n      code: 'BIND-201',\r\n      message: 'Parent node not found',\r\n      context: { ...baseContext, nodeType: this.node.nodeType },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n\r\n    // Detect changes: adds, removes, changeIndexes, overwrites\r\n    const newList = renderer.readonlyState[GetByRefSymbol](this.binding.bindingState.ref);\r\n    if (!Array.isArray(newList)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Loop value is not array',\r\n        context: { ...baseContext, receivedType: newList === null ? 'null' : typeof newList },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    const newListIndexes = renderer.readonlyState[GetListIndexesByRefSymbol](this.binding.bindingState.ref) ?? [];\r\n    const newListIndexesSet = new Set<IListIndex>(newListIndexes);\r\n    \r\n    const listDiff = this._getListDiffResult(newListIndexesSet, this._oldListIndexSet);\r\n    const elementsResult = this._getElementsResult(renderer, this._elementsPath, this._oldListIndexSet, baseContext);\r\n\r\n    let optimizedReplaceDone = false;\r\n\r\n    if (listDiff.isAllNew) {\r\n      const removeBindContents = this._optimizedReplace(\r\n        parentNode,\r\n        this.node,\r\n        renderer,\r\n        this._oldListIndexes,\r\n        newListIndexes,\r\n        this._bindContentByListIndex,\r\n        this._bindContents,\r\n        baseContext\r\n      );\r\n      if (removeBindContents.length > 0) {\r\n        this._poolBindContents(removeBindContents);\r\n      }\r\n      optimizedReplaceDone = true;\r\n    }\r\n\r\n    // Optimization: clear all if new list is empty\r\n    let isCleared = false;\r\n    if (!optimizedReplaceDone && listDiff.willRemoveAll) {\r\n      /* v8 ignore start -- defensive: willRemoveAll requires oldSize>0, so bindContents is never empty here */\r\n      const lastContent = this.bindContents[this.bindContents.length - 1] ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Last BindContent not found',\r\n        context: { ...baseContext, bindContentCount: this.bindContents.length },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n      /* v8 ignore stop */\r\n\r\n      isCleared = this._allRemove(parentNode, lastContent);\r\n      if (isCleared) {\r\n        this._clearBindContents();\r\n      }\r\n    }\r\n\r\n    // Handle removes: unmount and pool BindContents\r\n    if (!optimizedReplaceDone && !isCleared && listDiff.hasRemoves) {\r\n      const removeBindContents = this._partialRemove(\r\n        newListIndexesSet, this._oldListIndexSet, this._bindContentByListIndex, baseContext\r\n      );\r\n      if (removeBindContents.length > 0) {\r\n        this._poolBindContents(removeBindContents);\r\n        // Update _bindContents to remove deleted entries\r\n        if (!listDiff.hasAdds) {\r\n          const removeSet = new Set(removeBindContents);\r\n          this._bindContents = this._bindContents.filter(bc => !removeSet.has(bc));\r\n        }\r\n      }\r\n    }\r\n\r\n    // Optimization: reorder-only path when no adds/removes\r\n    const isReorder = !listDiff.hasAdds && !listDiff.hasRemoves &&\r\n      (elementsResult.changes.length > 0 || elementsResult.overwrites.length > 0 );\r\n\r\n    if (!optimizedReplaceDone && listDiff.hasAdds) {\r\n      // Rebuild path: create/reuse BindContents in new order\r\n      this._bindContents = this._applyChange(\r\n        renderer,\r\n        parentNode,\r\n        this.node,\r\n        this._oldListIndexes,\r\n        this._oldListIndexSet,\r\n        newListIndexes,\r\n        this._bindContentByListIndex,\r\n        this.binding.bindingsByListIndex,\r\n        baseContext\r\n      );\r\n    } else if (!optimizedReplaceDone && isReorder) {\r\n      // Reorder path: only move DOM nodes without recreating\r\n      if (elementsResult.changes.length > 0) {\r\n        this._reorder(\r\n          parentNode,\r\n          this.node,\r\n          elementsResult.changes,\r\n          this._bindContents,\r\n          this._bindContentByListIndex,\r\n          baseContext\r\n        );\r\n      }\r\n      if (elementsResult.overwrites.length > 0) {\r\n        this._overwrite(\r\n          renderer,\r\n          elementsResult.overwrites,\r\n          this._bindContentByListIndex,\r\n          baseContext\r\n        );\r\n      }\r\n    }\r\n\r\n    // Update state for next diff detection\r\n    this._oldListIndexes = [...newListIndexes];\r\n    this._oldListIndexSet = newListIndexesSet;\r\n  }\r\n\r\n  /**\r\n   * Inactivates all BindContents and resets state.\r\n   */\r\n  inactivate(): void {\r\n    for(let i = 0; i < this._bindContents.length; i++) {\r\n      const bindContent = this._bindContents[i];\r\n      bindContent.unmount();\r\n      bindContent.inactivate();\r\n    }\r\n    this._poolBindContents(this._bindContents);\r\n    this._bindContents = [];\r\n    this._bindContentByListIndex = new WeakMap();\r\n    this._oldListIndexes = [];\r\n    this._oldListIndexSet = new Set();\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create BindingNodeFor instances.\r\n * \r\n * @param name - Binding name (list property path)\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeFor with binding, node, and filters\r\n */\r\nexport const createBindingNodeFor: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createBindingFilters(filters, filterTexts);\r\n    return new BindingNodeFor(binding, node, name, \"\", filterFns, decorates);\r\n  }\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * Checks if element supports bidirectional binding.\r\n * \r\n * @param element - HTML element to check\r\n * @returns true if element is input/textarea/select, false otherwise\r\n */\r\nfunction isTwoWayBindable(element: HTMLElement): boolean {\r\n  return element instanceof HTMLInputElement\r\n    || element instanceof HTMLTextAreaElement\r\n    || element instanceof HTMLSelectElement;\r\n}\r\n\r\n/**\r\n * Default event names for bidirectional binding by property name.\r\n */\r\nconst defaultEventByName: Record<string, string> = {\r\n  value: \"input\",\r\n  valueAsNumber: \"input\",\r\n  valueAsDate: \"input\",\r\n  checked: \"change\",\r\n  selected: \"change\",\r\n};\r\n\r\ntype DefaultPropertyByElementType = {\r\n  [key: string]: Set<string>;\r\n};\r\n\r\n/**\r\n * Bidirectional bindable properties by input type.\r\n */\r\nconst twoWayPropertyByElementType: DefaultPropertyByElementType = {\r\n  radio: new Set([\"checked\"]),\r\n  checkbox: new Set([\"checked\"]),\r\n};\r\n\r\nconst VALUES_SET = new Set([\"value\", \"valueAsNumber\", \"valueAsDate\"]);\r\n\r\nconst BLANK_SET = new Set<string>();\r\n\r\n/**\r\n * Returns bidirectional bindable property set for element.\r\n * \r\n * @param node - DOM node to check\r\n * @returns Set of bindable property names (e.g., \"value\", \"checked\")\r\n */\r\nconst getTwoWayPropertiesHTMLElement = (node: Node): Set<string> =>\r\n  node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement || node instanceof HTMLOptionElement\r\n    ? VALUES_SET\r\n    : node instanceof HTMLInputElement\r\n      ? (twoWayPropertyByElementType[node.type] ?? VALUES_SET)\r\n      : BLANK_SET;\r\n\r\n\r\n/**\r\n * BindingNode for property binding (value, checked, etc.).\r\n * Supports bidirectional binding with event listeners.\r\n * Converts null/undefined/NaN to empty string.\r\n */\r\nclass BindingNodeProperty extends BindingNode {\r\n  /**\r\n   * Registers event listener for bidirectional binding if:\r\n   * - Element supports two-way binding (input/textarea/select)\r\n   * - Property name is bindable (value, checked, etc.)\r\n   * - Not readonly decorator\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node\r\n   * @param name - Property name (e.g., \"value\", \"checked\")\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n   * @throws BIND-201 Has multiple decorators\r\n   */\r\n  constructor(\r\n    binding: IBinding,\r\n    node: Node,\r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[],\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n\r\n    if (!(name in node)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: `Property not found on node: ${name}`,\r\n        context: {\r\n          where: 'BindingNodeProperty.assignValue',\r\n          bindName: name,\r\n          nodeType: node.nodeType,\r\n        },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n      return;\r\n    }\r\n\r\n    const isElement = this.node instanceof HTMLElement;\r\n    if (!isElement) {return;}\r\n    \r\n    if (!isTwoWayBindable(this.node)) {return;}\r\n    \r\n    const defaultNames = getTwoWayPropertiesHTMLElement(this.node);\r\n    if (!defaultNames.has(this.name)) {return;}\r\n    \r\n    if (decorates.length > 1) {\r\n      raiseError({\r\n        code: \"BIND-201\",\r\n        message: \"Property binding has multiple decorators\",\r\n        context: {\r\n          where: \"BindingNodeProperty.constructor\",\r\n          bindName: this.name,\r\n          decoratesCount: decorates.length,\r\n        },\r\n        docsUrl: \"./docs/error-codes.md#bind\",\r\n      });\r\n    }\r\n    \r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? defaultEventByName[this.name] ?? \"readonly\";\r\n    \r\n    if (eventName === \"readonly\" || eventName === \"ro\") {return;}\r\n\r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, (_e) => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      createUpdater<void>(engine, (updater) => {\r\n        updater.update(loopContext, (state, handler) => {\r\n          binding.updateStateValue(state, handler, this.filteredValue);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns raw property value from DOM node.\r\n   * \r\n   * @returns Property value\r\n   */\r\n  get value(): unknown {\r\n    // @ts-expect-error TS doesn't recognize dynamic property names\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n    return this.node[this.name];\r\n  }\r\n  \r\n  /**\r\n   * Returns property value with filters applied.\r\n   * \r\n   * @returns Filtered property value\r\n   */\r\n  get filteredValue(): unknown {\r\n    let value = this.value;\r\n    for (let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  \r\n  /**\r\n   * Assigns value to property, converting null/undefined/NaN to empty string.\r\n   * \r\n   * @param value - Value to assign to property\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  assignValue(value: any) {\r\n    let anyValue;\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      anyValue = \"\";\r\n    } else {\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n      anyValue = value;\r\n    }\r\n    // @ts-expect-error TS doesn't recognize dynamic property names\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n    this.node[this.name] = anyValue;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create BindingNodeProperty instances.\r\n * \r\n * @param name - Property name (e.g., \"value\", \"checked\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n * @returns Function that creates BindingNodeProperty with binding, node, and filters\r\n */\r\nexport const createBindingNodeProperty: CreateBindingNodeFn =\r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) =>\r\n    (binding: IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      return new BindingNodeProperty(binding, node, name, \"\", filterFns, decorates);\r\n    };\r\n\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { createUpdater } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeRadio class implements binding processing for radio buttons.\r\n * - Controls checked state by comparing binding value with input element value\r\n * - Supports bidirectional binding (auto-updates state on user selection)\r\n * - Converts null/undefined to empty string for comparison\r\n */\r\nclass BindingNodeRadio extends BindingNode {\r\n  /**\r\n   * Constructor sets up radio button bidirectional binding.\r\n   * - Validates decorates count (max 1)\r\n   * - Registers event listener for state updates (skipped if readonly/ro)\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - DOM node (should be HTMLInputElement with type=\"radio\")\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n   * @throws BIND-201 Has multiple decorators\r\n   */\r\n  constructor(\r\n    binding: IBinding,\r\n    node: Node,\r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[],\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n\r\n    const isInputElement = this.node instanceof HTMLInputElement;\r\n    if (!isInputElement) {return;}\r\n    const inputElement = this.node;\r\n    if (inputElement.type !== \"radio\") {return;}\r\n    \r\n    if (decorates.length > 1) {\r\n      raiseError({\r\n        code: \"BIND-201\",\r\n        message: \"Radio binding has multiple decorators\",\r\n        context: {\r\n          where: \"BindingNodeRadio.constructor\",\r\n          bindName: this.name,\r\n          decoratesCount: decorates.length,\r\n        },\r\n        docsUrl: \"./docs/error-codes.md#bind\",\r\n      });\r\n    }\r\n    \r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? \"input\";\r\n    \r\n    if (eventName === \"readonly\" || eventName === \"ro\") {return;}\r\n    \r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, (_e) => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      createUpdater<void>(engine, (updater) => {\r\n        updater.update(loopContext, (state, handler) => {\r\n          binding.updateStateValue(state, handler, this.filteredValue);\r\n        });\r\n      });\r\n    });\r\n\r\n  }\r\n  \r\n  /**\r\n   * Returns raw value attribute of radio input element.\r\n   * \r\n   * @returns Value attribute string\r\n   */\r\n  get value(): unknown {\r\n    const element = this.node as HTMLInputElement;\r\n    return element.value;\r\n  }\r\n  \r\n  /**\r\n   * Returns value with all filters applied.\r\n   * \r\n   * @returns Filtered value\r\n   */\r\n  get filteredValue(): unknown {\r\n    let value = this.value;\r\n    for (let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  \r\n  /**\r\n   * Sets checked state by comparing binding value with filteredValue.\r\n   * Converts null/undefined to empty string for comparison.\r\n   * \r\n   * @param value - Value from state binding\r\n   */\r\n  assignValue(rawValue: unknown) {\r\n    let value;\r\n    if (rawValue === null || rawValue === undefined) {\r\n      value = \"\";\r\n    } else {\r\n      value = rawValue;\r\n    }\r\n    \r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value === this.filteredValue;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate radio button binding node.\r\n * \r\n * @param name - Binding name\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators (event name or \"readonly\"/\"ro\")\r\n * @returns Function that creates BindingNodeRadio with binding, node, and filters\r\n */\r\nexport const createBindingNodeRadio: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      return new BindingNodeRadio(binding, node, name, \"\", filterFns, decorates);\r\n    }\r\n\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeStyle class implements binding processing for style attributes.\r\n * - Extracts CSS property name (subName) from name and sets value with style.setProperty\r\n * - Converts null/undefined/NaN to empty string\r\n */\r\nclass BindingNodeStyle extends BindingNode {\r\n  /**\r\n   * Sets CSS property value. Converts null/undefined/NaN to empty string.\r\n   * \r\n   * @param value - Value to assign to CSS property\r\n   */\r\n  assignValue(value: unknown) {\r\n    const element = this.node as HTMLElement;\r\n    const stringValue = \r\n      value === null || \r\n      value === undefined || \r\n      (typeof value === \"number\" && Number.isNaN(value))\r\n        ? \"\"\r\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string\r\n        : String(value);\r\n\r\n    element.style.setProperty(this.subName, stringValue.toString());\r\n  }\r\n}\r\n\r\nconst subNameByName: Record<string, string> = {};\r\n\r\n/**\r\n * Factory function to generate style attribute binding node.\r\n * \r\n * @param name - Binding name (e.g., \"style.color\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeStyle with binding, node, and filters\r\n */\r\nexport const createBindingNodeStyle: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      const subName = subNameByName[name] ?? (subNameByName[name] = name.split(\".\")[1]);\r\n      return new BindingNodeStyle(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","const symbolName = \"component-state-input\";\r\n\r\nexport const AssignStateSymbol: unique symbol = Symbol.for(`${symbolName}.AssignState`);\r\nexport const NotifyRedrawSymbol: unique symbol = Symbol.for(`${symbolName}.NotifyRedraw`);","import { StructiveComponent } from \"./types\";\r\n\r\n/**\r\n * WeakMap storing parent-child relationships between Structive components.\r\n * Uses WeakMap to allow automatic garbage collection when components are destroyed.\r\n */\r\nconst parentStructiveComponentByStructiveComponent = new WeakMap<StructiveComponent, StructiveComponent>();\r\n\r\n/**\r\n * Finds the parent Structive component for a given component.\r\n * Returns the registered parent component or null if none exists.\r\n * \r\n * @param {StructiveComponent} el - The component to find the parent for\r\n * @returns {StructiveComponent | null} The parent component or null if not found\r\n * \r\n * @example\r\n * const parent = findStructiveParent(childComponent);\r\n * if (parent) {\r\n *   // Access parent component\r\n * }\r\n */\r\nexport function findStructiveParent(el:StructiveComponent): StructiveComponent | null {\r\n  return parentStructiveComponentByStructiveComponent.get(el) ?? null;\r\n}\r\n\r\n/**\r\n * Registers a parent-child relationship between two Structive components.\r\n * This allows child components to access their parent via findStructiveParent.\r\n * \r\n * @param {StructiveComponent} parentComponent - The parent component\r\n * @param {StructiveComponent} component - The child component to register\r\n * @returns {void}\r\n * \r\n * @example\r\n * registerStructiveComponent(parentComponent, childComponent);\r\n */\r\nexport function registerStructiveComponent(parentComponent: StructiveComponent, component: StructiveComponent): void {\r\n  parentStructiveComponentByStructiveComponent.set(component, parentComponent);\r\n}\r\n\r\n/**\r\n * Removes a component from the parent-child relationship registry.\r\n * Called during component cleanup/disconnection to prevent memory leaks.\r\n * \r\n * @param {StructiveComponent} component - The component to remove from registry\r\n * @returns {void}\r\n * \r\n * @example\r\n * removeStructiveComponent(component); // Called in disconnectedCallback\r\n */\r\nexport function removeStructiveComponent(component: StructiveComponent): void {\r\n  parentStructiveComponentByStructiveComponent.delete(component);\r\n}","import { raiseError } from \"../utils\";\r\n\r\n/**\r\n * Retrieves the custom element tag name from an HTMLElement.\r\n * \r\n * Handles both autonomous custom elements (tag names with hyphens like <my-element>)\r\n * and customized built-in elements (standard elements with 'is' attribute like <button is=\"my-button\">).\r\n * \r\n * @param {HTMLElement} component - The HTML element to extract the tag name from\r\n * @returns {string} The custom element tag name in lowercase\r\n * @throws {Error} COMP-401 - When neither the tag name nor 'is' attribute contains a hyphen\r\n * \r\n * @example\r\n * // Autonomous custom element\r\n * const tagName = getCustomTagName(document.querySelector('my-element'));\r\n * // Returns: 'my-element'\r\n * \r\n * @example\r\n * // Customized built-in element\r\n * const tagName = getCustomTagName(document.querySelector('[is=\"my-button\"]'));\r\n * // Returns: 'my-button'\r\n */\r\nexport function getCustomTagName(component: HTMLElement): string {\r\n  // Check if it's an autonomous custom element (tag name contains hyphen)\r\n  if (component.tagName.includes('-')) {\r\n    return component.tagName.toLowerCase();\r\n  }\r\n\r\n  const isAttribute = component.getAttribute('is');\r\n  // Check if it's a customized built-in element (has 'is' attribute with hyphen)\r\n  if (isAttribute?.includes('-')) {\r\n    return isAttribute.toLowerCase();\r\n  }\r\n  // Neither format found - not a valid custom element\r\n  raiseError({\r\n    code: 'COMP-401',\r\n    message: 'Custom element tag name not found',\r\n    context: {\r\n      where: 'WebComponents.getCustomTagName',\r\n      tagName: component.tagName,\r\n      isAttribute: isAttribute ?? null,\r\n    },\r\n    docsUrl: './docs/error-codes.md#comp',\r\n  });\r\n\r\n}","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { NotifyRedrawSymbol } from \"../../ComponentStateInput/symbols.js\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { registerStructiveComponent, removeStructiveComponent } from \"../../WebComponents/findStructiveParent.js\";\r\nimport { getCustomTagName } from \"../../WebComponents/getCustomTagName.js\";\r\nimport { StructiveComponent } from \"../../WebComponents/types\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeComponent class implements binding processing to StructiveComponent (custom component).\r\n *\r\n * Responsibilities:\r\n * - Binds parent component state to child component state property\r\n * - Propagates state changes via NotifyRedrawSymbol\r\n * - Manages parent-child component relationships and lifecycle\r\n *\r\n * @throws COMP-401 Custom element tag name not found: When tag name cannot be determined\r\n */\r\nclass BindingNodeComponent extends BindingNode {\r\n  tagName: string;\r\n  \r\n  /**\r\n   * Determines custom element tag name from element's tagName or is attribute.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param node - Custom element node\r\n   * @param name - Binding name\r\n   * @param subName - Sub-property name (component state property)\r\n   * @param filters - Filter functions to apply\r\n   * @param decorates - Array of decorators\r\n  * @throws COMP-401 Custom element tag name not found\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    node: Node, \r\n    name: string,\r\n    subName: string,\r\n    filters: Filters,\r\n    decorates: string[]\r\n  ) {\r\n    super(binding, node, name, subName, filters, decorates);\r\n    \r\n    const element = this.node as HTMLElement;\r\n    if (element.tagName.includes(\"-\")) {\r\n      this.tagName = element.tagName.toLowerCase();\r\n    } \r\n    else if (element.getAttribute(\"is\")?.includes(\"-\")) {\r\n      this.tagName = element.getAttribute(\"is\")!.toLowerCase();\r\n    } \r\n    else {\r\n      raiseError({\r\n        code: 'COMP-401',\r\n        message: 'Custom element tag name not found',\r\n        context: { where: 'BindingNodeComponent.constructor' },\r\n        docsUrl: './docs/error-codes.md#comp',\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends redraw notification to child component after custom element is defined.\r\n   * \r\n   * @param refs - Array of state property references to notify\r\n   */\r\n  _notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    const component = this.node as StructiveComponent;\r\n    const tagName = getCustomTagName(component);\r\n    customElements.whenDefined(tagName).then(() => {\r\n      component.state[NotifyRedrawSymbol](refs);\r\n    }).catch((e: unknown) => {\r\n      const cause = e instanceof Error ? e : new Error(String(e));\r\n      raiseError({\r\n        code: 'COMP-402',\r\n        message: `Custom element definition failed: ${tagName}`,\r\n        context: { where: 'BindingNodeComponent._notifyRedraw', tagName },\r\n        docsUrl: './docs/error-codes.md#comp',\r\n        cause,\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Filters and propagates only related references to child component.\r\n   * Skips refs that:\r\n   * 1. Match this binding's pattern (already processed by applyChange)\r\n   * 2. Are not in cumulative path set\r\n   * 3. Have mismatched loop indices\r\n   * \r\n   * @param refs - Array of state property references to filter and propagate\r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    const notifyRefs: IStatePropertyRef[] = [];\r\n    const compRef = this.binding.bindingState.ref;\r\n    const listIndex = compRef.listIndex;\r\n    const atIndex = (listIndex?.length ?? 0) - 1;\r\n    \r\n    for(const ref of refs) {\r\n      if (ref.info.pattern === compRef.info.pattern) {\r\n        continue;\r\n      }\r\n      if (!ref.info.cumulativePathSet.has(compRef.info.pattern)) {\r\n        continue;\r\n      }\r\n      if (atIndex >= 0) {\r\n        if (ref.listIndex?.at(atIndex) !== listIndex) {\r\n          continue;\r\n        }\r\n      }\r\n      notifyRefs.push(ref);\r\n    }\r\n    \r\n    if (notifyRefs.length === 0) {\r\n      return;\r\n    }\r\n    this._notifyRedraw(notifyRefs);\r\n  }\r\n\r\n  /**\r\n   * Notifies child component of this binding's state change.\r\n   * \r\n   * @param renderer - Renderer instance\r\n   */\r\n  applyChange(_renderer: IRenderer): void {\r\n    this._notifyRedraw([this.binding.bindingState.ref]);\r\n  }\r\n\r\n  /**\r\n   * Registers parent-child component relationship and adds binding to tracking structures.\r\n   */\r\n  activate(): void {\r\n    const engine = this.binding.engine;\r\n    const parentComponent = engine.owner;\r\n    const component = this.node as StructiveComponent;\r\n\r\n    const tagName = getCustomTagName(component);\r\n    customElements.whenDefined(tagName).then(() => {\r\n      parentComponent.registerChildComponent(component);\r\n      component.stateBinding.addBinding(this.binding);\r\n    }).catch((e: unknown) => {\r\n      const cause = e instanceof Error ? e : new Error(String(e));\r\n      raiseError({\r\n        code: 'COMP-402',\r\n        message: `Custom element definition failed: ${tagName}`,\r\n        context: { where: 'BindingNodeComponent.activate', tagName },\r\n        docsUrl: './docs/error-codes.md#comp',\r\n        cause,\r\n      });\r\n    });\r\n\r\n    registerStructiveComponent(parentComponent, component);\r\n    \r\n    let bindings = engine.bindingsByComponent.get(component);\r\n    if (typeof bindings === \"undefined\") {\r\n      engine.bindingsByComponent.set(component, bindings = new Set<IBinding>());\r\n    }\r\n    bindings.add(this.binding);\r\n  }\r\n\r\n  /**\r\n   * Unregisters component relationships and cleans up binding tracking.\r\n   */\r\n  inactivate(): void {\r\n    const engine = this.binding.engine;\r\n    removeStructiveComponent(this.node as StructiveComponent);\r\n    \r\n    const bindings = engine.bindingsByComponent.get(this.node as StructiveComponent);\r\n    if (typeof bindings !== \"undefined\") {\r\n      bindings.delete(this.binding);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nconst subNameByName: Record<string, string> = {};\r\n\r\n/**\r\n * Factory function to generate component binding node.\r\n * \r\n * @param name - Binding name (e.g., \"component.stateProp\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @param decorates - Array of decorators\r\n * @returns Function that creates BindingNodeComponent with binding, node, and filters\r\n */\r\nexport const createBindingNodeComponent: CreateBindingNodeFn = \r\n  (name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n    (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      const subName = subNameByName[name] ?? (subNameByName[name] = name.split(\".\")[1]);\r\n      return new BindingNodeComponent(binding, node, name, subName, filterFns, decorates);\r\n    }\r\n","import { createBindingNodeAttribute } from \"../DataBinding/BindingNode/BindingNodeAttribute.js\";\r\nimport { createBindingNodeCheckbox } from \"../DataBinding/BindingNode/BindingNodeCheckbox.js\";\r\nimport { createBindingNodeClassList } from \"../DataBinding/BindingNode/BindingNodeClassList.js\";\r\nimport { createBindingNodeClassName } from \"../DataBinding/BindingNode/BindingNodeClassName.js\";\r\nimport { createBindingNodeEvent } from \"../DataBinding/BindingNode/BindingNodeEvent.js\";\r\nimport { createBindingNodeIf } from \"../DataBinding/BindingNode/BindingNodeIf.js\";\r\nimport { createBindingNodeFor } from \"../DataBinding/BindingNode/BindingNodeFor.js\";\r\nimport { createBindingNodeProperty } from \"../DataBinding/BindingNode/BindingNodeProperty.js\";\r\nimport { createBindingNodeRadio } from \"../DataBinding/BindingNode/BindingNodeRadio.js\";\r\nimport { createBindingNodeStyle } from \"../DataBinding/BindingNode/BindingNodeStyle.js\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn } from \"../DataBinding/BindingNode/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\nimport { createBindingNodeComponent } from \"../DataBinding/BindingNode/BindingNodeComponent.js\";\r\n\r\n/**\r\n * Map of binding node creator functions keyed by property name\r\n */\r\ntype NodePropertyConstructorByName = { [key: string]: CreateBindingNodeFn };\r\n\r\n/**\r\n * Two-level map with comment node flag (0=Element, 1=Comment) as key,\r\n * containing property name maps\r\n */\r\ntype NodePropertyConstructorByNameByIsComment = { [key: number]: NodePropertyConstructorByName };\r\n\r\n/**\r\n * Map defining specific binding node creator functions by combination of\r\n * node type (Element/Comment) and property name\r\n * \r\n * Index 0 (Element): Element-specific bindings\r\n *   - \"class\": classList manipulation (class attribute token list operations)\r\n *   - \"checkbox\": Checkbox checked state binding\r\n *   - \"radio\": Radio button checked state binding\r\n * \r\n * Index 1 (Comment): Comment node-specific bindings\r\n *   - \"if\": Conditional binding (element show/hide)\r\n */\r\nconst nodePropertyConstructorByNameByIsComment: NodePropertyConstructorByNameByIsComment = {\r\n  0: {\r\n    \"class\"   : createBindingNodeClassList,\r\n    \"checkbox\": createBindingNodeCheckbox,\r\n    \"radio\"   : createBindingNodeRadio,\r\n  },\r\n  1: {\r\n    \"if\" : createBindingNodeIf,\r\n  },\r\n};\r\n\r\n/**\r\n * Map of binding node creator functions keyed by property name prefix\r\n */\r\ntype NodePropertyConstructorByFirstName = { [key: string]: CreateBindingNodeFn };\r\n\r\n/**\r\n * Map of binding node creator functions determined by property name prefix\r\n * (first element before dot separator)\r\n * \r\n * Supported patterns:\r\n *   - \"class.xxx\": className binding (set entire class attribute)\r\n *   - \"attr.xxx\": attribute binding (set arbitrary attribute)\r\n *   - \"style.xxx\": style binding (set inline style)\r\n *   - \"state.xxx\": component state binding (pass state to child component)\r\n * \r\n * Examples:\r\n *   - \"class.active\" → BindingNodeClassName (set class attribute to \"active\")\r\n *   - \"attr.src\" → BindingNodeAttribute (set src attribute)\r\n *   - \"style.color\" → BindingNodeStyle (set color style)\r\n *   - \"state.user\" → BindingNodeComponent (pass value to child component's user state)\r\n */\r\nconst nodePropertyConstructorByFirstName: NodePropertyConstructorByFirstName = {\r\n  \"class\": createBindingNodeClassName,\r\n  \"attr\" : createBindingNodeAttribute,\r\n  \"style\": createBindingNodeStyle,\r\n  \"state\": createBindingNodeComponent,\r\n//  \"popover\": PopoverTarget,      // For future extension\r\n//  \"commandfor\": CommandForTarget, // For future extension\r\n};\r\n\r\n/**\r\n * Internal function that returns the appropriate binding node creator function\r\n * (CreateBindingNodeFn) based on target node type (Element/Comment) and property name.\r\n * \r\n * Decision logic (in priority order):\r\n * 1. Exact match by node type and property name (nodePropertyConstructorByNameByIsComment)\r\n *    - Element: \"class\", \"checkbox\", \"radio\"\r\n *    - Comment: \"if\"\r\n * \r\n * 2. Comment node with \"for\" → createBindingNodeFor\r\n * \r\n * 3. Comment node with unknown property → Error\r\n * \r\n * 4. Match by property name prefix (nodePropertyConstructorByFirstName)\r\n *    - \"class.xxx\", \"attr.xxx\", \"style.xxx\", \"state.xxx\"\r\n * \r\n * 5. Element node starting with \"on\" → createBindingNodeEvent\r\n *    - Examples: \"onclick\", \"onchange\", \"onkeydown\"\r\n * \r\n * 6. Others → createBindingNodeProperty (generic property binding)\r\n *    - Examples: \"value\", \"textContent\", \"disabled\", \"innerHTML\"\r\n * \r\n * @param isComment - Whether it's a comment node\r\n * @param isElement - Whether it's an element node\r\n * @param propertyName - Binding property name\r\n * @returns Binding node creator function\r\n * @throws When property name is invalid\r\n */\r\nfunction _getBindingNodeCreator(isComment: boolean, isElement: boolean, propertyName: string): CreateBindingNodeFn {\r\n  // Step 1: Get dedicated creator function by exact match of node type and property name\r\n  const bindingNodeCreatorByName = nodePropertyConstructorByNameByIsComment[isComment ? 1 : 0][propertyName];\r\n  if (typeof bindingNodeCreatorByName !== \"undefined\") {\r\n    return bindingNodeCreatorByName;\r\n  }\r\n\r\n  // Step 2: For comment node with \"for\", use dedicated loop binding\r\n  if (isComment && propertyName === \"for\") {\r\n    return createBindingNodeFor;\r\n  }\r\n\r\n  // Step 3: Error for unsupported properties on comment node\r\n  // (Only \"if\" and \"for\" are allowed on comment nodes)\r\n  if (isComment) {\r\n    raiseError({\r\n      code: \"BIND-106\",\r\n      message: `Comment binding property not supported: ${propertyName}`,\r\n      context: {\r\n        where: \"BindingBuilder.getBindingNodeCreator\",\r\n        propertyName,\r\n        nodeType: \"Comment\",\r\n      },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n  }\r\n\r\n  // Step 4: Determine by property name prefix (first part before dot)\r\n  // Example: \"attr.src\" → nameElements[0] = \"attr\"\r\n  const nameElements = propertyName.split(\".\");\r\n  const bindingNodeCreatorByFirstName = nodePropertyConstructorByFirstName[nameElements[0]];\r\n  if (typeof bindingNodeCreatorByFirstName !== \"undefined\") {\r\n    return bindingNodeCreatorByFirstName;\r\n  }\r\n\r\n  // Step 5: For element node starting with \"on\", use event binding\r\n  // Examples: \"onclick\", \"onchange\", \"onsubmit\"\r\n  if (isElement) {\r\n    if (propertyName.startsWith(\"on\")) {\r\n      return createBindingNodeEvent;\r\n    } else {\r\n      // Step 6a: Other element properties use generic property binding\r\n      // Examples: \"value\", \"textContent\", \"disabled\"\r\n      return createBindingNodeProperty;\r\n    }\r\n  } else {\r\n    // Step 6b: For nodes that are neither element nor comment (Text nodes, etc.), use generic binding\r\n    return createBindingNodeProperty;\r\n  }\r\n}\r\n\r\n/**\r\n * Cache for binding node creator functions\r\n * Key format: \"{isComment}\\t{isElement}\\t{propertyName}\"\r\n * \r\n * When the same combination of node type and property name is used multiple times,\r\n * retrieve from cache instead of re-executing decision logic to improve performance\r\n */\r\nconst _cache: { [key: string]: CreateBindingNodeFn } = {};\r\n\r\n/**\r\n * Factory function that retrieves the appropriate binding node creator function\r\n * from node, property name, filter, and decorator information.\r\n * \r\n * Processing flow:\r\n * 1. Determine node type (Comment/Element)\r\n * 2. Generate cache key (\"{isComment}\\t{isElement}\\t{propertyName}\")\r\n * 3. Check cache, if not exists, get via _getBindingNodeCreator and cache it\r\n * 4. Execute obtained creator function with property name, filters, and decorates\r\n * 5. Return actual binding node creator function (CreateBindingNodeByNodeFn)\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * const node = document.querySelector('input');\r\n * const creator = getBindingNodeCreator(\r\n *   node,\r\n *   'value',\r\n *   [{ name: 'trim', options: [] }],\r\n *   ['required']\r\n * );\r\n * // creator is a function like (binding, node, filters) => BindingNodeProperty\r\n * ```\r\n * \r\n * @param node - Target DOM node for binding\r\n * @param propertyName - Binding property name (e.g., \"value\", \"onclick\", \"attr.src\")\r\n * @param filterTexts - Array of input filter metadata\r\n * @param decorates - Array of decorators (e.g., [\"required\", \"trim\"])\r\n * @returns Function that creates actual binding node instance\r\n */\r\nexport function getBindingNodeCreator(\r\n  node        : Node, \r\n  propertyName: string,\r\n  filterTexts : IFilterText[],\r\n  decorates   : string[]\r\n): CreateBindingNodeByNodeFn {\r\n  // Determine node type\r\n  const isComment = node instanceof Comment;\r\n  const isElement = node instanceof Element;\r\n  \r\n  // Generate cache key (concatenate with tab separator)\r\n  const key = `${isComment  }\\t${  isElement  }\\t${  propertyName}`;\r\n  \r\n  // Get from cache, if not exists, determine and save to cache\r\n  const fn = _cache[key] ?? (_cache[key] = _getBindingNodeCreator(isComment, isElement, propertyName));\r\n  \r\n  // Execute obtained creator function with property name, filters, and decorates\r\n  return fn(propertyName, filterTexts, decorates);\r\n}\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { ILoopContext } from \"../../LoopContext/types.js\";\r\nimport { getByRef } from \"../../StateClass/methods/getByRef.js\";\r\nimport { setByRef } from \"../../StateClass/methods/setByRef.js\";\r\nimport { IStateHandler, IStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\ninterface IBindingStateInternal {\r\n  readonly pattern: string;\r\n  readonly info: IStructuredPathInfo;\r\n  readonly nullRef: IStatePropertyRef | null;\r\n}\r\n\r\nclass BindingStateInternal implements IBindingStateInternal {\r\n  readonly pattern: string\r\n  readonly info: IStructuredPathInfo;\r\n  readonly nullRef: IStatePropertyRef | null;\r\n  constructor(pattern: string) {\r\n    this.pattern = pattern;\r\n    this.info = getStructuredPathInfo(pattern);\r\n    this.nullRef = (this.info.wildcardCount === 0) ? getStatePropertyRef(this.info, null) : null;\r\n  }\r\n}\r\n\r\nconst bindingStateInternalByPattern: Record<string, IBindingStateInternal> = {};\r\n\r\n/**\r\n * BindingState class manages state property access, filtering, and updates for bindings.\r\n * - Supports wildcard paths for array bindings with dynamic index resolution\r\n * - Handles bidirectional binding via assignValue\r\n */\r\nclass BindingState implements IBindingState {\r\n  readonly filters: Filters;\r\n  readonly isLoopIndex: boolean = false;\r\n  readonly pattern: string;\r\n  readonly info: IStructuredPathInfo;\r\n\r\n  private readonly _internal: IBindingStateInternal;\r\n  private readonly _binding: IBinding;\r\n  private _ref: IStatePropertyRef | null = null;\r\n  private _loopContext: ILoopContext | null = null;\r\n\r\n  /**\r\n   * Constructor initializes BindingState for property binding.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param pattern - State property pattern (e.g., \"user.name\", \"items.*.value\")\r\n   * @param filters - Filter functions to apply\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this._internal = bindingStateInternalByPattern[pattern] ?? \r\n      (bindingStateInternalByPattern[pattern] = new BindingStateInternal(pattern));\r\n    this._binding = binding;\r\n    this.filters = filters;\r\n    this.pattern = pattern;\r\n    this.info = this._internal.info;\r\n    this._ref = this._internal.nullRef;\r\n  }\r\n\r\n  /**\r\n   * Returns list index from state property reference.\r\n   * \r\n   * @returns IListIndex or null\r\n   */\r\n  get listIndex() {\r\n    return this.ref.listIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns state property reference, dynamically resolved for wildcard paths.\r\n   * \r\n   * @returns IStatePropertyRef instance\r\n   * @throws BIND-201 LoopContext is null or ref is null\r\n   */\r\n  get ref(): IStatePropertyRef {\r\n    if (this._ref === null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ref is null',\r\n        context: {\r\n          where: 'BindingState.ref',\r\n          pattern: this.pattern,\r\n          wildcardCount: this.info.wildcardCount,\r\n        },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    return this._ref;\r\n  }\r\n\r\n  /**\r\n   * Retrieves raw value from state without applying filters.\r\n   * \r\n   * @param state - State proxy\r\n   * @param handler - State handler\r\n   * @returns Raw value from state\r\n   */\r\n  getValue(state:IStateProxy, handler:IStateHandler): unknown {\r\n    return getByRef(this._binding.engine.state, this.ref, state, handler);\r\n  }\r\n\r\n  /**\r\n   * Retrieves value from state and applies all filters.\r\n   * \r\n   * @param state - State proxy\r\n   * @param handler - State handler\r\n   * @returns Filtered value\r\n   */\r\n  getFilteredValue(state:IStateProxy, handler:IStateHandler): unknown {\r\n    let value = getByRef(this._binding.engine.state, this.ref, state, handler);\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Assigns value to state (for bidirectional binding).\r\n   * \r\n   * @param writeState - Writable state proxy\r\n   * @param handler - Writable state handler\r\n   * @param value - Value to assign\r\n   */\r\n  assignValue(writeState: IWritableStateProxy, handler: IWritableStateHandler, value: unknown) {\r\n    setByRef(this._binding.engine.state, this.ref, value, writeState, handler);\r\n  }\r\n\r\n  /**\r\n   * Activates binding. Resolves loop context for wildcard bindings.\r\n   * \r\n   * @throws BIND-201 Wildcard last parentPath is null or LoopContext is null\r\n   */\r\n  activate(): void {\r\n    if (this.info.wildcardCount > 0) {\r\n      const baseContext = {\r\n        where: 'BindingState.activate',\r\n        pattern: this.pattern,\r\n      } as const;\r\n      const lastWildcardPath = this.info.lastWildcardPath ?? \r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'Wildcard last parentPath is null',\r\n          context: baseContext,\r\n          docsUrl: './docs/error-codes.md#bind',\r\n        });\r\n      this._loopContext = this._binding.parentBindContent.currentLoopContext?.find(lastWildcardPath) ?? \r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'LoopContext is null',\r\n          context: {\r\n            ...baseContext,\r\n            lastWildcardPath,\r\n          },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n        });\r\n      this._ref = getStatePropertyRef(this.info, this._loopContext.listIndex);\r\n    }\r\n    if (this._binding.bindingNode.renderable) {\r\n      this._binding.engine.saveBinding(this.ref, this._binding);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inactivates binding and clears references.\r\n   */\r\n  inactivate() {\r\n    this._binding.engine.removeBinding(this.ref, this._binding);\r\n    this._ref = this._internal.nullRef;\r\n    this._loopContext = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate BindingState instance.\r\n * \r\n * @param name - State property pattern\r\n * @param filterTexts - Array of filter text definitions\r\n * @returns Function that creates BindingState with binding and filters\r\n */\r\nexport const createBindingState: CreateBindingStateFn = \r\n  (name: string, filterTexts: IFilterText[]) => \r\n    (binding:IBinding, filters:FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      return new BindingState(binding, name, filterFns);\r\n    }\r\n","import { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { ILoopContext } from \"../../LoopContext/types.js\";\r\nimport { IStateHandler, IStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindingFilters } from \"../BindingFilter.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\ninterface IBindingStateIndexInternal {\r\n  readonly pattern: string;\r\n  readonly indexNumber: number;\r\n}\r\n\r\nclass BindingStateIndexInternal implements IBindingStateIndexInternal {\r\n  readonly pattern: string;\r\n  readonly indexNumber: number;\r\n  constructor(pattern: string) {\r\n    this.pattern = pattern;\r\n    const indexNumber = Number(pattern.slice(1));\r\n    if (isNaN(indexNumber)) {\r\n      raiseError({\r\n        code: 'BIND-202',\r\n        message: 'Pattern is not a number',\r\n        context: { where: 'BindingStateIndex.constructor', pattern },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    this.indexNumber = indexNumber;\r\n  }\r\n}\r\n\r\nconst bindingStateIndexInternalByPattern: Record<string, IBindingStateIndexInternal> = {};\r\n\r\n/**\r\n * BindingStateIndex manages binding state for loop index values ($1, $2, ...).\r\n * - Extracts index from loop context, supports filtering\r\n * - Read-only (assignValue not implemented)\r\n */\r\nclass BindingStateIndex implements IBindingState {\r\n  readonly filters: Filters;\r\n\r\n  private _internal: IBindingStateIndexInternal;\r\n  private _binding: IBinding;\r\n  private _loopContext: ILoopContext | null = null;\r\n\r\n  /**\r\n   * Constructor initializes BindingStateIndex for loop index binding.\r\n   * \r\n   * @param binding - Parent IBinding instance\r\n   * @param pattern - Index pattern string (e.g., \"$1\", \"$2\")\r\n   * @param filters - Filter functions to apply\r\n   * @throws BIND-202 Pattern is not a number\r\n   */\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this._binding = binding;\r\n    this._internal = bindingStateIndexInternalByPattern[pattern] ?? \r\n      (bindingStateIndexInternalByPattern[pattern] = new BindingStateIndexInternal(pattern));\r\n    this.filters = filters;\r\n  }\r\n\r\n  private createContext(where: string, extra: Record<string, unknown> = {}) {\r\n    return {\r\n      where,\r\n      pattern: this._internal.pattern,\r\n      indexNumber: this._internal.indexNumber,\r\n      ...extra,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Not implemented for index binding.\r\n   * \r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  get pattern(): string {\r\n    return raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Binding pattern not implemented',\r\n      context: this.createContext('BindingStateIndex.pattern'),\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  /**\r\n   * Not implemented for index binding.\r\n   * \r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  get info() {\r\n    return raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Binding info not implemented',\r\n      context: this.createContext('BindingStateIndex.info'),\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns list index from current loop context.\r\n   * \r\n   * @returns IListIndex instance\r\n   * @throws LIST-201 listIndex is null\r\n   */\r\n  get listIndex() {\r\n    return this._loopContext?.listIndex ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: this.createContext('BindingStateIndex.listIndex'),\r\n      docsUrl: './docs/error-codes.md#list',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns state property reference from loop context.\r\n   * \r\n   * @returns IStatePropertyRef instance\r\n   * @throws STATE-202 ref is null\r\n   */\r\n  get ref() {\r\n    return this._loopContext?.ref ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'ref is null',\r\n      context: this.createContext('BindingStateIndex.ref'),\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Always returns true for index binding.\r\n   * \r\n   * @returns true\r\n   */\r\n  get isLoopIndex() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns raw index value from list index.\r\n   * \r\n   * @param state - State proxy (unused)\r\n   * @param handler - State handler (unused)\r\n   * @returns Index number\r\n   * @throws LIST-201 listIndex is null\r\n   */\r\n  getValue(_state: IStateProxy, _handler: IStateHandler): number {\r\n    return this.listIndex?.index ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: this.createContext('BindingStateIndex.getValue'),\r\n      docsUrl: './docs/error-codes.md#list',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns filtered index value.\r\n   * \r\n   * @param state - State proxy (unused)\r\n   * @param handler - State handler (unused)\r\n   * @returns Filtered index value\r\n   * @throws LIST-201 listIndex is null\r\n   */\r\n  getFilteredValue(_tate: IStateProxy, _handler: IStateHandler): unknown {\r\n    let value: unknown = this.listIndex?.index ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: this.createContext('BindingStateIndex.getFilteredValue'),\r\n      docsUrl: './docs/error-codes.md#list',\r\n    });\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n\r\n  /**\r\n   * Not implemented (index is read-only).\r\n   * \r\n   * @param writeState - Writable state proxy (unused)\r\n   * @param handler - Writable state handler (unused)\r\n   * @param value - Value to assign (unused)\r\n   * @throws BIND-301 Not implemented\r\n   */\r\n  assignValue(_writeState:IWritableStateProxy, _handler:IWritableStateHandler, _value:unknown): void {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Binding assignValue not implemented',\r\n      context: this.createContext('BindingStateIndex.assignValue'),\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Activates binding. Resolves loop context and registers to bindingsByListIndex.\r\n   * \r\n   * @throws BIND-201 LoopContext is null or binding for list is null\r\n   */\r\n  activate(): void {\r\n    const baseContext = this.createContext('BindingStateIndex.activate');\r\n    const loopContext = this._binding.parentBindContent.currentLoopContext ??\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'LoopContext is null',\r\n        context: baseContext,\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    const loopContexts = loopContext.serialize();\r\n    this._loopContext = loopContexts[this._internal.indexNumber - 1] ??\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Current loopContext is null',\r\n        context: this.createContext('BindingStateIndex.activate', {\r\n          serializedIndex: this._internal.indexNumber - 1,\r\n          serializedLength: loopContexts.length,\r\n        }),\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    const bindingForList = this._loopContext.bindContent?.parentBinding ?? null;\r\n    if (bindingForList === null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Binding for list is null',\r\n        context: baseContext,\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    const bindings = bindingForList.bindingsByListIndex.get(this.listIndex);\r\n    if (typeof bindings === \"undefined\") {\r\n      bindingForList.bindingsByListIndex.set(this.listIndex, new Set([this._binding]));\r\n    } else {\r\n      bindings.add(this._binding);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inactivates binding and clears loop context reference.\r\n   */\r\n  inactivate(): void {\r\n    this._loopContext = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate BindingStateIndex instance.\r\n * \r\n * @param name - Index pattern string (e.g., \"$1\", \"$2\")\r\n * @param filterTexts - Array of filter text definitions\r\n * @returns Function that creates BindingStateIndex with binding and filters\r\n */\r\nexport const createBindingStateIndex: CreateBindingStateFn = \r\n  (name: string, filterTexts: IFilterText[]) => \r\n    (binding:IBinding, filters:FilterWithOptions) => {\r\n      const filterFns = createBindingFilters(filters, filterTexts);\r\n      return new BindingStateIndex(binding, name, filterFns);\r\n    }\r\n","import { createBindingState } from \"../DataBinding/BindingState/BindingState.js\";\r\nimport { createBindingStateIndex } from \"../DataBinding/BindingState/BindingStateIndex.js\";\r\nimport { CreateBindingStateByStateFn } from \"../DataBinding/BindingState/types\";\r\nimport { IFilterText } from \"./types\";\r\n\r\n/**\r\n * Regular expression to identify index references within loop context\r\n * Pattern: \"$\" + digit (e.g., \"$1\", \"$2\", \"$3\")\r\n * \r\n * Hierarchy structure (1-based, from outer to inner):\r\n * - \"$1\": Index of outermost loop\r\n * - \"$2\": Index of one level inner loop\r\n * - \"$3\": Index of further inner loop\r\n * \r\n * Usage example (nested loops):\r\n * ```\r\n * <ul data-bind=\"for:categories\">              ← $1\r\n *   <li>\r\n *     <ul data-bind=\"for:categories.*.items\">  ← $2 (child list is property of parent list element)\r\n *       <li data-bind=\"text:$1\">...            ← categories index\r\n *       <li data-bind=\"text:$2\">...            ← items index\r\n *     </ul>\r\n *   </li>\r\n * </ul>\r\n * ```\r\n * \r\n * Note: In nested loops, child list must be defined as property of parent list element\r\n * (e.g., categories.*.items means categories[i].items)\r\n */\r\nconst ereg = new RegExp(/^\\$\\d+$/);\r\n\r\n/**\r\n * Factory function that returns the appropriate binding state creator function\r\n * (CreateBindingStateByStateFn) from target state property name and filter information.\r\n *\r\n * Decision logic:\r\n * 1. Check if property name matches \"$digit\" pattern with regex\r\n *    - If matches: Use createBindingStateIndex\r\n *      Loop index binding (e.g., $1, $2 inside for statement)\r\n *    - If not matches: Use createBindingState\r\n *      Normal state property binding (e.g., user.name)\r\n * \r\n * 2. Execute creator function with filter information\r\n * \r\n * 3. Return function that creates actual binding state instance\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Normal property binding\r\n * const creator1 = getBindingStateCreator('user.name', []);\r\n * // creator1 generates normal BindingState\r\n * \r\n * // Outermost loop index binding\r\n * const creator2 = getBindingStateCreator('$1', []);\r\n * // creator2 generates BindingStateIndex (accesses outermost loop index value)\r\n * \r\n * // Inner loop index in nested loops\r\n * const creator3 = getBindingStateCreator('$2', []);\r\n * // creator3 accesses index of one level inner loop\r\n * ```\r\n * \r\n * @param name - Target state property name (e.g., \"user.name\", \"$1\", \"$2\")\r\n * @param filterTexts - Array of output filter metadata (node→state direction)\r\n * @returns Function that creates actual binding state instance\r\n */\r\nexport function getBindingStateCreator(\r\n  name       : string, \r\n  filterTexts: IFilterText[]\r\n): CreateBindingStateByStateFn {\r\n  // Check if property name matches \"$digit\" pattern\r\n  if (ereg.test(name)) {\r\n    // Return creator function for loop index binding\r\n    // \"$1\" → Outermost loop index (1-based)\r\n    // \"$2\" → One level inner loop index\r\n    // \"$3\" → Further inner loop index\r\n    // ...and so on, proceeding inward\r\n    return createBindingStateIndex(name, filterTexts);\r\n  } else {\r\n    // Return standard binding state creator function for normal property names\r\n    // Examples: \"user.name\", \"items\", \"isVisible\"\r\n    return createBindingState(name, filterTexts);\r\n  }\r\n}","import { COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\n/**\r\n * Cache comment mark lengths (performance optimization)\r\n */\r\nconst COMMENT_EMBED_MARK_LEN = COMMENT_EMBED_MARK.length;\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * Utility function that retrieves data-bind text (binding definition string) for each node type.\r\n * Extracts binding expressions appropriately based on how mustache syntax or comment bindings\r\n * were transformed during template preprocessing.\r\n *\r\n * Processing by node type:\r\n * 1. Text: Text node restored from comment\r\n *    - Get text after COMMENT_EMBED_MARK (e.g., \"@@:\")\r\n *    - Add \"textContent:\" prefix to create binding expression\r\n *    - Example: \"@@:user.name\" → \"textContent:user.name\"\r\n * \r\n * 2. HTMLElement: Regular HTML element\r\n *    - Get data-bind attribute value as-is\r\n *    - Example: <div data-bind=\"class:active\"> → \"class:active\"\r\n * \r\n * 3. Template: Template reference comment\r\n *    - Extract template ID after COMMENT_TEMPLATE_MARK (e.g., \"@@|\")\r\n *    - Get template by ID and return its data-bind attribute value\r\n *    - Example: \"@@|123 if:isVisible\" → data-bind attribute of template 123\r\n * \r\n * 4. SVGElement: SVG element\r\n *    - Get data-bind attribute value as-is (same as HTML element)\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Text node (converted from mustache syntax)\r\n * const text = document.createTextNode(\"@@:user.name\");\r\n * getDataBindText(\"Text\", text); // → \"textContent:user.name\"\r\n * \r\n * // HTML element\r\n * const div = document.createElement(\"div\");\r\n * div.setAttribute(\"data-bind\", \"class:active\");\r\n * getDataBindText(\"HTMLElement\", div); // → \"class:active\"\r\n * \r\n * // Template reference comment\r\n * const comment = document.createComment(\"@@|123 if:isVisible\");\r\n * getDataBindText(\"Template\", comment); // → data-bind value of template 123\r\n * ```\r\n * \r\n * @param nodeType - Node type\r\n * @param node - Target node\r\n * @returns Binding definition string (may be empty string)\r\n */\r\nexport function getDataBindText(nodeType: NodeType, node: Node): string {\r\n  switch (nodeType) {\r\n    case \"Text\": {\r\n      // Case 1: Text node (converted from mustache syntax)\r\n      // Get text after comment mark (e.g., \"@@:\") and trim\r\n      // Add \"textContent:\" prefix to create binding expression\r\n      const text = node.textContent?.slice(COMMENT_EMBED_MARK_LEN).trim() ?? \"\";\r\n      return `textContent:${  text}`;\r\n    }\r\n    case \"HTMLElement\": {\r\n      // Case 2: HTMLElement (regular HTML element)\r\n      // Return data-bind attribute value as-is\r\n      // Return empty string if attribute doesn't exist\r\n      return (node as HTMLElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"Template\": {\r\n      // Case 3: Template (template reference comment node)\r\n      // Comment text format: \"@@|123 if:isVisible\" format\r\n      // Step 1: Get text after comment mark\r\n      const text = node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN).trim();\r\n      \r\n      // Step 2: Split by space and get first element as template ID\r\n      // Example: \"123 if:isVisible\" → idText = \"123\"\r\n      const [idText, ] = text?.split(' ', 2) ?? [];\r\n      const id = Number(idText);\r\n      \r\n      // Step 3: Get template element by ID\r\n      const template = getTemplateById(id);\r\n      \r\n      // Step 4: Return data-bind attribute value of template\r\n      // Binding definition that template itself has (e.g., \"if:isVisible\", \"for:items\")\r\n      return template.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"SVGElement\": {\r\n      // Case 4: SVGElement (SVG element)\r\n      // Return data-bind attribute value as-is, same as HTML element\r\n      return (node as SVGElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    default:\r\n      // Other node types (normally unreachable)\r\n      // Return empty string\r\n      return \"\";\r\n  }\r\n}","import { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\n/**\r\n * Creates cache key from node (internal function).\r\n * \r\n * Key composition:\r\n * - Constructor name (e.g., \"Comment\", \"HTMLDivElement\", \"SVGCircleElement\")\r\n * - Tab character (\"\\t\")\r\n * - For comment nodes: character at textContent[2] (\":\" or \"|\")\r\n * - For other nodes: empty string\r\n * \r\n * Examples:\r\n * - Comment(\"@@:user.name\") → \"Comment\\t:\"\r\n * - Comment(\"@@|123\") → \"Comment\\t|\"\r\n * - HTMLDivElement → \"HTMLDivElement\\t\"\r\n * - SVGCircleElement → \"SVGCircleElement\\t\"\r\n * \r\n * @param node - Node to generate key from\r\n * @returns Cache key string\r\n */\r\nconst createNodeKey = (node: Node): string => \r\n  `${node.constructor.name  }\\t${  (node instanceof Comment) ? (node.textContent?.[2] ?? \"\") : \"\"}`;\r\n\r\n/**\r\n * Cache of NodeType values keyed by node key\r\n * When the same type of node is determined multiple times, skip re-determination to improve performance\r\n */\r\ntype NodeTypeByNodeKey = {\r\n  [nodeKey: string]: NodeType;\r\n};\r\n\r\nconst nodeTypeByNodeKey: NodeTypeByNodeKey = {};\r\n\r\n/**\r\n * Internal function that actually determines NodeType from node.\r\n * \r\n * Decision logic (in priority order):\r\n * 1. Comment and textContent[2] === \":\" → \"Text\"\r\n *    - Example: \"@@:user.name\" → Text content binding\r\n * \r\n * 2. HTMLElement → \"HTMLElement\"\r\n *    - Example: <div>, <input>, <span>, etc.\r\n * \r\n * 3. Comment and textContent[2] === \"|\" → \"Template\"\r\n *    - Example: \"@@|123\" → Template reference binding\r\n * \r\n * 4. SVGElement → \"SVGElement\"\r\n *    - Example: <circle>, <path>, <rect>, etc.\r\n * \r\n * 5. Others → Error\r\n * \r\n * Note: Why HTMLElement check comes before SVGElement\r\n * → Checking HTMLElement first allows faster processing of more common cases\r\n * \r\n * @param node - Node to determine\r\n * @returns Node type\r\n * @throws When node type is unknown\r\n */\r\nconst getNodeTypeByNode = (node: Node): NodeType =>\r\n  (node instanceof Comment && node.textContent?.[2] === \":\") ? \"Text\" : \r\n  (node instanceof HTMLElement) ? \"HTMLElement\" :\r\n  (node instanceof Comment && node.textContent?.[2] === \"|\") ? \"Template\" : \r\n  (node instanceof SVGElement) ? \"SVGElement\" : \r\n  raiseError({\r\n    code: 'BIND-105',\r\n    message: `Node type not supported: ${node.nodeType}`,\r\n    context: { \r\n      where: 'BindingBuilder.getNodeType',\r\n      nodeType: node.nodeType,\r\n      nodeName: node.nodeName,\r\n      nodeConstructor: node.constructor.name\r\n    },\r\n    docsUrl: './docs/error-codes.md#bind'\r\n  });\r\n\r\n/**\r\n * Utility function that determines node type (\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\")\r\n * and uses cache for performance optimization.\r\n *\r\n * Node type determination criteria:\r\n * 1. Text: Comment node with textContent[2] === \":\"\r\n *    - Comment starting with \"@@:\" → Text content binding\r\n *    - Example: <!--@@:user.name--> → \"Text\"\r\n * \r\n * 2. Template: Comment node with textContent[2] === \"|\"\r\n *    - Comment starting with \"@@|\" → Template reference binding\r\n *    - Example: <!--@@|123--> → \"Template\"\r\n * \r\n * 3. HTMLElement: Regular HTML element\r\n *    - Example: <div>, <input>, <span> → \"HTMLElement\"\r\n * \r\n * 4. SVGElement: SVG element\r\n *    - Example: <circle>, <path>, <rect> → \"SVGElement\"\r\n * \r\n * Cache mechanism:\r\n * - Generate key from node (constructor name + comment type)\r\n * - Same key nodes return from cache on second and subsequent calls\r\n * - Performance improvement (especially when processing large number of nodes)\r\n * \r\n * Processing flow:\r\n * 1. Generate cache key from node (or get from argument)\r\n * 2. Check cache\r\n * 3. Cache hit → Return saved value\r\n * 4. Cache miss → Determine with getNodeTypeByNode, save to cache, then return\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Text binding comment\r\n * const comment1 = document.createComment(\"@@:user.name\");\r\n * getNodeType(comment1); // → \"Text\"\r\n * \r\n * // Template reference comment\r\n * const comment2 = document.createComment(\"@@|123\");\r\n * getNodeType(comment2); // → \"Template\"\r\n * \r\n * // HTML element\r\n * const div = document.createElement('div');\r\n * getNodeType(div); // → \"HTMLElement\"\r\n * \r\n * // SVG element\r\n * const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n * getNodeType(circle); // → \"SVGElement\"\r\n * ```\r\n * \r\n * @param node - Node to determine\r\n * @param nodeKey - Node key for cache (auto-generated if omitted)\r\n * @returns Node type (NodeType)\r\n */\r\nexport function getNodeType(\r\n  node   : Node, \r\n  nodeKey: string = createNodeKey(node)\r\n): NodeType {\r\n  // Check cache, if not exists, determine and save to cache\r\n  return nodeTypeByNodeKey[nodeKey] ?? (nodeTypeByNodeKey[nodeKey] = getNodeTypeByNode(node));\r\n}\r\n","import { IFilterText, IBindText } from \"./types\";\r\n\r\n/**\r\n * Helper function to trim whitespace from string\r\n */\r\nconst trim = (s: string): string => s.trim();\r\n\r\n/**\r\n * Helper function to check if string is not empty\r\n */\r\nconst has = (s: string): boolean => s.length > 0;\r\n\r\n/**\r\n * Regular expression to detect URL-encoded strings\r\n * Matches strings enclosed in \"#...#\" format\r\n */\r\nconst re = new RegExp(/^#(.*)#$/);\r\n\r\n/**\r\n * Internal function to decode filter option values.\r\n * URL-decodes if enclosed in \"#...#\", otherwise returns as-is.\r\n * \r\n * Usage examples:\r\n * - \"#Hello%20World#\" → \"Hello World\" (URL decode)\r\n * - \"100\" → \"100\" (as-is)\r\n * - \"true\" → \"true\" (as-is)\r\n * \r\n * @param s - String to decode\r\n * @returns Decoded string\r\n */\r\nconst decode = (s: string): string => {\r\n  const m = re.exec(s);\r\n  return m ? decodeURIComponent(m[1]) : s;\r\n};\r\n\r\n/**\r\n * Internal function to parse filter part.\r\n * \r\n * Parse format: \"filterName,option1,option2,...\"\r\n * \r\n * Processing flow:\r\n * 1. Split by comma\r\n * 2. Extract first element as filter name, rest as options\r\n * 3. Decode each option (URL decode if \"#...#\" format)\r\n * 4. Return as IFilterText object\r\n * \r\n * Usage examples:\r\n * - \"eq,100\" → { name: \"eq\", options: [\"100\"] }\r\n * - \"default,#Hello%20World#\" → { name: \"default\", options: [\"Hello World\"] }\r\n * - \"trim\" → { name: \"trim\", options: [] }\r\n * \r\n * @param text - Filter definition string\r\n * @returns Parsed filter information\r\n */\r\nconst parseFilter = (text: string): IFilterText => {\r\n  // Split by comma, first is filter name, rest are options\r\n  const [name, ...options] = text.split(\",\").map(trim);\r\n  return { name, options: options.map(decode) };\r\n};\r\n\r\n/**\r\n * Type definition for property parse result\r\n */\r\ntype ReturnParseStateProperty = { property: string, filters: IFilterText[] };\r\n\r\n/**\r\n * Internal function to parse property expression.\r\n * \r\n * Parse format: \"propertyName|filter1|filter2|...\"\r\n * \r\n * Processing flow:\r\n * 1. Split by pipe (|)\r\n * 2. Extract first element as property name\r\n * 3. Parse remaining elements as filters (parseFilter)\r\n * 4. Return object with property name and filter array\r\n * \r\n * Usage examples:\r\n * - \"value\" → { property: \"value\", filters: [] }\r\n * - \"value|trim\" → { property: \"value\", filters: [{ name: \"trim\", options: [] }] }\r\n * - \"value|eq,100|falsey\" → { property: \"value\", filters: [{ name: \"eq\", options: [\"100\"] }, { name: \"falsey\", options: [] }] }\r\n * \r\n * @param text - Property expression string\r\n * @returns Property name and filter array\r\n */\r\nconst parseProperty = (text: string): ReturnParseStateProperty => {\r\n  // Split by pipe, first is property name, rest are filters\r\n  const [property, ...filterTexts] = text.split(\"|\").map(trim);\r\n  return { property, filters: filterTexts.map(parseFilter) };\r\n};\r\n\r\n/**\r\n * Internal function to parse single binding expression.\r\n * \r\n * Parse format: \"nodeProperty:stateProperty@decorator1,decorator2\"\r\n * \r\n * Syntax structure:\r\n * - Colon (:): Separates node property and state property\r\n * - At-mark (@): Separates binding expression and decorators\r\n * - Pipe (|): Separates property and filters\r\n * - Comma (,): Separates decorators or filter options\r\n * \r\n * Processing flow:\r\n * 1. Split by \"@\" to separate binding expression and decorator expression\r\n * 2. Convert decorator expression to array by comma separation\r\n * 3. Split binding expression by \":\" into node property and state property\r\n * 4. Parse each property with parseProperty (extract property name and filters)\r\n * 5. Return as IBindText object\r\n * \r\n * Filter directionality:\r\n * - inputFilterTexts: State→Node direction (applied during display)\r\n * - outputFilterTexts: Node→State direction (applied during input)\r\n * \r\n * Usage examples:e examples:\r\n * ```typescript\r\n * // Basic form\r\n * \"textContent:user.name\"\r\n * → { nodeProperty: \"textContent\", stateProperty: \"user.name\", \r\n *     inputFilterTexts: [], outputFilterTexts: [], decorates: [] }\r\n * \r\n * // With filter\r\n * \"value:amount|currency,USD\"\r\n * → { nodeProperty: \"value\", stateProperty: \"amount\",\r\n *     inputFilterTexts: [{ name: \"currency\", options: [\"USD\"] }],\r\n *     outputFilterTexts: [], decorates: [] }\r\n * \r\n * // With decorator\r\n * \"value:email@required,trim\"\r\n * → { nodeProperty: \"value\", stateProperty: \"email\",\r\n *     inputFilterTexts: [], outputFilterTexts: [],\r\n *     decorates: [\"required\", \"trim\"] }\r\n * \r\n * // Combined (bidirectional filters + decorator)\r\n * \"value|trim:email|lowercase@required\"\r\n * → { nodeProperty: \"value\", stateProperty: \"email\",\r\n *     inputFilterTexts: [{ name: \"trim\", options: [] }],\r\n *     outputFilterTexts: [{ name: \"lowercase\", options: [] }],\r\n *     decorates: [\"required\"] }\r\n * ```\r\n * \r\n * @param expression - Binding expression string\r\n * @returns Parsed binding information\r\n */\r\nconst parseExpression = (expression: string): IBindText => {\r\n  // Step 1: Split by \"@\" to separate binding expression and decorator expression\r\n  const [bindExpression, decoratesExpression = null] = expression.split(\"@\").map(trim);\r\n  \r\n  // Step 2: Convert decorator expression to array by comma (empty array if not exists)\r\n  const decorates = decoratesExpression ? decoratesExpression.split(\",\").map(trim) : [];\r\n  \r\n  // Step 3: Split binding expression by \":\" into node property and state property\r\n  const [nodePropertyText, statePropertyText] = bindExpression.split(\":\").map(trim);\r\n  \r\n  // Step 4: Parse each property text to extract property name and filters\r\n  // Node property filters = inputFilterTexts (state→node direction)\r\n  const { property: nodeProperty, filters: inputFilterTexts } = parseProperty(nodePropertyText);\r\n  \r\n  // State property filters = outputFilterTexts (node→state direction)\r\n  const { property: stateProperty, filters: outputFilterTexts } = parseProperty(statePropertyText);\r\n  \r\n  // Step 5: Return as structured binding information\r\n  return { nodeProperty, stateProperty, inputFilterTexts, outputFilterTexts, decorates };\r\n};\r\n\r\n/**\r\n * Internal function to parse entire bind text (containing multiple binding expressions).\r\n * \r\n * Parse format: \"expr1;expr2;expr3\" (semicolon-separated)\r\n * \r\n * Processing flow:\r\n * 1. Split by semicolon (;)\r\n * 2. Trim each element\r\n * 3. Filter out empty strings (filter(has))\r\n * 4. Parse each expression with parseExpression\r\n * 5. Return as IBindText array\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Single binding\r\n * \"textContent:user.name\"\r\n * → [{ nodeProperty: \"textContent\", stateProperty: \"user.name\", ... }]\r\n * \r\n * // Multiple bindings\r\n * \"value:email;class:active\"\r\n * → [\r\n *     { nodeProperty: \"value\", stateProperty: \"email\", ... },\r\n *     { nodeProperty: \"class\", stateProperty: \"active\", ... }\r\n *   ]\r\n * \r\n * // With empty expressions (automatically filtered out)\r\n * \"value:name; ;class:active\"\r\n * → [\r\n *     { nodeProperty: \"value\", stateProperty: \"name\", ... },\r\n *     { nodeProperty: \"class\", stateProperty: \"active\", ... }\r\n *   ]\r\n * ```\r\n * \r\n * @param text - Entire bind text\r\n * @returns Array of parsed binding information\r\n */\r\nconst parseExpressions = (text: string): IBindText[] => {\r\n  // Split by semicolon → trim → filter empty → parse each expression\r\n  return text.split(\";\").map(trim).filter(has).map(s => parseExpression(s));\r\n};\r\n\r\n/**\r\n * Cache for parse results\r\n * When same bind text is parsed multiple times, skip re-parsing to improve performance\r\n */\r\nconst cache: { [key: string]: IBindText[] } = {};\r\n\r\n/**\r\n * Main utility function that parses bind text (string obtained from data-bind attribute or comment)\r\n * and converts it to structured binding information (IBindText[]).\r\n *\r\n * Supported syntax:\r\n * - Basic form: \"nodeProperty:stateProperty\"\r\n * - With filters: \"nodeProperty|filter1,opt1:stateProperty|filter2\"\r\n * - With decorators: \"nodeProperty:stateProperty@decorator1,decorator2\"\r\n * - Multiple bindings: \"expr1;expr2;expr3\" (semicolon-separated)\r\n * - Encoded options: \"filter,#encoded%20value#\"\r\n * \r\n * Syntax elements:\r\n * - `:` (colon): Separates node property and state property\r\n * - `|` (pipe): Separates property and filters\r\n * - `,` (comma): Separates filter options or decorators\r\n * - `@` (at-mark): Separates binding expression and decorators\r\n * - `;` (semicolon): Separates multiple binding expressions\r\n * - `#...#`: Encloses URL-encoded values\r\n * \r\n * Performance optimization:\r\n * - Caches parse results (prevents re-parsing of same text)\r\n * - Returns empty array immediately for empty string\r\n * \r\n * Processing flow:\r\n * 1. Check if input is empty string → return empty array if empty\r\n * 2. Check cache → return from cache if hit\r\n * 3. Cache miss → parse with parseExpressions\r\n * 4. Save result to cache\r\n * 5. Return parse result\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // Basic binding\r\n * parseBindText(\"textContent:user.name\");\r\n * // → [{ nodeProperty: \"textContent\", stateProperty: \"user.name\", \r\n * //      inputFilterTexts: [], outputFilterTexts: [], decorates: [] }]\r\n * \r\n * // With filter\r\n * parseBindText(\"value:amount|currency,USD,2\");\r\n * // → [{ nodeProperty: \"value\", stateProperty: \"amount\",\r\n * //      inputFilterTexts: [{ name: \"currency\", options: [\"USD\", \"2\"] }],\r\n * //      outputFilterTexts: [], decorates: [] }]\r\n * \r\n * // With decorator\r\n * parseBindText(\"value:email@required,trim\");\r\n * // → [{ nodeProperty: \"value\", stateProperty: \"email\",\r\n * //      inputFilterTexts: [], outputFilterTexts: [],\r\n * //      decorates: [\"required\", \"trim\"] }]\r\n * \r\n * // Multiple bindings\r\n * parseBindText(\"value:name;class:active\");\r\n * // → [\r\n * //   { nodeProperty: \"value\", stateProperty: \"name\", ... },\r\n * //   { nodeProperty: \"class\", stateProperty: \"active\", ... }\r\n * // ]\r\n * \r\n * // Bidirectional filters\r\n * parseBindText(\"value|trim:data.text|uppercase\");\r\n * // → [{ nodeProperty: \"value\", stateProperty: \"data.text\",\r\n * //      inputFilterTexts: [{ name: \"trim\", options: [] }],\r\n * //      outputFilterTexts: [{ name: \"uppercase\", options: [] }],\r\n * //      decorates: [] }]\r\n * \r\n * // Empty string\r\n * parseBindText(\"\");\r\n * // → []\r\n * ```\r\n * \r\n * @param text - Bind text (data-bind attribute value or comment content)\r\n * @returns Array of structured binding information\r\n */\r\nexport function parseBindText(\r\n  text: string\r\n): IBindText[] {\r\n  // Return empty array immediately for empty string (performance optimization)\r\n  if (text.trim() === \"\") {\r\n    return [];\r\n  }\r\n  \r\n  // Check cache, if not exists, parse and save to cache\r\n  return cache[text] ?? (cache[text] = parseExpressions(text));\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\n/**\r\n * Constant for data-bind attribute name\r\n */\r\nconst DATASET_BIND_PROPERTY = 'data-bind';\r\n\r\n/**\r\n * Internal function to remove data-bind attribute from Element node.\r\n * Commonly used for both HTMLElement and SVGElement.\r\n * \r\n * Processing flow:\r\n * 1. Cast node to Element type\r\n * 2. Remove data-bind attribute with removeAttribute\r\n * \r\n * @param node - Target node\r\n */\r\nconst removeAttributeFromElement = (node: Node): void => {\r\n  const element = node as Element;\r\n  element.removeAttribute(DATASET_BIND_PROPERTY);\r\n}\r\n\r\n/**\r\n * Type definition for map of attribute removal functions per node type.\r\n * Holds removal function (or undefined) corresponding to each node type.\r\n */\r\ntype RemoveAttributeByNodeType = {\r\n  [key in NodeType]: ((node: Node) => void) | undefined;\r\n}\r\n\r\n/**\r\n * Map of attribute removal functions per node type.\r\n * \r\n * Removal targets:\r\n * - HTMLElement: Remove data-bind attribute\r\n * - SVGElement: Remove data-bind attribute\r\n * \r\n * Non-removal targets:\r\n * - Text: undefined (no attributes)\r\n * - Template: undefined (template itself is not a removal target)\r\n */\r\nconst removeAttributeByNodeType: RemoveAttributeByNodeType = {\r\n  HTMLElement: removeAttributeFromElement,\r\n  SVGElement: removeAttributeFromElement,\r\n  Text: undefined,\r\n  Template: undefined,\r\n}\r\n\r\n/**\r\n * Utility function to remove data-bind attribute from specified node.\r\n *\r\n * Executes appropriate removal processing based on node type.\r\n * - HTMLElement, SVGElement: Remove data-bind attribute\r\n * - Text, Template: Do nothing (no attributes or not a removal target)\r\n * \r\n * By using optional chaining (?.),\r\n * nothing is executed if undefined, processing safely.\r\n * \r\n * Processing flow:\r\n * 1. Get removal function corresponding to nodeType from removeAttributeByNodeType\r\n * 2. Execute only if function exists (HTMLElement, SVGElement)\r\n * 3. Do nothing if function is undefined (Text, Template)\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // For HTMLElement\r\n * const div = document.createElement('div');\r\n * div.setAttribute('data-bind', 'textContent:user.name');\r\n * removeDataBindAttribute(div, 'HTMLElement');\r\n * // → data-bind attribute is removed\r\n * \r\n * // For SVGElement\r\n * const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n * svg.setAttribute('data-bind', 'class:active');\r\n * removeDataBindAttribute(svg, 'SVGElement');\r\n * // → data-bind attribute is removed\r\n * \r\n * // For Text node\r\n * const text = document.createTextNode('Hello');\r\n * removeDataBindAttribute(text, 'Text');\r\n * // → Do nothing (no attributes)\r\n * \r\n * // For Template\r\n * const template = document.createElement('template');\r\n * removeDataBindAttribute(template, 'Template');\r\n * // → Do nothing (not a removal target)\r\n * ```\r\n * \r\n * @param node - Target node\r\n * @param nodeType - Node type (\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\")\r\n */\r\nexport function removeDataBindAttribute(\r\n  node: Node,\r\n  nodeType: NodeType\r\n): void {\r\n  // Execute removal function corresponding to node type (do nothing if not exists)\r\n  return removeAttributeByNodeType[nodeType]?.(node);\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\n/**\r\n * Internal function to replace comment node with empty text node.\r\n * \r\n * Used when replacing binding comment nodes (<!-- @@:textContent:value --> etc.)\r\n * with actual text nodes for display.\r\n * \r\n * Processing flow:\r\n * 1. Create new text node with empty string\r\n * 2. Replace original comment node with parent node's replaceChild\r\n * 3. Return newly created text node\r\n * \r\n * Note: If parent node doesn't exist, replaceChild is not executed,\r\n *       but the new text node is still returned\r\n * \r\n * @param node - Comment node to replace\r\n * @returns Newly created text node\r\n */\r\nconst replaceTextNodeText = (node: Node): Node => {\r\n  // Step 1: Create empty text node\r\n  const textNode = document.createTextNode(\"\");\r\n  \r\n  // Step 2: Replace comment node in parent node\r\n  node.parentNode?.replaceChild(textNode, node);\r\n  \r\n  // Step 3: Return new text node\r\n  return textNode;\r\n}\r\n\r\n/**\r\n * Type definition for map of text node replacement functions per node type.\r\n * Holds replacement function (or undefined) corresponding to each node type.\r\n */\r\ntype ReplaceTextNodeFn = {\r\n  [key in NodeType]: ((node: Node) => Node) | undefined;\r\n}\r\n\r\n/**\r\n * Map of text node replacement functions per node type.\r\n * \r\n * Replacement target:\r\n * - Text: Replace comment node with empty text node\r\n *   (NodeType is \"Text\", but actually processes Comment node)\r\n * \r\n * Non-replacement targets:\r\n * - HTMLElement: undefined (Element nodes don't need replacement)\r\n * - Template: undefined (Template nodes don't need replacement)\r\n * - SVGElement: undefined (SVGElement nodes don't need replacement)\r\n * \r\n * Note: NodeType \"Text\" actually refers to comment nodes representing\r\n *       text content bindings (in BindingBuilder context)\r\n */\r\nconst replaceTextNodeFn: ReplaceTextNodeFn = {\r\n  Text: replaceTextNodeText,\r\n  HTMLElement: undefined,\r\n  Template: undefined,\r\n  SVGElement: undefined\r\n}\r\n\r\n/**\r\n * Utility function to replace binding comment nodes with actual display nodes.\r\n *\r\n * Used when converting text content bindings (<!-- @@:textContent:value --> etc.)\r\n * to actual DOM nodes.\r\n * \r\n * Processing by node type:\r\n * - Text (actually comment node): Replace with empty text node\r\n * - HTMLElement, SVGElement, Template: Return original node without modification\r\n * \r\n * By combining optional chaining (?.) and nullish coalescing operator (??),\r\n * - If replacement function exists: Execute function and return new node\r\n * - If replacement function is undefined: Return original node as-is\r\n * \r\n * Processing flow:\r\n * 1. Get replacement function corresponding to nodeType from replaceTextNodeFn\r\n * 2. If function exists (Text): Execute to replace comment node\r\n * 3. If function is undefined (others): Return original node\r\n * 4. Return replaced (or original) node\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * // For Text (actually comment node)\r\n * const comment = document.createComment(\"@@:textContent:user.name\");\r\n * const parent = document.createElement('div');\r\n * parent.appendChild(comment);\r\n * \r\n * const textNode = replaceTextNodeFromComment(comment, 'Text');\r\n * // → Empty text node is created and comment node is replaced\r\n * // parent.childNodes[0] === textNode (empty Text node)\r\n * \r\n * // For HTMLElement\r\n * const div = document.createElement('div');\r\n * div.setAttribute('data-bind', 'textContent:value');\r\n * \r\n * const result = replaceTextNodeFromComment(div, 'HTMLElement');\r\n * // → Original div node is returned as-is (no replacement)\r\n * // result === div\r\n * \r\n * // For SVGElement\r\n * const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n * const result = replaceTextNodeFromComment(svg, 'SVGElement');\r\n * // → Original svg node is returned as-is (no replacement)\r\n * \r\n * // For Template\r\n * const template = document.createElement('template');\r\n * const result = replaceTextNodeFromComment(template, 'Template');\r\n * // → Original template node is returned as-is (no replacement)\r\n * ```\r\n * \r\n * @param node - Target node (comment node or Element node)\r\n * @param nodeType - Node type (\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\")\r\n * @returns Replaced node (for Text) or original node (for others)\r\n */\r\nexport function replaceTextNodeFromComment(\r\n  node: Node,\r\n  nodeType: NodeType\r\n): Node {\r\n  // Execute replacement function corresponding to node type (return original node if not exists)\r\n  return replaceTextNodeFn[nodeType]?.(node) ?? node;\r\n}\r\n","import { getAbsoluteNodePath } from \"./getAbsoluteNodePath.js\";\r\nimport { getBindingNodeCreator } from \"./getBindingNodeCreator.js\";\r\nimport { getBindingStateCreator } from \"./getBindingStateCreator.js\";\r\nimport { getDataBindText } from \"./getDataBindText.js\";\r\nimport { getNodeType } from \"./getNodeType.js\";\r\nimport { parseBindText } from \"./parseBindText.js\";\r\nimport { removeDataBindAttribute } from \"./removeDataBindAttribute.js\";\r\nimport { replaceTextNodeFromComment } from \"./replaceTextNodeFromComment.js\";\r\nimport { IBindingCreator, IBindText, IDataBindAttributes, NodePath, NodeType } from \"./types\";\r\n\r\n/**\r\n * DataBindAttributes class extracts and analyzes binding information from DOM nodes,\r\n * managing all necessary data (node type, path, bind texts, creators) for binding generation.\r\n *\r\n * Main processing flow:\r\n * 1. Determine node type (HTMLElement/SVGElement/Text/Template)\r\n * 2. Extract binding expression from data-bind attribute or comment\r\n * 3. Replace comment nodes with Text nodes (restore template preprocessing)\r\n * 4. Remove processed data-bind attributes (prevent duplicate processing)\r\n * 5. Calculate absolute node path (index array from parent)\r\n * 6. Parse binding expression into structured metadata (properties, filters, decorates)\r\n * 7. Generate factory function pairs for each bind text:\r\n *    - createBindingNode: Creates runtime BindingNode instance\r\n *    - createBindingState: Creates runtime BindingState instance\r\n *\r\n * This centralizes binding definition management in templates and streamlines\r\n * subsequent binding construction processes.\r\n */\r\nclass DataBindAttributes implements IDataBindAttributes {\r\n  /** Node type classification */\r\n  readonly nodeType: NodeType;\r\n  \r\n  /** Absolute path from template root (index array) */\r\n  readonly nodePath: NodePath;\r\n  \r\n  /** Array of parsed binding expressions */\r\n  readonly bindTexts: IBindText[];\r\n  \r\n  /** Map from bind text to factory function pairs */\r\n  readonly creatorByText: Map<IBindText, IBindingCreator> = new Map();\r\n\r\n  /**\r\n   * Constructor that initializes DataBindAttributes by analyzing the provided node.\r\n   * Extracts binding information, processes the DOM, and generates factory functions.\r\n   * \r\n   * @param node - DOM node to extract binding information from\r\n   */\r\n  constructor(node: Node) {\r\n    // Step 1: Determine node type\r\n    this.nodeType = getNodeType(node);\r\n\r\n    // Step 2: Extract binding expression from data-bind attribute or comment\r\n    const text = getDataBindText(this.nodeType, node);\r\n\r\n    // Step 3: Replace comment nodes with Text nodes\r\n    // (Restores Text nodes that were converted to comments during template preprocessing)\r\n    // Note: Directly modifies template.content\r\n    const textNode = replaceTextNodeFromComment(node, this.nodeType);\r\n\r\n    // Step 4: Remove data-bind attribute (no longer needed after parsing, prevents duplicate processing)\r\n    removeDataBindAttribute(textNode, this.nodeType);\r\n\r\n    // Step 5: Calculate absolute node path (index array from parent nodes)\r\n    this.nodePath = getAbsoluteNodePath(textNode);\r\n\r\n    // Step 6: Parse binding expression into structured metadata\r\n    // (Array of IBindText containing nodeProperty, stateProperty, filters, decorates)\r\n    this.bindTexts = parseBindText(text);\r\n\r\n    // Step 7: Create factory function pairs for runtime instance generation for each bind text\r\n    for(let i = 0; i < this.bindTexts.length; i++) {\r\n      const bindText = this.bindTexts[i];\r\n      \r\n      // Generate factory function pair:\r\n      // - createBindingNode: Factory for BindingNode subclass (Attribute/Event/For/If, etc.)\r\n      // - createBindingState: Factory for BindingState subclass (normal/Index/Component, etc.)\r\n      const creator: IBindingCreator = {\r\n        createBindingNode : getBindingNodeCreator(\r\n          textNode, \r\n          bindText.nodeProperty,\r\n          bindText.inputFilterTexts,\r\n          bindText.decorates\r\n        ),\r\n        createBindingState: getBindingStateCreator(\r\n          bindText.stateProperty,\r\n          bindText.outputFilterTexts\r\n        ),\r\n      }\r\n      \r\n      // Associate bind text with factory function pair\r\n      this.creatorByText.set(bindText, creator);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Factory function that creates a DataBindAttributes instance from the specified node.\r\n * Called for each data-bind target node during template compilation.\r\n * \r\n * @param node - DOM node to extract binding information from\r\n * @returns IDataBindAttributes object containing binding metadata\r\n */\r\nexport function createDataBindAttributes(node: Node): IDataBindAttributes {\r\n  return new DataBindAttributes(node);\r\n}","import { DATA_BIND_ATTRIBUTE, COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK } from \"../constants.js\";\r\n\r\n/**\r\n * Internal function to determine if a comment node is a binding target.\r\n * \r\n * Decision criteria:\r\n * - Must be a Comment node\r\n * - Text starts with \"@@:\" (COMMENT_EMBED_MARK) → Text content binding\r\n * - Or starts with \"@@|\" (COMMENT_TEMPLATE_MARK) → Template reference binding\r\n * \r\n * Usage examples:\r\n * ```typescript\r\n * const comment1 = document.createComment(\"@@:user.name\");\r\n * isCommentNode(comment1); // → true (text binding)\r\n * \r\n * const comment2 = document.createComment(\"@@|123 if:isVisible\");\r\n * isCommentNode(comment2); // → true (template reference)\r\n * \r\n * const comment3 = document.createComment(\"regular comment\");\r\n * isCommentNode(comment3); // → false\r\n * ```\r\n * \r\n * @param node - Node to check\r\n * @returns true if binding target comment node\r\n */\r\nfunction isCommentNode(node: Node): boolean {\r\n  return node instanceof Comment && (\r\n    (node.textContent?.indexOf(COMMENT_EMBED_MARK) === 0) || \r\n    (node.textContent?.indexOf(COMMENT_TEMPLATE_MARK) === 0)\r\n  );\r\n} \r\n\r\n/**\r\n * Utility function that retrieves all \"elements with data-bind attribute\" or\r\n * \"comment nodes starting with specific marks (@@: or @@|)\" from DOM tree below specified node.\r\n *\r\n * Search targets:\r\n * 1. Element (element nodes)\r\n *    - Extract only those with data-bind attribute\r\n *    - Example: <div data-bind=\"class:active\">\r\n * \r\n * 2. Comment (comment nodes)\r\n *    - Starting with \"@@:\" (text content binding)\r\n *    - Starting with \"@@|\" (template reference binding)\r\n * \r\n * Processing flow:\r\n * 1. Create TreeWalker (SHOW_ELEMENT | SHOW_COMMENT flags)\r\n * 2. Custom filter ACCEPTs only matching nodes\r\n *    - Element: Check for data-bind attribute\r\n *    - Comment: Check with isCommentNode\r\n * 3. Efficiently traverse tree with nextNode()\r\n * 4. Add matching nodes to array\r\n * 5. Return array of all nodes\r\n * \r\n * Performance:\r\n * - Achieves efficient DOM tree traversal using TreeWalker\r\n * - Skips unnecessary nodes with custom filter\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * const fragment = document.createDocumentFragment();\r\n * const div = document.createElement('div');\r\n * div.setAttribute('data-bind', 'class:active');\r\n * const comment = document.createComment('@@:user.name');\r\n * fragment.appendChild(div);\r\n * fragment.appendChild(comment);\r\n * \r\n * const nodes = getNodesHavingDataBind(fragment);\r\n * // nodes = [div, comment] (elements with data-bind and binding comments)\r\n * ```\r\n * \r\n * @param root - Root node for search (typically DocumentFragment or Element)\r\n * @returns Array of nodes matching criteria\r\n */\r\nexport function getNodesHavingDataBind(root: Node): Node[] {\r\n  // Array to store results\r\n  const nodes: Node[] = [];\r\n  \r\n  // Create TreeWalker (target element and comment nodes)\r\n  const walker = document.createTreeWalker(\r\n    root, \r\n    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, \r\n    {\r\n      // Custom filter: Determine ACCEPT/SKIP for each node\r\n      acceptNode(node: Node) {\r\n        // Case: Element\r\n        if (node instanceof Element) {\r\n          // ACCEPT only if has data-bind attribute, otherwise SKIP\r\n          return node.hasAttribute(DATA_BIND_ATTRIBUTE) \r\n            ? NodeFilter.FILTER_ACCEPT \r\n            : NodeFilter.FILTER_SKIP;\r\n        } else {\r\n          // Case: Comment\r\n          // Check with isCommentNode if starts with \"@@:\" or \"@@|\"\r\n          return isCommentNode(node) \r\n            ? NodeFilter.FILTER_ACCEPT \r\n            : NodeFilter.FILTER_SKIP;\r\n        }\r\n      }\r\n    }\r\n  );\r\n  \r\n  // Move to next node with TreeWalker and add matching nodes to array\r\n  while (walker.nextNode()) {\r\n    nodes.push(walker.currentNode);\r\n  }\r\n  \r\n  // Return array of binding target nodes\r\n  return nodes;\r\n}\r\n\r\n","import { createDataBindAttributes } from \"./createDataBindAttributes.js\";\r\nimport { getNodesHavingDataBind } from \"./getNodesHavingDataBind.js\";\r\nimport { IDataBindAttributes } from \"./types\";\r\n\r\n/**\r\n * Cache of binding attribute lists per template ID.\r\n * When a template is registered, stores all binding information within that template.\r\n */\r\nconst listDataBindAttributesById: { [key: number]: IDataBindAttributes[] } = {};\r\n\r\n/**\r\n * Cache of \"for\" binding stateProperty sets per template ID.\r\n * Used to identify state paths related to loops (lists).\r\n * \r\n * Example: \"for:items\" → \"items\" is added to listPathsSetById[id]\r\n */\r\nconst listPathsSetById: { [key: number]: Set<string> } = {};\r\n\r\n/**\r\n * Cache of all binding stateProperty sets per template ID.\r\n * Tracks all state paths referenced within the template.\r\n * \r\n * Example: \"textContent:user.name\", \"value:email\" → \"user.name\", \"email\" are added to pathsSetById[id]\r\n */\r\nconst pathsSetById: { [key: number]: Set<string> } = {};\r\n\r\n/**\r\n * Cache of \"for\" and \"if\" binding stateProperty sets per template ID.\r\n * Used to identify state paths related to loops (lists) and conditionals.\r\n * \r\n * Example: \"for:items\" or \"if:isVisible\" → \"items\" or \"isVisible\" is added to buildablePathsSetById[id]\r\n */\r\nconst buildablePathsSetById: { [key: number]: Set<string> } = {};\r\n\r\n/**\r\n * Internal utility function that extracts data-bind target nodes from template's DocumentFragment\r\n * and converts them to IDataBindAttributes array.\r\n * \r\n * Processing flow:\r\n * 1. Extract nodes with bindings using getNodesHavingDataBind\r\n * 2. Convert each node to attribute information using createDataBindAttributes\r\n * 3. Return as IDataBindAttributes array\r\n * \r\n * @param content - Template's DocumentFragment\r\n * @returns Array of binding attribute information\r\n */\r\nfunction getDataBindAttributesFromTemplate(content: DocumentFragment): IDataBindAttributes[] {\r\n  // Step 1: Get all nodes with bindings\r\n  const nodes = getNodesHavingDataBind(content);\r\n  \r\n  // Step 2: Convert each node to attribute information\r\n  return nodes.map(node => createDataBindAttributes(node));\r\n}\r\n\r\n/**\r\n * Parses and registers binding information (data-bind attributes and comments) within a template,\r\n * building and caching attribute lists and state path sets per template ID.\r\n *\r\n * Main features:\r\n * 1. Detects and converts all binding nodes within the template\r\n * 2. Registers all binding stateProperty values to pathsSetById\r\n * 3. Also registers \"for\" binding stateProperty values to listPathsSetById\r\n * 4. Caches parse results in listDataBindAttributesById\r\n * \r\n * rootId parameter:\r\n * - When templates are nested, specify the root template's ID\r\n * - State path sets are managed collectively by root ID\r\n * - If omitted, id is used as rootId\r\n * \r\n * Processing flow:\r\n * 1. Extract binding information using getDataBindAttributesFromTemplate\r\n * 2. Get paths and listPaths Sets corresponding to rootId (create new if first time)\r\n * 3. Traverse each binding attribute:\r\n *    a. Add each bindText's stateProperty to paths\r\n *    b. If nodeProperty is \"for\", also add to listPaths\r\n * 4. Save parse result to listDataBindAttributesById[id] and return\r\n * \r\n * Usage example:e example:\r\n * ```typescript\r\n * // Template HTML:\r\n * // <div data-bind=\"textContent:user.name\"></div>\r\n * // <ul>\r\n * //   <!-- @@:for:items -->\r\n * //   <li data-bind=\"textContent:name\"></li>\r\n * //   <!-- @@:end -->\r\n * // </ul>\r\n * \r\n * const template = document.getElementById('myTemplate');\r\n * const attributes = registerDataBindAttributes(1, template.content);\r\n * \r\n * // Result:\r\n * // listDataBindAttributesById[1] = [\r\n * //   { bindTexts: [{ nodeProperty: \"textContent\", stateProperty: \"user.name\", ... }], ... },\r\n * //   { bindTexts: [{ nodeProperty: \"for\", stateProperty: \"items\", ... }], ... },\r\n * //   { bindTexts: [{ nodeProperty: \"textContent\", stateProperty: \"name\", ... }], ... }\r\n * // ]\r\n * // pathsSetById[1] = Set { \"user.name\", \"items\", \"name\" }\r\n * // listPathsSetById[1] = Set { \"items\" }\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @param content - Template's DocumentFragment\r\n * @param rootId - Root template ID (defaults to id if omitted)\r\n * @returns Parsed binding attribute list\r\n */\r\nexport function registerDataBindAttributes(\r\n  id: number,\r\n  content: DocumentFragment,\r\n  rootId: number = id\r\n): IDataBindAttributes[] {\r\n  // Step 1: Extract all binding information from template\r\n  const dataBindAttributes = getDataBindAttributesFromTemplate(content);\r\n  \r\n  // Step 2: Get state path sets corresponding to rootId (create new if first time)\r\n  const paths = pathsSetById[rootId] ?? (pathsSetById[rootId] = new Set<string>());\r\n  const listPaths = listPathsSetById[rootId] ?? (listPathsSetById[rootId] = new Set<string>());\r\n  const buildablePaths = buildablePathsSetById[rootId] ?? (buildablePathsSetById[rootId] = new Set<string>());\r\n  \r\n  // Step 3: Traverse each binding attribute and register state paths\r\n  for (let i = 0; i < dataBindAttributes.length; i++) {\r\n    const attribute = dataBindAttributes[i];\r\n    \r\n    // Process stateProperty of each binding text\r\n    for (let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      \r\n      // Add stateProperty of all bindings to paths\r\n      paths.add(bindText.stateProperty);\r\n      \r\n      // If \"for\" binding (loop), also add to listPaths\r\n      if (bindText.nodeProperty === \"for\") {\r\n        listPaths.add(bindText.stateProperty);\r\n      }\r\n\r\n      // If \"for\" or \"if\" binding (conditional), also add to buildablePaths\r\n      if (bindText.nodeProperty === \"if\" || bindText.nodeProperty === \"for\") {\r\n        buildablePaths.add(bindText.stateProperty);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Step 4: Save parse result to cache and return\r\n  return listDataBindAttributesById[id] = dataBindAttributes;\r\n}\r\n\r\n/**\r\n * Gets registered binding attribute list from template ID.\r\n * \r\n * Used to retrieve binding information of templates\r\n * registered with registerDataBindAttributes.\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * registerDataBindAttributes(1, template.content);\r\n * const attributes = getDataBindAttributesById(1);\r\n * // → [{ bindTexts: [...], nodeType: \"Element\", nodePath: [...], ... }]\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @returns Binding attribute list\r\n */\r\nexport const getDataBindAttributesById = (id: number): IDataBindAttributes[] => {\r\n  return listDataBindAttributesById[id];\r\n}\r\n\r\n/**\r\n * Gets \"for\" binding (loop) stateProperty set from template ID.\r\n * \r\n * Used to identify state paths related to loops.\r\n * Returns empty array if not registered.\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * // Assuming template contains <!-- @@:for:items -->\r\n * registerDataBindAttributes(1, template.content);\r\n * const listPaths = getListPathsSetById(1);\r\n * // → Set { \"items\" }\r\n * \r\n * // Monitor loop state changes\r\n * if (listPaths.has(\"items\")) {\r\n *   // Process assuming items is an array\r\n * }\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @returns State path set of \"for\" bindings (empty Set if not registered)\r\n */\r\nexport const getListPathsSetById = (id: number): Set<string> => {\r\n  return listPathsSetById[id] ?? new Set();\r\n};\r\n\r\n/**\r\n * Gets all binding stateProperty set from template ID.\r\n * \r\n * Used to track all state paths referenced within the template.\r\n * Returns empty array if not registered.\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * // Assuming template has following bindings:\r\n * // - textContent:user.name\r\n * // - value:email\r\n * // - for:items\r\n * registerDataBindAttributes(1, template.content);\r\n * const allPaths = getPathsSetById(1);\r\n * // → Set { \"user.name\", \"email\", \"items\" }\r\n * \r\n * // Monitor state changes\r\n * if (allPaths.has(\"user.name\")) {\r\n *   // Process user.name change\r\n * }\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @returns State path set of all bindings (empty Set if not registered)\r\n */\r\nexport const getPathsSetById = (id: number): Set<string> => {\r\n  return pathsSetById[id] ?? new Set();\r\n};\r\n\r\n/**\r\n * Gets \"for\" and \"if\" binding (loop and conditional) stateProperty set from template ID.\r\n *\r\n * Used to identify state paths related to loops and conditionals.\r\n * Returns empty array if not registered.\r\n * \r\n * Usage example:\r\n * ```typescript\r\n * // Assuming template contains:\r\n * // <!-- @@:for:items -->\r\n * // <!-- @@:if:isVisible -->\r\n * registerDataBindAttributes(1, template.content);\r\n * const buildablePaths = getBuildablePathsSetById(1);\r\n * // → Set { \"items\", \"isVisible\" }\r\n * // Monitor buildable state changes\r\n * if (buildablePaths.has(\"isVisible\")) {\r\n *   // Process isVisible change \r\n * }\r\n * ```\r\n * \r\n * @param id - Template ID\r\n * @returns State path set of \"for\" and \"if\" bindings (empty Set if not registered)\r\n */\r\nexport const getBuildablePathsSetById = (id: number): Set<string> => {\r\n  return buildablePathsSetById[id] ?? new Set();\r\n};","/**\r\n * removeEmptyTextNodes.ts\r\n *\r\n * Utility function to remove empty text nodes from a DocumentFragment.\r\n *\r\n * Main responsibilities:\r\n * - Detects and removes whitespace-only text nodes directly under the content (DocumentFragment)\r\n *\r\n * Design points:\r\n * - Converts childNodes to an array using Array.from and traverses all nodes with forEach\r\n * - Removes nodes via removeChild when nodeType is TEXT_NODE and nodeValue contains only whitespace\r\n * - Used for template processing and clean DOM generation\r\n */\r\n\r\n/**\r\n * Removes all whitespace-only text nodes from a DocumentFragment.\r\n * This cleans up the DOM structure by removing unnecessary text nodes that contain\r\n * only spaces, tabs, newlines, or other whitespace characters.\r\n * \r\n * @param {DocumentFragment} content - The DocumentFragment to clean up\r\n * @returns {void}\r\n * \r\n * @example\r\n * const template = document.createElement('template');\r\n * template.innerHTML = `\r\n *   <div>\r\n *     <span>Hello</span>\r\n *   </div>\r\n * `;\r\n * removeEmptyTextNodes(template.content); // Removes whitespace text nodes\r\n */\r\nexport function removeEmptyTextNodes(content:DocumentFragment):void {\r\n  // Convert NodeList to array to safely iterate and remove nodes\r\n  Array.from(content.childNodes).forEach(node => {\r\n    // Check if node is a text node and contains only whitespace\r\n    if (node.nodeType === Node.TEXT_NODE && !(node.nodeValue ?? \"\").trim()) {\r\n      // Remove the empty text node from the fragment\r\n      content.removeChild(node);\r\n    }\r\n  });  \r\n}\r\n","/**\r\n * Management module for registering and retrieving HTMLTemplateElement by ID.\r\n *\r\n * Responsibilities:\r\n * - registerTemplate: Registers a template with a specified ID (removes empty text nodes and parses data-bind)\r\n * - getTemplateById: Retrieves a template by ID (throws error if not registered)\r\n *\r\n * Throws (getTemplateById):\r\n * - TMP-001 Template not found: Requested template ID is not registered\r\n */\r\nimport { registerDataBindAttributes } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { removeEmptyTextNodes } from \"./removeEmptyTextNodes.js\";\r\n\r\n/**\r\n * Global registry for HTMLTemplateElement instances keyed by numeric ID.\r\n * Stores processed templates after empty text node removal and data-bind parsing.\r\n */\r\nconst templateById:Record<number, HTMLTemplateElement> = {};\r\n\r\n/**\r\n * Registers a template by ID and builds internal index and data-bind information.\r\n * Performs preprocessing to remove empty text nodes and parse data-bind attributes\r\n * for efficient template instantiation and data binding.\r\n *\r\n * @param {number} id - Unique template ID for registration and retrieval\r\n * @param {HTMLTemplateElement} template - The template element to register\r\n * @param {number} rootId - Root template ID used for nested template parsing and resolution\r\n * @returns {number} The registered template ID (same as input id)\r\n * \r\n * @example\r\n * const template = document.createElement('template');\r\n * template.innerHTML = '<div data-bind=\"text:name\"></div>';\r\n * registerTemplate(1, template, 1);\r\n */\r\nexport function registerTemplate(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number\r\n): number {\r\n  // Remove whitespace-only text nodes to clean up the template structure\r\n  removeEmptyTextNodes(template.content);\r\n  \r\n  // Parse and index all data-bind attributes for efficient binding setup\r\n  registerDataBindAttributes(id, template.content, rootId);  \r\n  \r\n  // Store the processed template in the global registry\r\n  templateById[id] = template;\r\n  \r\n  return id;\r\n}\r\n\r\n/**\r\n * Retrieves a registered template by its ID.\r\n * Throws an error if the template has not been registered.\r\n *\r\n * @param {number} id - The template ID to retrieve\r\n * @returns {HTMLTemplateElement} The registered template element\r\n * @throws {Error} Throws TMP-001 error if the template ID is not found in the registry\r\n * \r\n * @example\r\n * const template = getTemplateById(1);\r\n * const clone = template.content.cloneNode(true);\r\n */\r\nexport function getTemplateById(id: number): HTMLTemplateElement {\r\n  // Return the template if found, otherwise throw a descriptive error\r\n  return templateById[id] ?? raiseError({\r\n    code: \"TMP-001\",\r\n    message: `Template not found: ${id}`,\r\n    context: { where: 'Template.getTemplateById', templateId: id },\r\n    docsUrl: \"./docs/error-codes.md#tmp\",\r\n  });\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../Updater/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { CreateBindingNodeByNodeFn, IBindingNode } from \"./BindingNode/types\";\r\nimport { CreateBindingStateByStateFn, IBindingState } from \"./BindingState/types\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\n\r\n/**\r\n * Coordinates BindingNode (DOM operations) and BindingState (state management) to achieve reactive binding.\r\n * \r\n * Optimizations:\r\n * - Duplicate update prevention via updatedBindings set\r\n * - Single binding optimization: Add non-dynamic single ref to processedRefs\r\n * - WeakMap cache for loop index bindings\r\n */\r\nclass Binding implements IBinding {\r\n  readonly parentBindContent: IBindContent;\r\n  readonly engine: IComponentEngine;\r\n  readonly node: Node;\r\n  readonly bindingNode: IBindingNode;\r\n  readonly bindingState: IBindingState;\r\n  readonly bindingsByListIndex: WeakMap<IListIndex, Set<IBinding>> = new WeakMap();\r\n\r\n  private _isActive: boolean = false;\r\n  \r\n  /**\r\n   * Initialize binding with factories for BindingNode and BindingState.\r\n   * Call activate() after construction to enable.\r\n   * \r\n   * @param parentBindContent - Parent BindContent instance\r\n   * @param node - DOM node to bind\r\n   * @param engine - Component engine instance\r\n   * @param createBindingNode - Factory function to create BindingNode\r\n   * @param createBindingState - Factory function to create BindingState\r\n   */\r\n  constructor(\r\n    parentBindContent: IBindContent,\r\n    node: Node,\r\n    engine: IComponentEngine,\r\n    createBindingNode: CreateBindingNodeByNodeFn, \r\n    createBindingState: CreateBindingStateByStateFn,\r\n  ) {\r\n    this.parentBindContent = parentBindContent\r\n    this.node = node;\r\n    this.engine = engine\r\n    this.bindingNode = createBindingNode(this, node, engine.inputFilters);\r\n    this.bindingState = createBindingState(this, engine.outputFilters);\r\n  }\r\n\r\n  /**\r\n   * Returns child BindContent managed by structural control bindings (for, if, etc.)\r\n   * \r\n   * @returns Array of child BindContent instances (empty for non-structural bindings)\r\n   */\r\n  get bindContents(): IBindContent[] {\r\n    return this.bindingNode.bindContents;\r\n  }\r\n\r\n  /**\r\n   * Returns whether binding is currently active.\r\n   * \r\n   * @returns true if binding is active, false otherwise\r\n   */\r\n  get isActive(): boolean {\r\n    return this._isActive;\r\n  }\r\n\r\n  /**\r\n   * Update state value for bidirectional binding (used by input, checkbox, etc.)\r\n   * \r\n   * @param writeState - Writable state proxy\r\n   * @param handler - State update handler\r\n   * @param void - Value to assign to state\r\n   */\r\n  updateStateValue(writeState:IWritableStateProxy, handler: IWritableStateHandler, value: unknown): void {\r\n    this.bindingState.assignValue(writeState, handler, value);\r\n  }\r\n\r\n  /**\r\n   * Notify BindingNode to redraw if its ref matches any in the provided refs array.\r\n   * \r\n   * @param refs - Array of state property references that require redraw\r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]) {\r\n    this.bindingNode.notifyRedraw(refs);\r\n  }\r\n\r\n  /**\r\n   * Apply state changes to DOM with duplicate update prevention.\r\n   * Optimization: Mark single binding refs as processed to avoid redundant checks.\r\n   * \r\n   * @param renderer - Renderer instance managing update cycle\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    if (!this.bindingNode.renderable) {return;}\r\n    if (renderer.updatedBindings.has(this)) {return;}\r\n    if (renderer.renderPhase === 'build' && !this.bindingNode.buildable) {\r\n      if (this.bindingNode.isSelectElement) {\r\n        renderer.applySelectPhaseBinidings.push(this);\r\n      } else {\r\n        renderer.applyPhaseBinidings.push(this);\r\n      }\r\n      return;\r\n    } else if (renderer.renderPhase === 'apply' && (this.bindingNode.buildable || this.bindingNode.isSelectElement)) {\r\n      return;\r\n    } else if (renderer.renderPhase === 'applySelect' && (this.bindingNode.buildable || !this.bindingNode.isSelectElement)) {\r\n      return;\r\n    } else if (renderer.renderPhase === 'direct') {\r\n      if (this.bindingNode.isSelectElement) {\r\n        renderer.applySelectPhaseBinidings.push(this);\r\n        return;\r\n      }\r\n      if (this.bindingNode.buildable) {\r\n        raiseError({\r\n          code: 'BIND-101',\r\n          message: 'Direct render phase cannot process buildable bindings',\r\n          context: { where: 'Binding.applyChange', name: this.bindingNode.name },\r\n          docsUrl: './docs/error-codes.md#bind',\r\n        });\r\n      }\r\n    }\r\n    renderer.updatedBindings.add(this);\r\n    this.bindingNode.applyChange(renderer);\r\n    \r\n    const ref = this.bindingState.ref;\r\n    if (!this.bindingState.isLoopIndex && !this.engine.pathManager.dynamicDependencies.has(ref.info.pattern)) {\r\n      const bindings = this.engine.getBindings(ref);\r\n      if (bindings.length === 1) {\r\n        renderer.processedRefs.add(ref);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Activate binding: subscribe to state and render to DOM. Not idempotent. */\r\n  activate(): void {\r\n    this._isActive = true;\r\n    this.bindingState.activate();\r\n    this.bindingNode.activate();\r\n  }\r\n  \r\n  /** Inactivate binding: unsubscribe from state and cleanup resources. Idempotent. */\r\n  inactivate(): void {\r\n    if (this.isActive) {\r\n      this.bindingNode.inactivate();\r\n      this.bindingState.inactivate();\r\n      this._isActive = false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create Binding instance. Call activate() after creation.\r\n * \r\n * @param parentBindContent - Parent BindContent instance\r\n * @param node - DOM node to bind\r\n * @param engine - Component engine instance\r\n * @param createBindingNode - Factory function to create BindingNode\r\n * @param createBindingState - Factory function to create BindingState\r\n * @returns New Binding instance\r\n */\r\nexport function createBinding(\r\n  parentBindContent: IBindContent,\r\n  node: Node, \r\n  engine: IComponentEngine, \r\n  createBindingNode: CreateBindingNodeByNodeFn, \r\n  createBindingState: CreateBindingStateByStateFn\r\n): IBinding {\r\n  return new Binding(\r\n    parentBindContent, \r\n    node, \r\n    engine, \r\n    createBindingNode, \r\n    createBindingState\r\n  );\r\n}","/**\r\n * createLoopContext.ts\r\n *\r\n * Implementation of LoopContext management class and factory function for loop bindings (for, etc.).\r\n *\r\n * Main responsibilities:\r\n * - Manages property path, index, and BindContent associations for each loop\r\n * - Provides parent loop context search with caching, index reassignment, and clearing\r\n * - Supports walk/serialize for traversing loop hierarchy and find for name-based search\r\n *\r\n * Design points:\r\n * - Holds listIndex with WeakRef for GC-friendly design\r\n * - Lazy search and caching of parentLoopContext for efficient parent-child relationship management\r\n * - Fast search by name with find (with caching)\r\n * - Concise loop hierarchy traversal with walk/serialize\r\n * - Consistent creation and management via createLoopContext factory\r\n */\r\nimport { IBindContent } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { ILoopContext } from \"./types\";\r\n\r\n/**\r\n * LoopContext class manages loop binding context with parent-child relationships.\r\n * Provides efficient caching and traversal of loop hierarchy.\r\n */\r\nclass LoopContext implements ILoopContext {\r\n  readonly info: IStructuredPathInfo;\r\n  readonly bindContent : IBindContent;\r\n\r\n  private _ref: IStatePropertyRef | null;\r\n  private _parentLoopContext: ILoopContext | null | undefined;\r\n  private _cache:Record<string, ILoopContext | null> = {};\r\n\r\n  /**\r\n   * Creates a new LoopContext instance.\r\n   * @param ref - State property reference with path and index information\r\n   * @param bindContent - Bind content to associate with this loop context\r\n   */\r\n  constructor(\r\n    ref: IStatePropertyRef,\r\n    bindContent: IBindContent\r\n  ) {\r\n    this._ref = ref;\r\n    this.info = ref.info;\r\n    this.bindContent = bindContent;\r\n  }\r\n  /**\r\n   * Gets the state property reference.\r\n   * @returns State property reference\r\n   * @throws STATE-202 If ref is null\r\n   */\r\n  get ref(): IStatePropertyRef {\r\n    return this._ref ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'ref is null',\r\n      context: { where: 'LoopContext.ref', path: this.info.pattern },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n  /**\r\n   * Gets the path pattern from the reference.\r\n   * @returns Path pattern string\r\n   */\r\n  get path(): string {\r\n    return this.ref.info.pattern;\r\n  }\r\n  /**\r\n   * Gets the list index from the reference.\r\n   * @returns List index instance\r\n   * @throws LIST-201 If listIndex is required but not present\r\n   */\r\n  get listIndex(): IListIndex {\r\n    return this.ref.listIndex ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is required',\r\n      context: { where: 'LoopContext.listIndex', path: this.info.pattern },\r\n      docsUrl: './docs/error-codes.md#list',\r\n    });\r\n  }\r\n  /**\r\n   * Assigns a new list index to this loop context.\r\n   * @param listIndex - New list index to assign\r\n   */\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    this._ref = getStatePropertyRef(this.info, listIndex);\r\n    // Structure doesn't change, so no need to clear _parentLoopContext and _cache\r\n  }\r\n  /**\r\n   * Clears the list index reference.\r\n   */\r\n  clearListIndex():void {\r\n    this._ref = null;\r\n  }\r\n\r\n  /**\r\n   * Gets the parent loop context with lazy evaluation and caching.\r\n   * @returns Parent loop context or null if none exists\r\n   */\r\n  get parentLoopContext(): ILoopContext | null {\r\n    if (typeof this._parentLoopContext === \"undefined\") {\r\n      let currentBindContent: IBindContent | null = this.bindContent;\r\n      while(currentBindContent !== null) {\r\n        if (currentBindContent.loopContext !== null && currentBindContent.loopContext !== this) {\r\n          this._parentLoopContext = currentBindContent.loopContext;\r\n          break;\r\n        }\r\n        currentBindContent = currentBindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      if (typeof this._parentLoopContext === \"undefined\") {this._parentLoopContext = null;}\r\n    }\r\n    return this._parentLoopContext;\r\n  }\r\n\r\n  /**\r\n   * Finds a loop context by path name in the hierarchy.\r\n   * @param name - Path name to search for\r\n   * @returns Loop context with matching path or null if not found\r\n   */\r\n  find(name: string): ILoopContext | null {\r\n    let loopContext = this._cache[name];\r\n    if (typeof loopContext === \"undefined\") {\r\n      if (this.path === name) {\r\n        loopContext = this._cache[name] = this;\r\n      } else {\r\n        let currentLoopContext: ILoopContext | null = this.parentLoopContext;\r\n        while(currentLoopContext !== null) {\r\n          if (currentLoopContext.path === name) {break;}\r\n          currentLoopContext = currentLoopContext.parentLoopContext;\r\n        }\r\n        loopContext = this._cache[name] = currentLoopContext;\r\n      }\r\n    }\r\n    return loopContext;\r\n  }\r\n\r\n  /**\r\n   * Walks through the loop context hierarchy from current to root.\r\n   * @param callback - Function to call for each loop context\r\n   */\r\n  walk(callback: (loopContext: ILoopContext) => void): void {\r\n    callback(this);\r\n    let currentLoopContext: ILoopContext | null = this.parentLoopContext;\r\n    while(currentLoopContext !== null) {\r\n      callback(currentLoopContext);\r\n      currentLoopContext = currentLoopContext.parentLoopContext;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Serializes the loop context hierarchy to an array from root to current.\r\n   * @returns Array of loop contexts ordered from root to current\r\n   */\r\n  serialize(): ILoopContext[] {\r\n    const results: ILoopContext[] = [];\r\n    this.walk((loopContext) => {\r\n      results.unshift(loopContext);\r\n    });\r\n    return results;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Factory function to create a new LoopContext instance.\r\n * Created instance is registered to IBindContent's loopContext and retained permanently.\r\n * @param ref - State property reference with path and index information\r\n * @param bindContent - Bind content to associate with this loop context\r\n * @returns New LoopContext instance\r\n */\r\nexport function createLoopContext(\r\n  ref: IStatePropertyRef,\r\n  bindContent: IBindContent\r\n): ILoopContext {\r\n  return new LoopContext(ref, bindContent);\r\n}","import { resolveNodeFromPath } from \"../BindingBuilder/resolveNodeFromPath.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createBinding } from \"./Binding.js\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\nimport { createLoopContext } from \"../LoopContext/createLoopContext.js\";\r\nimport { getDataBindAttributesById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { hasLazyLoadComponents, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IRenderer } from \"../Updater/types.js\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types.js\";\r\n\r\n// Reusable DocumentFragment for mount operations, GC overhead minimized\r\nconst workFragment = document.createDocumentFragment();\r\n\r\n/**\r\n * Internal helper function to generate DocumentFragment from template ID.\r\n * Automatically loads lazy-load components if present.\r\n * \r\n * @param id - Registered template ID\r\n * @returns DocumentFragment with copied template content\r\n * @throws TMP-001 Template not found\r\n */\r\nfunction createContent(id: number): DocumentFragment {\r\n  const template = getTemplateById(id) ?? \r\n    raiseError({\r\n      code: \"TMP-001\",\r\n      message: `Template not found: ${id}`,\r\n      context: { where: 'BindContent.createContent', templateId: id },\r\n      docsUrl: \"./docs/error-codes.md#tmp\",\r\n    });\r\n  \r\n  const fragment = document.importNode(template.content, true);\r\n  \r\n  if (hasLazyLoadComponents()) {\r\n    const lazyLoadElements = fragment.querySelectorAll(\":not(:defined)\");\r\n    for(let i = 0; i < lazyLoadElements.length; i++) {\r\n      const tagName = lazyLoadElements[i].tagName.toLowerCase();\r\n      loadLazyLoadComponent(tagName);\r\n    }\r\n  }\r\n  \r\n  return fragment;\r\n}\r\n\r\n/**\r\n * Internal function to construct IBinding array from data-bind information within template.\r\n * Uses factory functions to generate appropriate binding types.\r\n *\r\n * @param bindContent - Parent BindContent\r\n * @param id - Template ID\r\n * @param engine - Component engine\r\n * @param content - Fragment copied from template\r\n * @returns Array of generated IBinding\r\n * @throws BIND-101 Data-bind not registered\r\n * @throws BIND-102 Node not found\r\n * @throws BIND-103 Creator not found\r\n */\r\nfunction createBindings(\r\n  bindContent: IBindContent, \r\n  id         : number, \r\n  engine     : IComponentEngine, \r\n  content    : DocumentFragment\r\n): IBinding[] {\r\n  const attributes = getDataBindAttributesById(id) ?? \r\n    raiseError({\r\n      code: \"BIND-101\",\r\n      message: \"Data-bind not registered\",\r\n      context: { where: 'BindContent.createBindings', templateId: id },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n  \r\n  const bindings: IBinding[] = [];\r\n  \r\n  for(let i = 0; i < attributes.length; i++) {\r\n    const attribute = attributes[i];\r\n    \r\n    const node = resolveNodeFromPath(content, attribute.nodePath) ?? \r\n      raiseError({\r\n        code: \"BIND-102\",\r\n        message: `Node not found by nodePath: ${String(attribute.nodePath)}`,\r\n        context: { where: 'BindContent.createBindings', templateId: id, nodePath: attribute.nodePath },\r\n        docsUrl: \"./docs/error-codes.md#bind\",\r\n      });\r\n    \r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      \r\n      const creator = attribute.creatorByText.get(bindText) ??\r\n        raiseError({\r\n          code: \"BIND-103\",\r\n          // eslint-disable-next-line @typescript-eslint/no-base-to-string\r\n          message: `Creator not found for bindText: ${String(bindText)}`,\r\n          context: { where: 'BindContent.createBindings', templateId: id, bindText },\r\n          docsUrl: \"./docs/error-codes.md#bind\",\r\n        });\r\n      \r\n      // Generate Binding instance (includes BindingNode and BindingState)\r\n      const binding = createBinding(\r\n        bindContent, \r\n        node, \r\n        engine, \r\n        creator.createBindingNode, \r\n        creator.createBindingState\r\n      );\r\n      \r\n      // Add to array\r\n      bindings.push(binding);\r\n    }\r\n  }\r\n  \r\n  // Step 4: Return generated IBinding array\r\n  return bindings;\r\n}\r\n\r\n/**\r\n * BindContent class manages DOM fragments generated from templates and their binding information.\r\n * Supports hierarchical structure, loops, and lifecycle management.\r\n *\r\n * @throws TMP-001 Template not found (in createContent)\r\n * @throws BIND-101/102/103 data-bind info issues (in createBindings)\r\n * @throws BIND-104 Child bindContent not found (getLastNode)\r\n * @throws BIND-201 LoopContext is null (assignListIndex)\r\n */\r\nclass BindContent implements IBindContent {\r\n  parentBinding: IBinding | null;\r\n  readonly loopContext: ILoopContext | null;\r\n  readonly id: number;\r\n  readonly firstChildNode: Node | null;\r\n  readonly lastChildNode: Node | null;\r\n  readonly fragment: DocumentFragment;\r\n  readonly childNodes: Node[];\r\n  readonly bindings: IBinding[] = [];\r\n  readonly lastBinding: IBinding | null = null;\r\n\r\n  private _isActive: boolean = false;\r\n  private _currentLoopContext: ILoopContext | null | undefined;\r\n  \r\n  /**\r\n   * Constructor initializes BindContent from template ID.\r\n   * Generates LoopContext if loopRef has listIndex.\r\n   * Call activate() after construction to enable bindings.\r\n   * \r\n   * @param parentBinding - Parent IBinding (null if root)\r\n   * @param id - Template ID\r\n   * @param engine - Component engine instance\r\n   * @param loopRef - StatePropertyRef for loop context\r\n  * @throws TMP-001 Template not found or BIND-101 data-bind not set\r\n   * @throws BIND-102 Node not found in template\r\n   * @throws BIND-103 Creator not found for bindText\r\n   */\r\n  constructor(\r\n    parentBinding: IBinding | null,\r\n    id: number, \r\n    engine: IComponentEngine, \r\n    loopRef: IStatePropertyRef,\r\n  ) {\r\n    this.parentBinding = parentBinding;\r\n    this.id = id;\r\n    this.fragment = createContent(id);\r\n    this.childNodes = Array.from(this.fragment.childNodes);\r\n    this.firstChildNode = this.childNodes[0] ?? null;\r\n    this.lastChildNode = this.childNodes[this.childNodes.length - 1] ?? null;\r\n    this.loopContext = (loopRef.listIndex !== null) ? createLoopContext(loopRef, this) : null;\r\n    this.bindings = createBindings(\r\n      this, \r\n      id, \r\n      engine, \r\n      this.fragment\r\n    );\r\n    this.lastBinding = this.bindings.length > 0 ? this.bindings[this.bindings.length - 1] : null;\r\n  }\r\n\r\n  /**\r\n   * Returns whether BindContent is currently active.\r\n   * \r\n   * @returns true if active, false otherwise\r\n   */\r\n  get isActive(): boolean {\r\n    return this._isActive;\r\n  }\r\n\r\n  /**\r\n   * Getter to retrieve current loop context with caching.\r\n   * Traverses parent direction on first access, cached thereafter.\r\n   * \r\n   * @returns Current ILoopContext or null if not in loop\r\n   */\r\n  get currentLoopContext(): ILoopContext | null {\r\n    if (typeof this._currentLoopContext === \"undefined\") {\r\n      if (this.loopContext !== null) {\r\n        this._currentLoopContext = this.loopContext;\r\n        return this._currentLoopContext;\r\n      }\r\n      let bindContent: IBindContent | null = this.parentBinding?.parentBindContent ?? null;\r\n      while(bindContent !== null) {\r\n        if (bindContent.loopContext !== null) {break;} ;\r\n        bindContent = bindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      this._currentLoopContext = bindContent?.loopContext ?? null;\r\n    }\r\n    return this._currentLoopContext;\r\n  }\r\n\r\n  /**\r\n   * Recursively retrieves the last node, including those under trailing bindings.\r\n   * Used for determining DOM insertion position in BindingNodeFor.\r\n   *\r\n   * @param parentNode - Parent node for validation\r\n   * @returns Last node or null if parent-child relationship broken\r\n   * @throws BIND-104 Child bindContent not found\r\n   */\r\n  get lastNode(): Node | null {\r\n    if (this.lastBinding !== null \r\n      && this.lastBinding.node === this.lastChildNode \r\n      && this.lastBinding.bindContents.length > 0) {\r\n      const lastBindContent = this.lastBinding.bindContents[this.lastBinding.bindContents.length - 1];\r\n      const lastNode = lastBindContent.lastNode;\r\n      if (lastNode !== null) {\r\n        return lastNode;\r\n      }\r\n    }\r\n    return this.lastChildNode;\r\n  }\r\n\r\n  /**\r\n   * Mounts childNodes to end of parent node (appendChild).\r\n   * Not idempotent - caller must avoid duplicate mounts.\r\n   * \r\n   * @param parentNode - Parent node for mount destination\r\n   */\r\n  mount(parentNode: Node) {\r\n    let workParentNode: Node = parentNode;\r\n    const useFragment = parentNode.isConnected && this.childNodes.length > 1;\r\n    if (useFragment) {\r\n      workFragment.textContent = \"\";\r\n      workParentNode = workFragment;\r\n    }\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      workParentNode.appendChild(this.childNodes[i]);\r\n    }\r\n    if (useFragment) {\r\n      parentNode.appendChild(workParentNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mounts childNodes immediately before specified node (insertBefore).\r\n   * If beforeNode is null, appends to end.\r\n   * \r\n   * @param parentNode - Parent node for mount destination\r\n   * @param beforeNode - Reference node for insertion position (null = append to end)\r\n   */\r\n  mountBefore(parentNode: Node, beforeNode: Node | null) {\r\n    const useFragment = parentNode.isConnected && this.childNodes.length > 1;\r\n    if (useFragment) {\r\n      // Optimization: use DocumentFragment for connected DOM\r\n      workFragment.textContent = \"\";\r\n      for(let i = 0; i < this.childNodes.length; i++) {\r\n        workFragment.appendChild(this.childNodes[i]);\r\n      }\r\n      parentNode.insertBefore(workFragment, beforeNode);\r\n    } else {\r\n      // For disconnected nodes, insert directly\r\n      for(let i = 0; i < this.childNodes.length; i++) {\r\n        parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mounts childNodes immediately after specified node.\r\n   * \r\n   * @param parentNode - Parent node for mount destination\r\n   * @param afterNode - Reference node for insertion position (null = prepend to start)\r\n   */\r\n  mountAfter(parentNode: Node, afterNode: Node | null) {\r\n    const useFragment = parentNode.isConnected && this.childNodes.length > 1;\r\n    const beforeNode = afterNode?.nextSibling ?? null;\r\n    if (useFragment) {\r\n      // Optimization: use DocumentFragment for connected DOM\r\n      workFragment.textContent = \"\";\r\n      for(let i = 0; i < this.childNodes.length; i++) {\r\n        workFragment.appendChild(this.childNodes[i]);\r\n      }\r\n      parentNode.insertBefore(workFragment, beforeNode);\r\n    } else {\r\n      // For disconnected nodes, insert directly\r\n      for(let i = 0; i < this.childNodes.length; i++) {\r\n        parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unmounts (detaches) childNodes from DOM.\r\n   * Clears currentLoopContext cache.\r\n   */\r\n  unmount() {\r\n    this._currentLoopContext = undefined;\r\n    \r\n    const parentNode = this.childNodes[0]?.parentNode ?? null;\r\n    if (parentNode === null) {\r\n      return; \r\n    }\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.removeChild(this.childNodes[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reassigns ListIndex within loop.\r\n   * Used when reordering array elements in BindingNodeFor.\r\n   * \r\n   * @param listIndex - New list index to assign\r\n   * @throws BIND-201 LoopContext is null\r\n   */\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    if (this.loopContext === null) {\r\n      raiseError({\r\n        code: \"BIND-201\",\r\n        message: \"LoopContext is null\",\r\n        context: { where: 'BindContent.assignListIndex', templateId: this.id },\r\n        docsUrl: \"./docs/error-codes.md#bind\",\r\n      });\r\n    }\r\n    this.loopContext.assignListIndex(listIndex);\r\n  }\r\n\r\n  /**\r\n   * Applies changes to all bindings.\r\n   * Called from Renderer, prevents duplicate updates.\r\n   * \r\n   * @param renderer - Renderer instance managing update cycle\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    const parentNode = this.childNodes[0]?.parentNode ?? null;\r\n    if (parentNode === null) {\r\n      return; \r\n    }\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      const binding = this.bindings[i];\r\n      if (!binding.bindingNode.renderable) {continue;}\r\n      if (renderer.updatedBindings.has(binding)) {continue;}\r\n      binding.applyChange(renderer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates all bindings in this BindContent.\r\n   * Subscribes to state and renders to DOM.\r\n   */\r\n  activate(): void {\r\n    this._isActive = true;\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      this.bindings[i].activate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inactivates all bindings and clears loop context.\r\n   * Unsubscribes from state and cleans up resources.\r\n   */\r\n  inactivate(): void {\r\n    this._isActive = false;\r\n    this.loopContext?.clearListIndex();\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      this.bindings[i].inactivate();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to generate BindContent instance.\r\n * Call activate() after creation to enable bindings.\r\n * \r\n * @param parentBinding - Parent IBinding (null if root)\r\n * @param id - Template ID\r\n * @param engine - Component engine instance\r\n * @param loopRef - StatePropertyRef for loop context\r\n * @returns Generated IBindContent instance\r\n * @throws TMP-001 Template not found or BIND-101 data-bind not set\r\n * @throws BIND-102 Node not found in template\r\n * @throws BIND-103 Creator not found for bindText\r\n */\r\nexport function createBindContent(\r\n  parentBinding: IBinding | null,\r\n  id: number, \r\n  engine: IComponentEngine, \r\n  loopRef: IStatePropertyRef,\r\n):IBindContent {\r\n  return new BindContent(\r\n    parentBinding, \r\n    id, \r\n    engine, \r\n    loopRef,\r\n  );\r\n}\r\n","/**\r\n * Utility function to determine whether an element with the specified tag name can have a ShadowRoot.\r\n *\r\n * - Creates an element with the specified tag name and checks if the attachShadow method exists\r\n * - Returns false for invalid tag names or elements that don't support attachShadow\r\n *\r\n * @param tagName - Tag name of the element to check (e.g., \"div\", \"span\", \"input\")\r\n * @returns true if the element can have a ShadowRoot, false otherwise\r\n */\r\nexport function canHaveShadowRoot(tagName: string): boolean {\r\n  try {\r\n    // Temporarily create an element\r\n    const element = document.createElement(tagName);\r\n    // Check if the `attachShadow` method exists and is callable\r\n    if (typeof element.attachShadow !== \"function\") {\r\n      return false;\r\n    }\r\n    // Attempt to attach a ShadowRoot temporarily\r\n    element.attachShadow({ mode: 'open' });\r\n    return true;\r\n  } catch {\r\n    // Return false if an invalid tag name or other error occurs\r\n    return false;\r\n  }\r\n}\r\n","import { IComponentConfig } from \"../WebComponents/types\";\r\nimport { canHaveShadowRoot } from \"./canHaveShadowRoot.js\";\r\n\r\n/**\r\n * Traverses up the DOM tree to find the nearest parent ShadowRoot.\r\n * Returns undefined if no ShadowRoot is found in the ancestor chain.\r\n *\r\n * @param parentNode - The starting node to traverse from\r\n * @returns The nearest parent ShadowRoot, or undefined if none exists\r\n */\r\nfunction getParentShadowRoot(parentNode: Node | null): ShadowRoot|undefined{\r\n  let node: Node | null = parentNode;\r\n  while(node) {\r\n    if (node instanceof ShadowRoot) {\r\n      return node;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n}\r\n\r\n/**\r\n * Light DOM mode: Adds styles to the parent ShadowRoot or document without using Shadow DOM.\r\n * Prevents duplicate stylesheet additions.\r\n *\r\n * @param element    - Target HTMLElement\r\n * @param styleSheet - CSSStyleSheet to apply\r\n */\r\nfunction attachStyleInLightMode(element: HTMLElement, styleSheet: CSSStyleSheet): void {\r\n  const shadowRootOrDocument = getParentShadowRoot(element.parentNode) || document;\r\n  const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n  if (!styleSheets.includes(styleSheet)) {\r\n    shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, styleSheet];\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a ShadowRoot and applies the stylesheet.\r\n * Skips creation if a ShadowRoot already exists.\r\n *\r\n * @param element    - Target HTMLElement\r\n * @param styleSheet - CSSStyleSheet to apply\r\n */\r\nfunction createShadowRootWithStyle(element: HTMLElement, styleSheet: CSSStyleSheet): void {\r\n  if (!element.shadowRoot) {\r\n    const shadowRoot = element.attachShadow({ mode: 'open' });\r\n    shadowRoot.adoptedStyleSheets = [styleSheet];\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to attach Shadow DOM to the specified HTMLElement and apply a stylesheet.\r\n *\r\n * - config.shadowDomMode=\"auto\": Creates ShadowRoot only for elements that support Shadow DOM, falls back to Light DOM for unsupported elements\r\n *   - Autonomous custom elements: Always creates ShadowRoot\r\n *   - Built-in element extensions: Determined by canHaveShadowRoot; creates ShadowRoot if supported, falls back to Light DOM otherwise\r\n * - config.shadowDomMode=\"force\": Forcefully creates ShadowRoot without validation (throws exception if unsupported)\r\n * - config.shadowDomMode=\"none\": Does not use Shadow DOM; adds styles to parent ShadowRoot or document\r\n * - Prevents duplicate additions if the same stylesheet is already included\r\n *\r\n * @param element - Target HTMLElement\r\n * @param config - Component configuration\r\n * @param styleSheet - CSSStyleSheet to apply\r\n * @throws DOMException if shadowDomMode is \"force\" and element doesn't support Shadow DOM\r\n */\r\nexport function attachShadow(element: HTMLElement, config: IComponentConfig, styleSheet: CSSStyleSheet): void {\r\n  if (config.shadowDomMode === \"none\") {\r\n    attachStyleInLightMode(element, styleSheet);\r\n  } else if (config.shadowDomMode === \"force\") {\r\n    createShadowRootWithStyle(element, styleSheet);\r\n  } else {\r\n    // Auto mode: Creates ShadowRoot only for elements that support Shadow DOM, falls back to Light DOM for unsupported elements\r\n    if (config.extends === null || canHaveShadowRoot(config.extends)) {\r\n      // Autonomous custom element or Shadow DOM-supported built-in element extension\r\n      createShadowRootWithStyle(element, styleSheet);\r\n    } else {\r\n      // Shadow DOM-unsupported built-in element extension → Falls back to Light DOM\r\n      attachStyleInLightMode(element, styleSheet);\r\n    }\r\n  }\r\n}","import { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { StructiveComponent } from \"../WebComponents/types\";\r\nimport { IComponentStateBinding } from \"./types\";\r\n\r\n/**\r\n * ComponentStateBinding\r\n *\r\n * Purpose:\r\n * - Associates parent component state paths with child component sub-paths in a one-to-one relationship,\r\n *   enabling bidirectional path conversion and referencing (parent->child/child->parent).\r\n *\r\n * Constraints:\r\n * - Parent path/child path is 1:1 only (duplicate registration results in STATE-303)\r\n * - Performs path conversion with longest match, concatenating lower segments as-is\r\n */\r\nclass ComponentStateBinding implements IComponentStateBinding {\r\n  childPaths: Set<string> = new Set<string>();\r\n  parentPaths: Set<string> = new Set<string>();\r\n  bindingByParentPath: Map<string, IBinding> = new Map();\r\n  bindingByChildPath: Map<string, IBinding> = new Map();\r\n\r\n  private _childPathByParentPath: Map<string, string> = new Map();\r\n  private _parentPathByChildPath: Map<string, string> = new Map();\r\n  private _bindings: WeakSet<IBinding> = new WeakSet();\r\n\r\n  /**\r\n   * Adds a binding to establish parent-child path mapping.\r\n   * Validates that paths are not already mapped and registers the binding.\r\n   * \r\n   * @param binding - IBinding instance to register\r\n   * @throws STATE-303 Parent path already has a child path or child path already has a parent path\r\n   */\r\n  addBinding(binding: IBinding): void {\r\n    if (this._bindings.has(binding)) {\r\n      return; // Skip if binding is already added\r\n    }\r\n    const parentPath = binding.bindingState.pattern;\r\n    const childPath = binding.bindingNode.subName;\r\n    if (this._childPathByParentPath.has(parentPath)) {\r\n      raiseError({\r\n        code: \"STATE-303\",\r\n        message: `Parent path \"${parentPath}\" already has a child path`,\r\n        context: {\r\n          where: 'ComponentStateBinding.addBinding',\r\n          parentPath,\r\n          existingChildPath: this._childPathByParentPath.get(parentPath),\r\n        },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    if (this._parentPathByChildPath.has(childPath)) {\r\n      raiseError({\r\n        code: \"STATE-303\",\r\n        message: `Child path \"${childPath}\" already has a parent path`,\r\n        context: {\r\n          where: 'ComponentStateBinding.addBinding',\r\n          childPath,\r\n          existingParentPath: this._parentPathByChildPath.get(childPath),\r\n        },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    this._childPathByParentPath.set(parentPath, childPath);\r\n    this._parentPathByChildPath.set(childPath, parentPath);\r\n    this.parentPaths.add(parentPath);\r\n    this.childPaths.add(childPath);\r\n    this.bindingByParentPath.set(parentPath, binding);\r\n    this.bindingByChildPath.set(childPath, binding);\r\n    this._bindings.add(binding);\r\n  }\r\n  \r\n  /**\r\n   * Gets the child path mapped to the given parent path.\r\n   * Returns undefined if no mapping exists.\r\n   * \r\n   * @param parentPath - Parent component state path\r\n   * @returns Child path string or undefined\r\n   */\r\n  getChildPath(parentPath: string): string | undefined {\r\n    return this._childPathByParentPath.get(parentPath);\r\n  }\r\n\r\n  /**\r\n   * Gets the parent path mapped to the given child path.\r\n   * Returns undefined if no mapping exists.\r\n   * \r\n   * @param childPath - Child component state path\r\n   * @returns Parent path string or undefined\r\n   */\r\n  getParentPath(childPath: string): string | undefined {\r\n    return this._parentPathByChildPath.get(childPath);\r\n  }\r\n\r\n  /**\r\n   * Converts a child path to its corresponding parent path.\r\n   * Uses longest match algorithm and concatenates remaining segments.\r\n   * Throws error if no matching parent path is found.\r\n   * \r\n   * @param childPath - Child component state path\r\n   * @returns Corresponding parent path string\r\n   * @throws STATE-302 No parent path found for child path\r\n   */\r\n  toParentPathFromChildPath(childPath: string): string {\r\n    // Child to parent: Find longest matching entry in childPaths, concatenate remaining segments to parent\r\n    const childPathInfo = getStructuredPathInfo(childPath);\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No parent path found for child path \"${childPath}\"`,\r\n        context: { where: 'ComponentStateBinding.toParentPathFromChildPath', childPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = childPath.slice(longestMatchPath.length); // include the dot\r\n    const matchParentPath = this._parentPathByChildPath.get(longestMatchPath);\r\n    if (typeof matchParentPath === \"undefined\") {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No parent path found for child path \"${childPath}\"`,\r\n        context: {\r\n          where: 'ComponentStateBinding.toParentPathFromChildPath',\r\n          childPath,\r\n          longestMatchPath,\r\n        },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    return matchParentPath + remainPath;\r\n  }\r\n\r\n  /**\r\n   * Converts a parent path to its corresponding child path.\r\n   * Uses longest match algorithm and concatenates remaining segments.\r\n   * Throws error if no matching child path is found.\r\n   * \r\n   * @param parentPath - Parent component state path\r\n   * @returns Corresponding child path string\r\n   * @throws STATE-302 No child path found for parent path\r\n   */\r\n  toChildPathFromParentPath(parentPath: string): string {\r\n    // Parent to child: Find longest matching entry in parentPaths, concatenate remaining segments to child\r\n    const parentPathInfo = getStructuredPathInfo(parentPath);\r\n    const matchPaths = parentPathInfo.cumulativePathSet.intersection(this.parentPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No child path found for parent path \"${parentPath}\"`,\r\n        context: { where: 'ComponentStateBinding.toChildPathFromParentPath', parentPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = parentPath.slice(longestMatchPath.length); // include the dot\r\n    const matchChildPath = this._childPathByParentPath.get(longestMatchPath);\r\n    if (typeof matchChildPath === \"undefined\") {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n        message: `No child path found for parent path \"${parentPath}\"`,\r\n        context: {\r\n          where: 'ComponentStateBinding.toChildPathFromParentPath',\r\n          parentPath,\r\n          longestMatchPath,\r\n        },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    return matchChildPath + remainPath;\r\n  }\r\n\r\n  /**\r\n   * Checks if the given child path has a registered mapping.\r\n   * Returns the longest matching child path, or null if no match exists.\r\n   * \r\n   * @param childPathInfo - Structured path information for child path\r\n   * @returns Longest matching child path string or null\r\n   */\r\n  startsWithByChildPath(childPathInfo: IStructuredPathInfo): string | null {\r\n    if (this.childPaths.size === 0) {\r\n      return null;\r\n    }\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      return null;\r\n    } else {\r\n      const matches = Array.from(matchPaths);\r\n      const longestMatchPath = matches[matches.length - 1];\r\n      return longestMatchPath;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Binds parent and child components by collecting and registering all bindings\r\n   * from parent to child component.\r\n   * \r\n   * @param parentComponent - Parent StructiveComponent instance\r\n   * @param childComponent - Child StructiveComponent instance\r\n   */\r\n  bind(parentComponent: StructiveComponent, childComponent: StructiveComponent): void {\r\n    // bindParentComponent\r\n    const bindings = parentComponent.getBindingsFromChild(childComponent);\r\n    for (const binding of bindings ?? []) {\r\n      this.addBinding(binding);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a component state binding instance for managing parent-child state mappings.\r\n * \r\n * @returns IComponentStateBinding instance\r\n */\r\nexport function createComponentStateBinding(): IComponentStateBinding {\r\n  return new ComponentStateBinding();\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { SetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { createUpdater } from \"../Updater/Updater\";\r\nimport { raiseError } from \"../utils\";\r\nimport { AssignStateSymbol, NotifyRedrawSymbol } from \"./symbols\";\r\nimport { IComponentStateInput, IComponentStateInputHandler } from \"./types\";\r\n\r\n/**\r\n * Handler class for ComponentStateInput proxy.\r\n * Manages state property access, assignment, and redraw notifications\r\n * by coordinating with the component engine and state binding.\r\n */\r\nclass ComponentStateInputHandler implements IComponentStateInputHandler {\r\n  private _componentStateBinding: IComponentStateBinding;\r\n  private _engine: IComponentEngine;\r\n  /**\r\n   * Constructor initializes component state input handler.\r\n   * \r\n   * @param engine - Component engine instance\r\n   * @param componentStateBinding - State binding configuration for path mapping\r\n   */\r\n  constructor(engine:IComponentEngine, componentStateBinding: IComponentStateBinding) {\r\n    this._componentStateBinding = componentStateBinding;\r\n    this._engine = engine;\r\n  }\r\n\r\n  /**\r\n   * Assigns multiple state properties from an object synchronously.\r\n   * \r\n   * @param object - Key-value pairs of state properties to assign\r\n   */\r\n  assignState(object: Record<string, unknown>): void {\r\n    // Synchronous processing\r\n    createUpdater<void>(this._engine, (updater) => {\r\n      updater.update(null, (stateProxy, ) => {\r\n        for(const [key, value] of Object.entries(object)) {\r\n          const childPathInfo = getStructuredPathInfo(key);\r\n          const childRef = getStatePropertyRef(childPathInfo, null);\r\n          stateProxy[SetByRefSymbol](childRef, value);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notifies the component to redraw based on parent state property changes.\r\n   * Translates parent paths to child paths and enqueues update references.\r\n   * \r\n   * @param refs - Array of parent state property references that have changed\r\n   * @throws LIST-201 ListIndex not found for parent ref\r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    createUpdater<void>(this._engine, (updater) => {\r\n      for(const parentPathRef of refs) {\r\n        let childPath;\r\n        try {\r\n          childPath = this._componentStateBinding.toChildPathFromParentPath(parentPathRef.info.pattern);\r\n        } catch(_e) {\r\n          // Ignore non-target paths\r\n          continue;\r\n        }\r\n        const childPathInfo = getStructuredPathInfo(childPath);\r\n        const atIndex = childPathInfo.wildcardCount - 1;\r\n        const childListIndex = (atIndex >= 0) ? (parentPathRef.listIndex?.at(atIndex) ?? null) : null;\r\n        if (atIndex >= 0 && childListIndex === null) {\r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found for parent ref: ${parentPathRef.info.pattern}`,\r\n            context: {\r\n              where: 'ComponentStateInput.notifyRedraw',\r\n              parentPattern: parentPathRef.info.pattern,\r\n              childPattern: childPathInfo.pattern,\r\n            },\r\n            docsUrl: './docs/error-codes.md#list',\r\n          });\r\n        }\r\n        const childRef = getStatePropertyRef(childPathInfo, childListIndex);\r\n        // Add to state update queue based on ref information\r\n        updater.enqueueRef(childRef);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Proxy get trap for accessing state properties and symbol-based methods.\r\n   * \r\n   * @param target - Proxy target object\r\n   * @param prop - Property key being accessed\r\n   * @param receiver - Proxy receiver\r\n   * @returns Property value or bound method\r\n   * @throws Error if property is not supported\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  get(_target: any, prop: PropertyKey, _receiver: IComponentStateInput): unknown {\r\n    if (prop === AssignStateSymbol) {\r\n      return this.assignState.bind(this);\r\n    } else if (prop === NotifyRedrawSymbol) {\r\n      return this.notifyRedraw.bind(this);\r\n    } else if (typeof prop === \"string\") {\r\n      const ref = getStatePropertyRef(getStructuredPathInfo(prop), null);\r\n      return this._engine.getPropertyValue(ref);\r\n    }\r\n    raiseError({\r\n      code: 'STATE-204',\r\n      message: `ComponentStateInput property not supported: ${String(prop)}`,\r\n      context: { where: 'ComponentStateInput.get', prop: String(prop) },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Proxy set trap for updating state properties.\r\n   * \r\n   * @param target - Proxy target object\r\n   * @param prop - Property key being set\r\n   * @param value - New value to assign\r\n   * @param receiver - Proxy receiver\r\n   * @returns true if set operation succeeded\r\n   * @throws Error if property is not supported\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  set(_target: any, prop: PropertyKey, value: any, _receiver: IComponentStateInput): boolean {\r\n    if (typeof prop === \"string\") {\r\n      const ref = getStatePropertyRef(getStructuredPathInfo(prop), null);\r\n      this._engine.setPropertyValue(ref, value);\r\n      return true;\r\n    }\r\n    raiseError({\r\n      code: 'STATE-204',\r\n      message: `ComponentStateInput property not supported: ${String(prop)}`,\r\n      context: { where: 'ComponentStateInput.set', prop: String(prop) },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a component state input proxy for managing parent-child state bindings.\r\n * \r\n * @param engine - Component engine instance\r\n * @param componentStateBinding - State binding configuration for parent-child path mapping\r\n * @returns Proxied component state input interface\r\n */\r\nexport function createComponentStateInput(\r\n  engine: IComponentEngine,\r\n  componentStateBinding: IComponentStateBinding\r\n): IComponentStateInput {\r\n  const handler = new ComponentStateInputHandler(engine, componentStateBinding);\r\n  return new Proxy({}, handler) as IComponentStateInput;\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IComponentStateOutput } from \"./types\";\r\n\r\n/**\r\n * Implementation of component state output that bridges child and parent component states.\r\n * Translates child component state operations to parent component state operations\r\n * using path mapping from the component state binding.\r\n */\r\nclass ComponentStateOutput implements IComponentStateOutput {\r\n  private _binding: IComponentStateBinding;\r\n  private _childEngine: IComponentEngine;\r\n  private _parentPaths: Set<string> = new Set<string>();\r\n  /**\r\n   * Constructor initializes component state output.\r\n   * \r\n   * @param binding - Component state binding for path mapping\r\n   * @param childEngine - Child component engine\r\n   */\r\n  constructor(binding: IComponentStateBinding, childEngine: IComponentEngine) {\r\n    this._binding = binding;\r\n    this._childEngine = childEngine;\r\n  }\r\n\r\n  /**\r\n   * Gets the value of a child state property by delegating to the parent component.\r\n   * Translates the child path to parent path and retrieves the value from parent engine.\r\n   * \r\n   * @param ref - Child state property reference\r\n   * @returns The value from the parent component state\r\n   * @throws CSO-101 No child path found for path\r\n   * @throws CSO-102 No binding found for child path\r\n   */\r\n  get(ref: IStatePropertyRef): unknown {\r\n    const childPath = this._binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError({\r\n        code: 'CSO-101',\r\n        message: `Child path not found: ${ref.info.pattern}`,\r\n        context: { where: 'ComponentStateOutput.get', path: ref.info.pattern },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentBinding = this._binding.bindingByChildPath.get(childPath);\r\n    if (typeof parentBinding === \"undefined\") {\r\n      raiseError({\r\n        code: 'CSO-102',\r\n        message: `Child binding not registered: ${childPath}`,\r\n        context: { where: 'ComponentStateOutput.get', childPath },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentPath = this._binding.toParentPathFromChildPath(ref.info.pattern);\r\n    const parentInfo = getStructuredPathInfo(parentPath);\r\n    const parentRef = getStatePropertyRef(parentInfo, ref.listIndex ?? parentBinding.bindingState.listIndex);\r\n    if (!this._parentPaths.has(parentRef.info.pattern)) {\r\n      const isList = this._childEngine.pathManager.lists.has(ref.info.pattern);\r\n      parentBinding.engine.pathManager.addPath(parentRef.info.pattern, isList);\r\n      this._parentPaths.add(parentRef.info.pattern);\r\n    }\r\n    return parentBinding.engine.getPropertyValue(parentRef);\r\n  }\r\n\r\n  /**\r\n   * Sets the value of a child state property by delegating to the parent component.\r\n   * Translates the child path to parent path and sets the value in parent engine.\r\n   * \r\n   * @param ref - Child state property reference\r\n   * @param value - New value to set\r\n   * @returns true if the operation succeeded\r\n   * @throws CSO-101 No child path found for path\r\n   * @throws CSO-102 No binding found for child path\r\n   */\r\n  set(ref: IStatePropertyRef, value: unknown): boolean {\r\n    const childPath = this._binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError({\r\n        code: 'CSO-101',\r\n        message: `Child path not found: ${ref.info.pattern}`,\r\n        context: { where: 'ComponentStateOutput.set', path: ref.info.pattern },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentBinding = this._binding.bindingByChildPath.get(childPath);\r\n    if (typeof parentBinding === \"undefined\") {\r\n      raiseError({\r\n        code: 'CSO-102',\r\n        message: `Child binding not registered: ${childPath}`,\r\n        context: { where: 'ComponentStateOutput.set', childPath },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentPath = this._binding.toParentPathFromChildPath(ref.info.pattern);\r\n    const parentInfo = getStructuredPathInfo(parentPath);\r\n    const parentRef = getStatePropertyRef(parentInfo, ref.listIndex ?? parentBinding.bindingState.listIndex);\r\n    if (!this._parentPaths.has(parentRef.info.pattern)) {\r\n      const isList = this._childEngine.pathManager.lists.has(ref.info.pattern);\r\n      parentBinding.engine.pathManager.addPath(parentRef.info.pattern, isList);\r\n      this._parentPaths.add(parentRef.info.pattern);\r\n    }\r\n    parentBinding.engine.setPropertyValue(parentRef, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if a given path pattern is handled by this state output.\r\n   * \r\n   * @param pathInfo - Structured path information to check\r\n   * @returns true if the path matches a child path in the binding\r\n   */\r\n  startsWith(pathInfo: IStructuredPathInfo): boolean {\r\n    return this._binding.startsWithByChildPath(pathInfo) !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets list indexes for a child state property by delegating to the parent component.\r\n   * Translates the child path to parent path and retrieves list indexes from parent engine.\r\n   * \r\n   * @param ref - Child state property reference\r\n   * @returns Array of list indexes or null if not a list\r\n   * @throws CSO-101 No child path found for path\r\n   * @throws CSO-102 No binding found for child path\r\n   */\r\n  getListIndexes(ref: IStatePropertyRef): IListIndex[] | null {\r\n    const childPath = this._binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError({\r\n        code: 'CSO-101',\r\n        message: `Child path not found: ${ref.info.pattern}`,\r\n        context: { where: 'ComponentStateOutput.getListIndexes', path: ref.info.pattern },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentBinding = this._binding.bindingByChildPath.get(childPath);\r\n    if (typeof parentBinding === \"undefined\") {\r\n      raiseError({\r\n        code: 'CSO-102',\r\n        message: `Child binding not registered: ${childPath}`,\r\n        context: { where: 'ComponentStateOutput.getListIndexes', childPath },\r\n        docsUrl: './docs/error-codes.md#cso',\r\n      });\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this._binding.toParentPathFromChildPath(ref.info.pattern));\r\n    const parentRef = getStatePropertyRef(parentPathInfo, ref.listIndex);\r\n    if (!this._parentPaths.has(parentRef.info.pattern)) {\r\n      const isList = this._childEngine.pathManager.lists.has(ref.info.pattern);\r\n      parentBinding.engine.pathManager.addPath(parentRef.info.pattern, isList);\r\n      this._parentPaths.add(parentRef.info.pattern);\r\n    }\r\n    return parentBinding.engine.getListIndexes(parentRef);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a component state output instance for bridging child and parent component states.\r\n * \r\n * @param binding - Component state binding for path mapping between child and parent\r\n * @param childEngine - Child component engine for accessing child state metadata\r\n * @returns Component state output interface\r\n */\r\nexport function createComponentStateOutput(\r\n  binding: IComponentStateBinding, \r\n  childEngine: IComponentEngine\r\n): IComponentStateOutput {\r\n  return new ComponentStateOutput(binding, childEngine);\r\n}","import { raiseError } from \"../utils\";\r\nimport { IUpdateCompleteQueue, UpdateComplete } from \"./types\";\r\n\r\ninterface ICompletedQueueItem {\r\n  completePromise: UpdateComplete;\r\n  notifyResolver: PromiseWithResolvers<boolean>;\r\n}\r\n\r\nclass UpdateCompleteQueue implements IUpdateCompleteQueue {\r\n  private _queue: ICompletedQueueItem[] = [];\r\n  private _processing: boolean = false;\r\n\r\n  private get _currentItem(): ICompletedQueueItem | null {\r\n    return this._queue.length > 0 ? this._queue[0] : null;\r\n  }\r\n\r\n  get current(): UpdateComplete | null {\r\n    return this._currentItem ? this._currentItem.notifyResolver.promise : null;\r\n  }\r\n\r\n  private async _processNext(resolver: PromiseWithResolvers<void>) {\r\n    const item = this._currentItem ?? raiseError({\r\n      code: 'UPD-301',\r\n      message: 'No item in update complete queue to process',\r\n      context: { where: 'CompleteQueue.processNext' },\r\n      docsUrl: './docs/error-codes.md#upd',\r\n    });\r\n    let retValue = false;\r\n    try {\r\n      retValue = await item.completePromise; // 先につかむとは限らない\r\n    } finally {\r\n      this._queue.shift();\r\n      item.notifyResolver.resolve(retValue);\r\n      resolver.resolve();\r\n    }\r\n  }\r\n\r\n  private async _processQueue() {\r\n    if (this._processing) {\r\n      return;\r\n    }\r\n    this._processing = true;\r\n    try {\r\n      while (this._queue.length > 0) {\r\n        const resolver = Promise.withResolvers<void>();\r\n        queueMicrotask(() => {\r\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n          this._processNext(resolver);\r\n        });\r\n        await resolver.promise;\r\n      }\r\n    } finally {\r\n      this._processing = false;\r\n    }\r\n  }\r\n\r\n  enqueue(updateComplete: UpdateComplete): void {\r\n    this._queue.push({\r\n      completePromise: updateComplete,\r\n      notifyResolver: Promise.withResolvers<boolean>(),\r\n    });\r\n    if (!this._processing) {\r\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n      this._processQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function createCompleteQueue(): IUpdateCompleteQueue {\r\n  return new UpdateCompleteQueue();\r\n}\r\n\r\n// Export for testing purposes only\r\nexport { UpdateCompleteQueue as _UpdateCompleteQueue };","import { createBindContent } from \"../DataBinding/BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { IState, IStructiveState } from \"../StateClass/types\";\r\nimport { ComponentType, IComponentConfig, IComponentStatic, StructiveComponent } from \"../WebComponents/types\";\r\nimport { attachShadow } from \"./attachShadow.js\";\r\nimport { IComponentEngine, ICacheEntry, IVersionRevision, IPropertyRefMetadata } from \"./types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, GetListIndexesByRefSymbol, SetByRefSymbol } from \"../StateClass/symbols.js\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types.js\";\r\nimport { createComponentStateBinding } from \"../ComponentStateBinding/createComponentStateBinding.js\";\r\nimport { createComponentStateInput } from \"../ComponentStateInput/createComponentStateInput.js\";\r\nimport { createComponentStateOutput } from \"../ComponentStateOutput/createComponentStateOutput.js\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { IComponentStateOutput } from \"../ComponentStateOutput/types.js\";\r\nimport { AssignStateSymbol } from \"../ComponentStateInput/symbols.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { createUpdater } from \"../Updater/Updater.js\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef.js\";\r\nimport { RESERVED_WORD_SET } from \"../constants.js\";\r\nimport { addPathNode } from \"../PathTree/PathNode.js\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types.js\";\r\nimport { createCompleteQueue } from \"../Updater/CompleteQueue.js\";\r\nimport { IUpdateCompleteQueue } from \"../Updater/types.js\";\r\n\r\n/**\r\n * ComponentEngine integrates state, dependencies, bindings, lifecycle, and rendering\r\n * for Structive components as the core engine.\r\n *\r\n * Key Responsibilities:\r\n * - State instance and proxy generation/management\r\n * - Template/stylesheet/filter/binding management\r\n * - Dependency graph (PathTree) construction and maintenance\r\n * - Binding and list information storage/retrieval\r\n * - Lifecycle (connected/disconnected) processing\r\n * - Shadow DOM application or block mode placeholder management\r\n * - State property get/set operations\r\n * - Binding addition, existence checking, and list management\r\n *\r\n * Error Codes:\r\n * - BIND-201: BindContent not initialized yet / Block parent node not set\r\n * - STATE-202: Failed to parse state from dataset\r\n *\r\n * Design Notes:\r\n * - Provides async initialization via readyResolvers\r\n * - Achieves efficient rendering through batch updates with Updater\r\n */\r\n\r\nclass ComponentEngine implements IComponentEngine {\r\n  // ===== Readonly fields (Core component resources) =====\r\n  /** Component type: 'autonomous' or 'builtin' */\r\n  readonly type: ComponentType = 'autonomous';\r\n  /** Component configuration */\r\n  readonly config: IComponentConfig;\r\n\r\n  /** HTMLTemplateElement for component rendering */\r\n  readonly template: HTMLTemplateElement;\r\n  /** CSSStyleSheet for component styling */\r\n  readonly styleSheet: CSSStyleSheet;\r\n  /** State class constructor */\r\n  readonly stateClass: IStructiveState;\r\n  /** State instance */\r\n  readonly state: IState;\r\n  /** Input filter functions */\r\n  readonly inputFilters: FilterWithOptions;\r\n  /** Output filter functions */\r\n  readonly outputFilters: FilterWithOptions;\r\n  /** Base HTML element class */\r\n  readonly baseClass: typeof HTMLElement = HTMLElement;\r\n  /** Owner component instance */\r\n  readonly owner: StructiveComponent;\r\n\r\n  /** Path manager for dependency tracking */\r\n  readonly pathManager: IPathManager;\r\n  /** Promise resolvers for async initialization */\r\n  readonly readyResolvers: PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n\r\n  /** State input proxy for parent-to-child communication */\r\n  readonly stateInput: IComponentStateInput;\r\n  /** State output proxy for child-to-parent communication */\r\n  readonly stateOutput: IComponentStateOutput;\r\n  /** State binding for parent-child relationship */\r\n  readonly stateBinding: IComponentStateBinding;\r\n\r\n  /** Map of child components to their bindings */\r\n  readonly bindingsByComponent: WeakMap<StructiveComponent, Set<IBinding>> = new WeakMap();\r\n  /** Set of child Structive components */\r\n  readonly structiveChildComponents: Set<StructiveComponent> = new Set();\r\n  /** Version and revision tracking by path */\r\n  readonly versionRevisionByPath: Map<string, IVersionRevision> = new Map();\r\n\r\n  readonly updateCompleteQueue: IUpdateCompleteQueue = createCompleteQueue();\r\n  \r\n  // ===== Private fields (Internal state) =====\r\n  /** Bind content instance (initialized in setup()) */\r\n  private _bindContent: IBindContent | null = null;\r\n  /** Block mode placeholder comment node */\r\n  private _blockPlaceholder: Comment | null = null;\r\n  /** Block mode placeholder parent node */\r\n  private _blockParentNode: Node | null = null;\r\n  /** Flag to ignore disconnectedCallback during replaceWith */\r\n  private _ignoreDissconnectedCallback: boolean = false;\r\n  /** Current version number for change tracking */\r\n  private _currentVersion: number = 0;\r\n  /** WeakMap storing binding metadata by property reference */\r\n  private _propertyRefMetadataByRef: WeakMap<IStatePropertyRef, IPropertyRefMetadata> = new WeakMap();\r\n\r\n  /**\r\n   * Constructs a new ComponentEngine instance.\r\n   * Initializes all readonly fields and creates state management infrastructure.\r\n   * \r\n   * @param config - Component configuration\r\n   * @param owner - Owner component instance\r\n   */\r\n  constructor(config: IComponentConfig, owner: StructiveComponent) {\r\n    this.config = config;\r\n    // Set type to 'builtin' if extending native elements\r\n    if (this.config.extends) {\r\n      this.type = 'builtin';\r\n    }\r\n    const componentClass = owner.constructor as IComponentStatic;\r\n    this.template = componentClass.template;\r\n    this.styleSheet = componentClass.styleSheet;\r\n    this.stateClass = componentClass.stateClass;\r\n    this.state = new this.stateClass();\r\n    this.inputFilters = componentClass.inputFilters;\r\n    this.outputFilters = componentClass.outputFilters;\r\n    this.owner = owner;\r\n    this.stateBinding = createComponentStateBinding();\r\n    this.stateInput = createComponentStateInput(this, this.stateBinding);\r\n    this.stateOutput = createComponentStateOutput(this.stateBinding, this);\r\n    this.pathManager = componentClass.pathManager;\r\n  }\r\n\r\n  // ===== Getters =====\r\n  /**\r\n   * Gets the bind content instance.\r\n   * Throws BIND-201 if accessed before setup() is called.\r\n   * \r\n   * @returns IBindContent instance\r\n  * @throws BIND-201 BindContent not initialized yet\r\n   */\r\n  get bindContent(): IBindContent {\r\n    if (this._bindContent === null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'BindContent not initialized yet',\r\n        context: { where: 'ComponentEngine.bindContent.get', componentId: (this.owner.constructor as IComponentStatic).id },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    return this._bindContent;\r\n  }\r\n\r\n  /**\r\n   * Gets the current version number for change tracking.\r\n   * \r\n   * @returns Current version number\r\n   */\r\n  get currentVersion(): number {\r\n    return this._currentVersion;\r\n  }\r\n\r\n  // ===== Public methods =====\r\n  /**\r\n   * Increments and returns the version number.\r\n   * Used for invalidating caches when state changes.\r\n   * \r\n   * @returns New version number\r\n   */\r\n  versionUp(): number {\r\n    return ++this._currentVersion;\r\n  }\r\n\r\n  /**\r\n   * Sets up the component engine.\r\n   * Registers all state properties to PathManager and creates bindContent.\r\n   * Must be called after construction and before connectedCallback.\r\n   */\r\n  setup(): void {\r\n    // Register all instantiated state object properties to PathManager\r\n    // TODO: Should traverse prototype chain for inherited properties\r\n    for(const path in this.state) {\r\n      if (RESERVED_WORD_SET.has(path) || this.pathManager.alls.has(path)) {\r\n        continue;\r\n      }\r\n      this.pathManager.alls.add(path);\r\n      addPathNode(this.pathManager.rootNode, path);\r\n    }\r\n    const componentClass = this.owner.constructor as IComponentStatic;\r\n    const rootRef = getStatePropertyRef(getStructuredPathInfo(''), null);\r\n    // Create bindContent (may modify stateArrayPropertyNamePatterns)\r\n    this._bindContent = createBindContent(null, componentClass.id, this, rootRef);\r\n  }\r\n\r\n  /**\r\n   * Handles component connection to DOM.\r\n   * - Attaches Shadow DOM or sets up block mode placeholder\r\n   * - Mounts bindContent\r\n   * - Initializes state from data-state attribute if present\r\n   * - Performs initial render\r\n   * - Calls state's connectedCallback if defined\r\n   * \r\n   * Why not do this in setup():\r\n   * - setup() is called at component instantiation\r\n   * - connectedCallback() is called when connected to DOM\r\n   * - State initialization and rendering must be redone if reconnected after disconnect\r\n   * \r\n  * @throws BIND-201 Block parent node not set\r\n   * @throws STATE-202 Failed to parse state from dataset\r\n   * @throws COMP-301 Error in connectedCallback\r\n   */\r\n  connectedCallback(): void {\r\n    if (this.config.enableWebComponents) {\r\n      attachShadow(this.owner, this.config, this.styleSheet);\r\n    } else {\r\n      // Block mode: Replace component with placeholder\r\n      this._blockParentNode = this.owner.parentNode;\r\n      this._blockPlaceholder = document.createComment(\"Structive block placeholder\");\r\n      // Set flag to ignore disconnectedCallback triggered by replaceWith\r\n      this._ignoreDissconnectedCallback = true;\r\n      try {\r\n        this.owner.replaceWith(this._blockPlaceholder);\r\n      } finally {\r\n        this._ignoreDissconnectedCallback = false;\r\n      }\r\n    }\r\n\r\n    if (this.config.enableWebComponents) {\r\n      // Mount bind content to Shadow DOM\r\n      this.bindContent.mount(this.owner.shadowRoot ?? this.owner);\r\n    } else {\r\n      // Mount bind content after block placeholder\r\n      const parentNode = this._blockParentNode ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Block parent node not set',\r\n        context: { where: 'ComponentEngine.connectedCallback', mode: 'block' },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n      this.bindContent.mountAfter(parentNode, this._blockPlaceholder);\r\n    }\r\n\r\n    // Initialize component state from data-state attribute if present\r\n    if (this.owner.dataset.state) {\r\n      try {\r\n        const json = JSON.parse(this.owner.dataset.state) as Record<string, unknown>;\r\n        this.stateInput[AssignStateSymbol](json);\r\n      } catch(e) {\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'Failed to parse state from dataset',\r\n          context: { where: 'ComponentEngine.connectedCallback', datasetState: this.owner.dataset.state },\r\n          docsUrl: './docs/error-codes.md#state',\r\n          cause: e,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Perform initial render\r\n    this.bindContent.activate();\r\n    createUpdater<void>(this, (updater) => {\r\n      updater.initialRender(this.bindContent);\r\n    });\r\n\r\n    // Call state's connectedCallback if implemented\r\n    if (this.pathManager.hasConnectedCallback) {\r\n      const resultPromise = createUpdater<Promise<void> | void>(this, (updater) => {\r\n        return updater.update(null, (stateProxy, ) => {\r\n          return stateProxy[ConnectedCallbackSymbol]();\r\n        });\r\n      });\r\n      if (resultPromise instanceof Promise) {\r\n        resultPromise.finally(() => {\r\n          this.readyResolvers.resolve();\r\n        }).catch(() => {\r\n          raiseError({\r\n            code: 'COMP-301',\r\n            message: 'Connected callback failed',\r\n            context: { where: 'ComponentEngine.connectedCallback' },\r\n            docsUrl: './docs/error-codes.md#comp',\r\n          });\r\n        });\r\n      } else {\r\n        this.readyResolvers.resolve();\r\n      }\r\n    } else {\r\n      this.readyResolvers.resolve();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles component disconnection from DOM.\r\n   * - Calls state's disconnectedCallback if defined\r\n   * - Unregisters from parent component\r\n   * - Removes block placeholder if in block mode\r\n   * - Inactivates and unmounts bindContent\r\n   * @throws COMP-302 Error in disconnectedCallback\r\n   */\r\n  disconnectedCallback(): void {\r\n    // Ignore if flag is set (during replaceWith in connectedCallback)\r\n    if (this._ignoreDissconnectedCallback) {return;}\r\n\r\n    try {\r\n      // Call state's disconnectedCallback if implemented (synchronous)\r\n      if (this.pathManager.hasDisconnectedCallback) {\r\n        createUpdater<void>(this, (updater) => {\r\n          updater.update(null, (stateProxy, ) => {\r\n            stateProxy[DisconnectedCallbackSymbol]();\r\n          });\r\n        });\r\n      }\r\n    } catch(e) {\r\n      raiseError({\r\n        code: 'COMP-302',\r\n        message: 'Disconnected callback failed',\r\n        context: { where: 'ComponentEngine.disconnectedCallback' },\r\n        docsUrl: './docs/error-codes.md#comp',\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        cause: e as any,\r\n      });\r\n    } finally {\r\n      // Unregister from parent component\r\n      this.owner.parentStructiveComponent?.unregisterChildComponent(this.owner);\r\n      if (!this.config.enableWebComponents) {\r\n        this._blockPlaceholder?.remove();\r\n        this._blockPlaceholder = null;\r\n        this._blockParentNode = null;\r\n      }\r\n      // Inactivate state and unmount (bindContent.unmount is called within inactivate)\r\n      this.bindContent.inactivate();\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Gets list indexes for a property reference.\r\n   * Delegates to stateOutput if the path matches parent-child binding.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Array of list indexes or null if not a list\r\n   */\r\n  getListIndexes(ref: IStatePropertyRef): IListIndex[] | null {\r\n    if (this.stateOutput.startsWith(ref.info)) {\r\n      return this.stateOutput.getListIndexes(ref);\r\n    }\r\n    let value: IListIndex[] | null = null;\r\n    // Synchronous operation\r\n    createUpdater<IListIndex[] | null>(this, (updater) => {\r\n      return value = updater.createReadonlyState<IListIndex[] | null>((stateProxy, ) => {\r\n        return stateProxy[GetListIndexesByRefSymbol](ref);\r\n      });\r\n    });\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Gets a property value by reference.\r\n   * Uses readonly state proxy to access the value synchronously.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Property value\r\n   */\r\n  getPropertyValue(ref: IStatePropertyRef): unknown {\r\n    let value: unknown;\r\n    // Synchronous operation\r\n    createUpdater(this, (updater) => {\r\n      value = updater.createReadonlyState((stateProxy, ) => {\r\n        return stateProxy[GetByRefSymbol](ref);\r\n      });\r\n    });\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Sets a property value by reference.\r\n   * Uses writable state proxy to set the value synchronously.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param value - New value to set\r\n   */\r\n  setPropertyValue(ref: IStatePropertyRef, value: unknown): void {\r\n    // Synchronous operation\r\n    createUpdater<void>(this, (updater) => {\r\n      updater.update(null, (stateProxy, ) => {\r\n        stateProxy[SetByRefSymbol](ref, value);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Registers a child Structive component.\r\n   * Used for parent-child relationship tracking.\r\n   * \r\n   * @param component - Child StructiveComponent instance to register\r\n   */\r\n  registerChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.add(component);\r\n  }\r\n\r\n  /**\r\n   * Unregisters a child Structive component.\r\n   * Called when child is disconnected or destroyed.\r\n   * \r\n   * @param component - Child StructiveComponent instance to unregister\r\n   */\r\n  unregisterChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.delete(component);\r\n  }\r\n\r\n  /**\r\n   * Gets the cache entry for a property reference.\r\n   * Returns null if no cache exists.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Cache entry or null\r\n   */\r\n  getCacheEntry(ref: IStatePropertyRef): ICacheEntry | null {\r\n    return this._propertyRefMetadataByRef.get(ref)?.cacheEntry ?? null;\r\n  }\r\n\r\n  /**\r\n   * Sets the cache entry for a property reference.\r\n   * Creates a new PropertyRefMetadata if it doesn't exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param entry - Cache entry to set\r\n   */\r\n  setCacheEntry(ref: IStatePropertyRef, entry: ICacheEntry): void {\r\n    const metadata = this._propertyRefMetadataByRef.get(ref);\r\n    if (typeof metadata === \"undefined\") {\r\n      this._propertyRefMetadataByRef.set(ref, { bindings: [], cacheEntry: entry });\r\n    } else {\r\n      metadata.cacheEntry = entry;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets all bindings associated with a property reference.\r\n   * Returns empty array if no bindings exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @returns Array of IBinding instances\r\n   */\r\n  getBindings(ref: IStatePropertyRef): IBinding[] {\r\n    return this._propertyRefMetadataByRef.get(ref)?.bindings ?? [];\r\n  }\r\n\r\n  /**\r\n   * Saves a binding for a property reference.\r\n   * Creates a new PropertyRefMetadata if it doesn't exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param binding - IBinding instance to save\r\n   */\r\n  saveBinding(ref: IStatePropertyRef, binding: IBinding): void {\r\n    const metadata = this._propertyRefMetadataByRef.get(ref);\r\n    if (typeof metadata === \"undefined\") {\r\n      this._propertyRefMetadataByRef.set(ref, { bindings: [binding], cacheEntry: null });\r\n    } else {\r\n      metadata.bindings.push(binding);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a binding from a property reference.\r\n   * Does nothing if the binding doesn't exist.\r\n   * \r\n   * @param ref - State property reference\r\n   * @param binding - IBinding instance to remove\r\n   */\r\n  removeBinding(ref: IStatePropertyRef, binding: IBinding): void {\r\n    const metadata = this._propertyRefMetadataByRef.get(ref);\r\n    if (typeof metadata !== \"undefined\") {\r\n      const index = metadata.bindings.indexOf(binding);\r\n      if (index >= 0) {\r\n        metadata.bindings.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n * Factory function to create a ComponentEngine instance.\r\n * \r\n * @param config - Component configuration\r\n * @param component - Owner component instance\r\n * @returns A new ComponentEngine instance\r\n */\r\nexport function createComponentEngine(config: IComponentConfig, component: StructiveComponent): IComponentEngine {\r\n  return new ComponentEngine(config, component);\r\n}","/**\r\n * replaceMustacheWithTemplateTag.ts\r\n *\r\n * Utility function to convert Mustache syntax ({{if:condition}}, {{for:expr}}, {{endif}}, {{endfor}}, \r\n * {{elseif:condition}}, {{else}}, etc.) into <template> tags or comment nodes.\r\n *\r\n * Main responsibilities:\r\n * - Detects Mustache syntax in HTML strings using regex and converts them to <template data-bind=\"...\"> or comment nodes\r\n * - Converts control structures like if/for/endif/endfor/elseif/else into <template> tags with nesting support\r\n * - Converts regular embedded expressions ({{expr}}) into comment nodes (<!--embed:expr-->)\r\n *\r\n * Design points:\r\n * - Uses a stack to manage nested structures and strictly checks correspondence of endif/endfor/elseif/else\r\n * - Throws exceptions via raiseError for invalid nesting or unsupported syntax\r\n * - elseif/else automatically generate templates with negated conditions to express conditional branching\r\n * - Conversion to comment nodes enables safe DOM insertion of embedded expressions\r\n */\r\nimport { COMMENT_EMBED_MARK } from \"../constants.js\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\n/** Regular expression to match Mustache syntax: {{ ... }} */\r\nconst MUSTACHE_REGEXP = /\\{\\{([^}]+)\\}\\}/g;\r\n\r\n/** Union type for all supported Mustache control structures */\r\ntype MustacheType = 'if' | 'for' | 'endif' | 'endfor' | 'elseif' | 'else';\r\n\r\n/** Information about a parsed Mustache tag */\r\ntype MustacheInfo = {\r\n  /** The control structure type (if, for, etc.) */\r\n  type: MustacheType;\r\n  /** The expression after the first ':' character */\r\n  remain: string;\r\n  /** The full expression string */\r\n  expr: string;\r\n}\r\n\r\n/**\r\n * Converts Mustache syntax in HTML strings to template tags or comment nodes.\r\n * Processes control structures (if/for/elseif/else) and embedded expressions,\r\n * maintaining proper nesting through a stack-based parser.\r\n * \r\n * @param {string} html - HTML string containing Mustache syntax ({{...}})\r\n * @returns {string} HTML string with Mustache syntax replaced by template tags and comments\r\n * @throws {Error} Throws TMP-102 error for invalid nesting (endif without if, endfor without for, etc.)\r\n * \r\n * @example\r\n * const html = '<div>{{if:active}}<span>{{name}}</span>{{endif}}</div>';\r\n * const result = replaceMustacheWithTemplateTag(html);\r\n * // Returns: '<div><template data-bind=\"if:active\"><span><!--embed:name--></span></template></div>'\r\n */\r\nexport function replaceMustacheWithTemplateTag(html: string): string {\r\n  // Stack to track nested control structures (if/for/elseif)\r\n  const stack:MustacheInfo[] = [];\r\n  \r\n  return html.replaceAll(MUSTACHE_REGEXP, (_match, expression: string): string => {\r\n    const expr = expression.trim();\r\n    \r\n    // Extract the type (first part before ':')\r\n    const [ type ] = expr.split(':');\r\n\r\n    // If not a control structure, treat as embedded expression\r\n    if (type !== 'if' && type !== 'for' && type !== 'endif' && type !== 'endfor' && type !== 'elseif' && type !== 'else') {\r\n      // Convert to comment node for later processing\r\n      return `<!--${COMMENT_EMBED_MARK}${expr}-->`;\r\n    }\r\n    \r\n    // Extract the remaining expression after the type\r\n    const remain = expr.slice(type.length + 1).trim();\r\n    const currentInfo:MustacheInfo = { type, expr, remain };\r\n    \r\n    // Handle opening tags (if/for): push to stack and generate opening template tag\r\n    if (type === 'if' || type === 'for') {\r\n      stack.push(currentInfo);\r\n      return `<template data-bind=\"${expr}\">`;\r\n    } else if (type === 'endif') {\r\n      // Handle endif: pop stack until matching 'if' is found, closing all elseif branches\r\n      const endTags = [];\r\n      if (stack.length === 0) {\r\n        raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Endif without if',\r\n          context: { where: 'Template.replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n      while (stack.length > 0) {\r\n        const info = stack.pop()!;\r\n        // Found the matching 'if', close it and stop\r\n        if (info.type === 'if') {\r\n          endTags.push('</template>');\r\n          break;\r\n        } else if (info.type === 'elseif') {\r\n          // Close elseif branches (each elseif creates nested templates)\r\n          endTags.push('</template>');\r\n        } else {\r\n          // Invalid nesting: encountered non-if/elseif tag\r\n          raiseError({\r\n            code: 'TMP-102',\r\n            message: 'Endif without if',\r\n            context: { where: 'Template.replaceMustacheWithTemplateTag', got: info.type, expr },\r\n            docsUrl: './docs/error-codes.md#tmp',\r\n          });\r\n        }\r\n      }\r\n      return endTags.join('');\r\n    } else if (type === 'endfor') {\r\n      // Handle endfor: pop stack and verify matching 'for'\r\n      const info = stack.pop() ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Endfor without for',\r\n        context: { where: 'Template.replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      \r\n      if (info.type === 'for') {\r\n        return '</template>';\r\n      }\r\n      // Invalid nesting: endfor without corresponding for\r\n      raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Endfor without for',\r\n        context: { where: 'Template.replaceMustacheWithTemplateTag', got: info.type, expr },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n    } else if (type === 'elseif') {\r\n      const lastInfo = stack.at(-1) ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Elseif without if',\r\n        context: { where: 'Template.replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      if (lastInfo.type === 'if' || lastInfo.type === 'elseif') {\r\n        stack.push(currentInfo);\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\"><template data-bind=\"if:${remain}\">`;\r\n      }\r\n      raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Elseif without if',\r\n        context: { where: 'Template.replaceMustacheWithTemplateTag', got: lastInfo.type, expr },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n    } else if (type === 'else') {\r\n      // Handle else: verify it follows if, then create negated condition template\r\n      const lastInfo = stack.at(-1) ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Else without if',\r\n        context: { where: 'Template.replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      \r\n      if (lastInfo.type === 'if') {\r\n        // Close previous if branch and open negated condition for else\r\n        // Structure: </template><template data-bind=\"if:condition|not\">\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\">`;\r\n      }\r\n      // Invalid: else must follow if\r\n      return raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Else without if',\r\n        context: { where: 'Template.replaceMustacheWithTemplateTag', got: lastInfo.type, expr },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n    }\r\n    /* c8 ignore start */\r\n    // Unreachable code: All possible Mustache types are handled above\r\n    // This code path is theoretically impossible because:\r\n    // 1. Non-control-structure types are converted to embed comments (line 66)\r\n    // 2. All control structure types (if/for/endif/endfor/elseif/else) have explicit handlers above\r\n    return raiseError({\r\n      code: 'TMP-102',\r\n      message: 'Unreachable: All Mustache types should be handled by preceding branches',\r\n      context: { where: 'Template.replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n      docsUrl: './docs/error-codes.md#tmp',\r\n    });\r\n    /* c8 ignore stop */\r\n  });\r\n}\r\n\r\n\r\n\r\n","/**\r\n * replaceTemplateTagWithComment.ts\r\n *\r\n * Utility function to replace <template> tags with comment nodes and recursively register templates.\r\n *\r\n * Main responsibilities:\r\n * - Replaces the specified HTMLTemplateElement with a comment node (<!--template:id-->)\r\n * - Converts template tags within SVG to regular template elements, preserving attributes and child nodes\r\n * - Recursively replaces and registers nested templates within templates\r\n * - Manages templates with IDs using registerTemplate\r\n *\r\n * Design points:\r\n * - Maintains template hierarchical structure while marking them as comment nodes in the DOM\r\n * - Supports SVG and attribute inheritance for versatile template processing\r\n * - Assigns unique IDs via generateId for centralized template management\r\n */\r\nimport { COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { config } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { registerTemplate } from \"./registerTemplate.js\";\r\n\r\n/** SVG namespace URI for detecting SVG context */\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\n/**\r\n * Replaces a template element with a comment node in the DOM and recursively processes nested templates.\r\n * Handles special cases for SVG templates and preserves template hierarchies through registration.\r\n * \r\n * @param {number} id - Unique identifier for this template\r\n * @param {HTMLTemplateElement} template - The template element to replace and register\r\n * @param {number} [rootId=id] - Root template ID for tracking nested template hierarchies\r\n * @returns {number} The template ID (same as input id)\r\n * \r\n * @example\r\n * const template = document.createElement('template');\r\n * template.innerHTML = '<div>{{name}}</div>';\r\n * const templateId = replaceTemplateTagWithComment(1, template);\r\n */\r\nexport function replaceTemplateTagWithComment(\r\n  id      : number, \r\n  rawTemplate: HTMLTemplateElement,\r\n  rootId  : number = id\r\n): number {\r\n  let template = rawTemplate;\r\n  // Replace the template element with a comment node in the DOM\r\n  // This preserves the template's position while removing it from the visible DOM\r\n\r\n  // Extract data-bind attribute for optional debug information\r\n  const bindText = template.getAttribute(DATA_BIND_ATTRIBUTE);\r\n  \r\n  // In debug mode, include binding expression in comment for easier debugging\r\n  const bindTextForDebug = config.debug ? (bindText ?? \"\") : \"\";\r\n  \r\n  // Replace template with comment marker (<!--template:id bindText-->)\r\n  template.parentNode?.replaceChild(document.createComment(`${COMMENT_TEMPLATE_MARK}${id} ${bindTextForDebug}`), template);\r\n  \r\n  // Special handling for templates within SVG context\r\n  if (template.namespaceURI === SVG_NS) {\r\n    // SVG doesn't support <template> natively, so convert to HTML template element\r\n    const newTemplate = document.createElement(\"template\");\r\n    \r\n    // Move all child nodes from SVG template to new HTML template\r\n    const childNodes = Array.from(template.childNodes);\r\n    for(let i = 0; i < childNodes.length; i++) {\r\n      const childNode = childNodes[i];\r\n      newTemplate.content.appendChild(childNode);\r\n    }\r\n    \r\n    // Preserve data-bind attribute from original SVG template\r\n    newTemplate.setAttribute(DATA_BIND_ATTRIBUTE, bindText ?? \"\");\r\n    template = newTemplate;\r\n  }\r\n  \r\n  // Recursively process all nested templates within this template\r\n  // Each nested template gets its own unique ID and is registered separately\r\n  template.content.querySelectorAll(\"template\").forEach(template => {\r\n    replaceTemplateTagWithComment(generateId(), template, rootId);\r\n  });\r\n  \r\n  // Register the processed template for later instantiation\r\n  registerTemplate(id, template, rootId);\r\n  \r\n  return id;\r\n}\r\n","/**\r\n * registerHtml.ts\r\n *\r\n * Utility function for registering HTML strings as templates.\r\n *\r\n * Main responsibilities:\r\n * - Creates an HTML template with a specified ID and assigns a data-id attribute\r\n * - Converts Mustache syntax ({{ }}) to template tags (using replaceMustacheWithTemplateTag)\r\n * - Replaces template tags with comments (using replaceTemplateTagWithComment)\r\n *\r\n * Design points:\r\n * - Supports dynamic template generation/management and flexible template processing through syntax conversion\r\n * - Templates are created using document.createElement(\"template\") and identified via data-id\r\n */\r\nimport { replaceMustacheWithTemplateTag } from \"./replaceMustacheWithTemplateTag.js\";\r\nimport { replaceTemplateTagWithComment } from \"./replaceTemplateTagWithComment.js\";\r\n\r\n/**\r\n * Registers an HTML template by converting Mustache syntax to template tags and then to comments.\r\n * Creates a template element, assigns it an ID, and processes it for use in the template system.\r\n * \r\n * @param {number} id - Unique numeric identifier for the template\r\n * @param {string} html - HTML string that may contain Mustache syntax ({{ }})\r\n * @returns {void}\r\n * \r\n * @example\r\n * registerHtml(1, `\r\n *   <div>\r\n *     <h1>{{ title }}</h1>\r\n *     <p>{{ content }}</p>\r\n *   </div>\r\n * `);\r\n */\r\nexport function registerHtml(id: number, html:string) {\r\n  // Create a new template element\r\n  const template = document.createElement(\"template\");\r\n  \r\n  // Assign the template ID as a data attribute for later retrieval\r\n  template.dataset.id = id.toString();\r\n  \r\n  // Convert Mustache syntax ({{ }}) to template tags, then set as innerHTML\r\n  template.innerHTML = replaceMustacheWithTemplateTag(html);\r\n  \r\n  // Replace template tags with comment nodes for data binding\r\n  replaceTemplateTagWithComment(id, template);\r\n}","/**\r\n * getBaseClass.ts\r\n *\r\n * Utility function to retrieve the constructor (base class) of an element from a specified tag name (extendTagName).\r\n *\r\n * Main responsibilities:\r\n * - Returns the HTMLElement constructor for the specified tag if extendTagName is provided\r\n * - Returns HTMLElement if no tag name is specified\r\n *\r\n * Design points:\r\n * - Dynamically retrieves the base class for custom element inheritance, enabling flexible Web Components extension\r\n */\r\nimport { Constructor } from \"../types\";\r\n\r\n/**\r\n * Gets the base class constructor for a custom element.\r\n * \r\n * If extendTagName is provided, creates a temporary element to retrieve its constructor,\r\n * enabling customized built-in elements (e.g., extending <button>, <input>).\r\n * Otherwise, returns the standard HTMLElement constructor.\r\n * \r\n * @param {string | null} extendTagName - Tag name of the element to extend, or null for standard HTMLElement\r\n * @returns {Constructor<HTMLElement>} The constructor of the specified element or HTMLElement\r\n * \r\n * @example\r\n * // Get base class for extending a button\r\n * const ButtonClass = getBaseClass('button'); // Returns HTMLButtonElement constructor\r\n * \r\n * @example\r\n * // Get base class for standard custom element\r\n * const BaseClass = getBaseClass(null); // Returns HTMLElement\r\n */\r\nexport function getBaseClass(extendTagName: string | null):Constructor<HTMLElement> {\r\n  // If extending a built-in element, create a temporary instance to get its constructor\r\n  // Otherwise, use the standard HTMLElement class\r\n  return extendTagName ? (document.createElement(extendTagName).constructor as Constructor<HTMLElement>) : HTMLElement;\r\n}","/**\r\n * getComponentConfig.ts\r\n *\r\n * Utility function to merge user configuration (IUserConfig) with global configuration and generate component configuration (IComponentConfig).\r\n *\r\n * Main responsibilities:\r\n * - Retrieves global configuration via getGlobalConfig\r\n * - User configuration takes priority, with global configuration values used for unspecified settings\r\n * - Centrally returns configuration values such as shadowDomMode and extends\r\n *\r\n * Design points:\r\n * - Flexibly merges individual user settings with overall default settings\r\n * - Design that considers default configuration values and extensibility\r\n */\r\nimport { getGlobalConfig } from \"./getGlobalConfig.js\";\r\nimport { IUserConfig, IComponentConfig } from \"./types\";\r\n\r\n/**\r\n * Generates component configuration by merging user-specific settings with global defaults.\r\n * \r\n * User-provided values take precedence over global configuration. If a setting is not\r\n * specified in userConfig, the global default is used instead.\r\n * \r\n * @param {IUserConfig} userConfig - User-specific configuration for the component\r\n * @returns {IComponentConfig} Merged configuration with all required settings\r\n * \r\n * @example\r\n * const config = getComponentConfig({\r\n *   shadowDomMode: 'open',\r\n *   extends: 'button'\r\n * });\r\n * // Returns: { enableWebComponents: true, shadowDomMode: 'open', extends: 'button' }\r\n * \r\n * @example\r\n * // Using global defaults\r\n * const config = getComponentConfig({});\r\n * // Returns configuration with global shadowDomMode and null for extends\r\n */\r\nexport function getComponentConfig(userConfig: IUserConfig): IComponentConfig {\r\n  // Retrieve global configuration as fallback\r\n  const globalConfig = getGlobalConfig();\r\n  \r\n  return {\r\n    // Default to true if not explicitly set to false\r\n    enableWebComponents: typeof userConfig.enableWebComponents === \"undefined\" ? true : userConfig.enableWebComponents,\r\n    // Use user's shadowDomMode if specified, otherwise fall back to global setting\r\n    shadowDomMode      : userConfig.shadowDomMode ?? globalConfig.shadowDomMode,\r\n    // Use user's extends value if specified, otherwise null (standard custom element)\r\n    extends            : userConfig.extends ?? null,\r\n  };\r\n}","/**\r\n * createAccessorFunctions.ts\r\n *\r\n * Utility for generating dynamic getter/setter functions from State property path information (IStructuredPathInfo).\r\n *\r\n * Main responsibilities:\r\n * - Dynamically generates optimal accessor functions (get/set) from path information and getter sets\r\n * - Supports wildcards (*) and nested property paths\r\n * - Validates paths and segments\r\n *\r\n * Design points:\r\n * - Searches for the longest matching getter path from matchPaths and constructs accessors from the relative path\r\n * - If no path matches, generates accessors directly from info.pathSegments\r\n * - Uses new Function to dynamically generate high-performance getter/setter\r\n * - Strictly validates path and segment names with regular expressions to ensure safety\r\n */\r\nimport { getStructuredPathInfo } from \"./getStructuredPathInfo\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IAccessorFunctions, IStructuredPathInfo } from \"./types\";\r\n\r\n// Regular expression to validate segment names (must start with letter/underscore/$, followed by alphanumeric/underscore/$)\r\nconst checkSegmentRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\n// Regular expression to validate full property paths (segments separated by dots, wildcards allowed)\r\nconst checkPathRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*(\\.[a-zA-Z_$][0-9a-zA-Z_$]*|\\.\\*)*$/;\r\n\r\n/**\r\n * Creates dynamic getter and setter functions for a property path.\r\n * \r\n * This function generates optimized accessor functions by:\r\n * 1. Finding the longest matching getter path from the cumulative paths\r\n * 2. Building accessors relative to that getter (or from root if no match)\r\n * 3. Handling wildcards by mapping them to $1, $2, etc.\r\n * 4. Validating all path segments for safety\r\n * \r\n * @param info - Structured path information containing segments and wildcards\r\n * @param getters - Set of getter paths available in the state\r\n * @returns Object containing dynamically generated get and set functions\r\n * @throws {Error} STATE-202 - When path or segment name is invalid\r\n */\r\nexport function createAccessorFunctions(info: IStructuredPathInfo, getters: Set<string>): IAccessorFunctions {\r\n  const baseContext = { where: 'StateProperty.createAccessorFunctions', pattern: info.pattern };\r\n  // Find all cumulative paths that match available getters\r\n  const matchPaths = new Set(info.cumulativePaths).intersection(getters);\r\n  let len = -1;\r\n  let matchPath = '';\r\n  // Find the longest matching path to use as base for accessor generation\r\n  for(const curPath of matchPaths) {\r\n    const pathSegments = curPath.split('.');\r\n    // Skip single-segment paths (not useful as base paths)\r\n    if (pathSegments.length === 1) {\r\n      continue;\r\n    }\r\n    if (pathSegments.length > len) {\r\n      len = pathSegments.length;\r\n      matchPath = curPath;\r\n    }\r\n  }\r\n  // Case 1: Found a matching getter path - build accessor relative to it\r\n  if (matchPath.length > 0) {\r\n    // Validate the matched path format\r\n    if (!checkPathRegexp.test(matchPath)) {\r\n      raiseError({\r\n        code: \"STATE-202\",\r\n        message: `Invalid path: ${matchPath}`,\r\n        context: { ...baseContext, matchPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    // Get structured info for the matched getter path\r\n    const matchInfo = getStructuredPathInfo(matchPath);\r\n    const segments = [];\r\n    let count = matchInfo.wildcardCount;\r\n    // Build accessor path from the remaining segments after the match\r\n    for(let i = matchInfo.pathSegments.length; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        // Wildcard: map to $1, $2, etc. based on wildcard position\r\n        segments.push(`[this.$${  count + 1  }]`);\r\n        count++;\r\n      } else {\r\n        // Regular segment: validate and add as property access\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          raiseError({\r\n            code: \"STATE-202\",\r\n            message: `Invalid segment name: ${segment}`,\r\n            context: { ...baseContext, segment, matchPath },\r\n            docsUrl: \"./docs/error-codes.md#state\",\r\n          });\r\n        }\r\n        segments.push(`.${  segment}`);\r\n      }\r\n    }\r\n    // Build final path string and generate getter/setter functions\r\n    const path = segments.join('');\r\n    const getterFuncText = `return this[\"${matchPath}\"]${path};`;\r\n    const setterFuncText = `this[\"${matchPath}\"]${path} = value;`;\r\n    //console.log('path/getter/setter:', info.pattern, getterFuncText, setterFuncText);\r\n    return {\r\n      // eslint-disable-next-line @typescript-eslint/no-implied-eval\r\n      get : new Function('', getterFuncText) as ()=> unknown,\r\n      // eslint-disable-next-line @typescript-eslint/no-implied-eval\r\n      set : new Function('value', setterFuncText) as (value: unknown) => void,\r\n    }\r\n  } else {\r\n    // Case 2: No matching getter path - build accessor from root\r\n    const segments = [];\r\n    let count = 0;\r\n    for(let i = 0; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        // Wildcard: map to $1, $2, etc.\r\n        segments.push(`[this.$${  count + 1  }]`);\r\n        count++;\r\n      } else {\r\n        // Regular segment: validate and add\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          raiseError({\r\n            code: \"STATE-202\",\r\n            message: `Invalid segment name: ${segment}`,\r\n            context: { ...baseContext, segment },\r\n            docsUrl: \"./docs/error-codes.md#state\",\r\n          });\r\n        }\r\n        segments.push((segments.length > 0 ? \".\" : \"\") + segment);\r\n      }\r\n    }\r\n    // Build final path and generate getter/setter functions from root\r\n    const path = segments.join('');\r\n    const getterFuncText = `return this.${path};`;\r\n    const setterFuncText = `this.${path} = value;`;\r\n    //console.log('path/getter/setter:', info.pattern, getterFuncText, setterFuncText);\r\n    return {\r\n      // eslint-disable-next-line @typescript-eslint/no-implied-eval\r\n      get : new Function('', getterFuncText) as ()=> unknown,\r\n      // eslint-disable-next-line @typescript-eslint/no-implied-eval\r\n      set : new Function('value', setterFuncText) as (value: unknown) => void,\r\n    }\r\n  }\r\n\r\n}\r\n","import { getBuildablePathsSetById, getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes\";\r\nimport { CONNECTED_CALLBACK_FUNC_NAME, DISCONNECTED_CALLBACK_FUNC_NAME, RESERVED_WORD_SET, UPDATED_CALLBACK_FUNC_NAME } from \"../constants\";\r\nimport { addPathNode, createRootNode } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { Constructor } from \"../types\";\r\nimport { StructiveComponentClass } from \"../WebComponents/types\";\r\nimport { Dependencies, IPathManager } from \"./types\";\r\n\r\n/**\r\n * PathManager class manages property paths, dependencies, and accessor optimizations.\r\n * Analyzes component class to build path hierarchy and dependency graph.\r\n */\r\nclass PathManager implements IPathManager {\r\n  readonly alls: Set<string> = new Set<string>();\r\n  readonly lists: Set<string> = new Set<string>();\r\n  readonly buildables: Set<string> = new Set<string>();\r\n  readonly elements: Set<string> = new Set<string>();\r\n  readonly funcs: Set<string> = new Set<string>();\r\n  readonly getters: Set<string> = new Set<string>();\r\n  readonly onlyGetters: Set<string> = new Set<string>();\r\n  readonly setters: Set<string> = new Set<string>();\r\n  readonly getterSetters: Set<string> = new Set<string>();\r\n  readonly optimizes: Set<string> = new Set<string>();\r\n  readonly staticDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  readonly dynamicDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  readonly rootNode: IPathNode = createRootNode();\r\n  readonly hasConnectedCallback: boolean = false;\r\n  readonly hasDisconnectedCallback: boolean = false;\r\n  readonly hasUpdatedCallback: boolean = false;\r\n\r\n  private _id: number;\r\n  private _stateClass: Constructor<object>;\r\n  private _dynamicDependencyKeys = new Set<string>();\r\n\r\n  /**\r\n   * Creates a new PathManager instance.\r\n   * Analyzes component class to extract paths, getters, setters, and builds dependency graph.\r\n   * @param componentClass - Component class to analyze\r\n   */\r\n  constructor(componentClass: StructiveComponentClass) {\r\n    this._id = componentClass.id;\r\n    this._stateClass = componentClass.stateClass;\r\n    const alls = getPathsSetById(this._id);\r\n    const listsFromAlls = new Set<string>();\r\n    for(const path of alls) {\r\n      const info = getStructuredPathInfo(path);\r\n      this.alls = this.alls.union(info.cumulativePathSet);\r\n      // Check all paths in cumulativePathSet for wildcards\r\n      for(const cumulativePath of info.cumulativePathSet) {\r\n        const cumulativeInfo = getStructuredPathInfo(cumulativePath);\r\n        if (cumulativeInfo.lastSegment === \"*\") {\r\n          listsFromAlls.add(cumulativeInfo.parentPath!);\r\n        }\r\n      }\r\n    }\r\n    // Configure list paths\r\n    const lists = getListPathsSetById(this._id);\r\n    this.lists = this.lists.union(lists).union(listsFromAlls);\r\n    for(const listPath of this.lists) {\r\n      const elementPath = `${listPath  }.*`;\r\n      this.elements.add(elementPath);\r\n    }\r\n    \r\n    // Configure buildable paths\r\n    const buildables = getBuildablePathsSetById(this._id);\r\n    this.buildables = this.buildables.union(buildables);\r\n\r\n    let currentProto: unknown = this._stateClass.prototype;\r\n    while (currentProto && currentProto !== Object.prototype) {\r\n      const getters = Object.getOwnPropertyDescriptors(currentProto);\r\n      if (getters) {\r\n        for (const [key, desc] of Object.entries(getters)) {\r\n          if (RESERVED_WORD_SET.has(key)) {\r\n            continue;\r\n          }\r\n          if (typeof desc.value === \"function\") {\r\n            this.funcs.add(key);\r\n            if (key === CONNECTED_CALLBACK_FUNC_NAME) {\r\n              this.hasConnectedCallback = true;\r\n            }\r\n            if (key === DISCONNECTED_CALLBACK_FUNC_NAME) {\r\n              this.hasDisconnectedCallback = true;\r\n            }\r\n            if (key === UPDATED_CALLBACK_FUNC_NAME) {\r\n              this.hasUpdatedCallback = true;\r\n            }\r\n            continue;\r\n          }\r\n          const hasGetter = desc.get !== undefined;\r\n          const hasSetter = desc.set !== undefined;\r\n          const info = getStructuredPathInfo(key);\r\n          this.alls = this.alls.union(info.cumulativePathSet);\r\n          if (hasGetter) {\r\n            this.getters.add(key);\r\n          }\r\n          if (hasSetter) {\r\n            this.setters.add(key);\r\n          }\r\n          if (hasGetter && !hasSetter) {\r\n            this.onlyGetters.add(key);\r\n          }\r\n          if (hasGetter && hasSetter) {\r\n            this.getterSetters.add(key);\r\n          }\r\n        }\r\n      }\r\n      currentProto = Object.getPrototypeOf(currentProto);\r\n    }\r\n    // Determine optimization target paths and optimize them\r\n    for(const path of this.alls) {\r\n      if (this.getters.has(path)) {\r\n        continue;\r\n      }\r\n      if (this.setters.has(path)) {\r\n        continue;\r\n      }\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.pathSegments.length === 1) {\r\n        continue;\r\n      }\r\n      const funcs = createAccessorFunctions(info, this.getters);\r\n      Object.defineProperty(this._stateClass.prototype, path, {\r\n        get: funcs.get,\r\n        set: funcs.set,\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n      this.optimizes.add(path);\r\n    }\r\n    // Configure static dependencies\r\n    for(const path of this.alls) {\r\n      addPathNode(this.rootNode, path);\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.parentPath) {\r\n        const dependencies = this.staticDependencies.get(info.parentPath);\r\n        if (typeof dependencies !== \"undefined\") {\r\n          dependencies.add(path);\r\n        } else {\r\n          this.staticDependencies.set(info.parentPath, new Set([path]));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Adds a new path to the manager dynamically.\r\n   * Updates path hierarchy, creates optimized accessors, and registers dependencies.\r\n   * @param addPath - Path to add\r\n   * @param isList - Whether the path represents a list (default: false)\r\n   */\r\n  addPath(addPath: string, isList: boolean = false): void {\r\n    const info = getStructuredPathInfo(addPath);\r\n    if (isList && !this.lists.has(addPath)) {\r\n      this.lists.add(addPath);\r\n      const elementPath = `${addPath  }.*`;\r\n      this.elements.add(elementPath);\r\n    } else if (info.lastSegment === \"*\") {\r\n      this.elements.add(addPath);\r\n      this.lists.add(info.parentPath!);\r\n    }\r\n    for(const path of info.cumulativePathSet) {\r\n      if (this.alls.has(path)) {continue;}\r\n      this.alls.add(path);\r\n      addPathNode(this.rootNode, path);\r\n      const pathInfo = getStructuredPathInfo(path);\r\n      if (pathInfo.lastSegment === \"*\") {\r\n        this.elements.add(path);\r\n        this.lists.add(pathInfo.parentPath!);\r\n      }      \r\n      if (pathInfo.pathSegments.length > 1) {\r\n        const funcs = createAccessorFunctions(pathInfo, this.getters);\r\n        Object.defineProperty(this._stateClass.prototype, path, {\r\n          get: funcs.get,\r\n          set: funcs.set,\r\n          enumerable: true,\r\n          configurable: true,\r\n        });\r\n        this.optimizes.add(path);\r\n      }\r\n\r\n      if (pathInfo.parentPath) {\r\n        const dependencies = this.staticDependencies.get(pathInfo.parentPath);\r\n        if (typeof dependencies !== \"undefined\") {\r\n          dependencies.add(path);\r\n        } else {\r\n          this.staticDependencies.set(pathInfo.parentPath, new Set([path]));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Adds a dynamic dependency between source and target paths.\r\n   * Ensures source path exists before registering dependency.\r\n   * @param target - Target path that depends on source\r\n   * @param source - Source path that target depends on\r\n   */\r\n  addDynamicDependency(target: string, source: string) {\r\n    const key = `${source}=>${target}`;\r\n    if (this._dynamicDependencyKeys.has(key)) {\r\n      return;\r\n    }\r\n    if (!this.alls.has(source)) {\r\n      this.addPath(source)\r\n    }\r\n    this._dynamicDependencyKeys.add(key);\r\n\r\n    const dependencies = this.dynamicDependencies.get(source);\r\n    if (typeof dependencies !== \"undefined\") {\r\n      dependencies.add(target);\r\n    } else {\r\n      this.dynamicDependencies.set(source, new Set([target]));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create a new PathManager instance.\r\n * @param componentClass - Component class to analyze and manage\r\n * @returns New PathManager instance\r\n */\r\nexport function createPathManager(componentClass: StructiveComponentClass): IPathManager {\r\n  return new PathManager(componentClass);\r\n}","/**\r\n * createComponentClass.ts\r\n *\r\n * Utility for dynamically generating custom element classes for Structive Web Components.\r\n *\r\n * Main responsibilities:\r\n * - Generates Web Components classes from user-defined componentData (stateClass, html, css, etc.)\r\n * - Centrally manages and registers StateClass/template/CSS/binding information by ID\r\n * - Provides a feature-rich foundation including custom get/set traps, bindings, parent-child component discovery, and filter extensions\r\n * - Provides access to template, styles, StateClass, filters, and getter information via static properties\r\n * - Registers custom elements via the define method\r\n *\r\n * Design points:\r\n * - Uses findStructiveParent to discover parent Structive components, enabling hierarchical state management\r\n * - Supports getter/setter/binding optimization\r\n * - Centrally manages template/CSS/StateClass/binding information by ID, ensuring reusability and extensibility\r\n * - Filters and binding information can be flexibly extended via static properties\r\n */\r\nimport { inputBuiltinFilters, outputBuiltinFilters } from \"../Filter/builtinFilters.js\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { getStateClassById, registerStateClass } from \"../StateClass/registerStateClass.js\";\r\nimport { getStyleSheetById } from \"../StyleSheet/registerStyleSheet.js\";\r\nimport { registerCss } from \"../StyleSheet/regsiterCss.js\";\r\nimport { createComponentEngine } from \"../ComponentEngine/ComponentEngine.js\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types.js\";\r\nimport { registerHtml } from \"../Template/registerHtml.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { getBaseClass } from \"./getBaseClass.js\";\r\nimport { getComponentConfig } from \"./getComponentConfig.js\";\r\nimport { IComponent, IUserComponentData, StructiveComponentClass, StructiveComponent } from \"./types\";\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { findStructiveParent } from \"./findStructiveParent.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { createPathManager } from \"../PathManager/PathManager.js\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types.js\";\r\nimport { UpdateComplete } from \"../Updater/types.js\";\r\n\r\n/**\r\n * Creates a custom Web Component class from user-defined component data.\r\n * \r\n * This factory function generates a fully-configured custom element class that:\r\n * - Extends the appropriate base class (HTMLElement or specified custom element)\r\n * - Registers all templates, styles, and state management\r\n * - Provides static accessors for component resources (template, stylesheet, stateClass, filters)\r\n * - Implements the IComponent interface with lifecycle hooks and state management\r\n * \r\n * @param {IUserComponentData} componentData - Configuration object containing stateClass, html, and css\r\n * @returns {StructiveComponentClass} A custom element class ready to be registered via customElements.define()\r\n * \r\n * @example\r\n * const MyComponent = createComponentClass({\r\n *   stateClass: { count: 0 },\r\n *   html: '<div>{{count}}</div>',\r\n *   css: 'div { color: blue; }'\r\n * });\r\n * MyComponent.define('my-component');\r\n */\r\nexport function createComponentClass(componentData: IUserComponentData): StructiveComponentClass {\r\n  // Extract and process component configuration\r\n  const config = (componentData.stateClass.$config ?? {});\r\n  const componentConfig = getComponentConfig(config);\r\n  \r\n  // Generate unique ID for this component class\r\n  const id = generateId();\r\n  const { html, css, stateClass } = componentData;\r\n  \r\n  // Initialize filter collections with built-in filters\r\n  const inputFilters:FilterWithOptions = Object.assign({}, inputBuiltinFilters);\r\n  const outputFilters:FilterWithOptions = Object.assign({}, outputBuiltinFilters);\r\n  \r\n  // Mark as Structive component and register all resources\r\n  stateClass.$isStructive = true;\r\n  registerHtml(id, html);\r\n  registerCss(id, css);\r\n  registerStateClass(id, stateClass);\r\n  \r\n  // Determine base class to extend (HTMLElement or custom element)\r\n  const baseClass = getBaseClass(componentConfig.extends);\r\n  const extendTagName = componentConfig.extends;\r\n  \r\n  return class extends baseClass implements IComponent {\r\n    /**\r\n     * Registers this component class as a custom element.\r\n     * \r\n     * @param {string} tagName - The custom element tag name (must contain a hyphen)\r\n     * @returns {void}\r\n     * \r\n     * @example\r\n     * MyComponent.define('my-component');\r\n     */\r\n    static define(tagName:string) {\r\n      // Register as extended built-in element if extends is specified\r\n      if (extendTagName) {\r\n        customElements.define(tagName, this, { extends: extendTagName });\r\n      } else {\r\n        customElements.define(tagName, this);\r\n      }\r\n    }\r\n\r\n    /** Gets the unique numeric ID for this component class */\r\n    static get id():number {\r\n      return id;\r\n    }\r\n    \r\n    /** HTML template string for this component */\r\n    static _html:string = html;\r\n    static get html():string {\r\n      return this._html;\r\n    }\r\n    /**\r\n     * Updates the HTML template and invalidates cached template/pathManager.\r\n     * This allows dynamic template modification after component class creation.\r\n     */\r\n    static set html(value:string) {\r\n      this._html = value;\r\n      registerHtml(this.id, value);\r\n      this._template = null;\r\n      this._pathManager = null; // Reset path information when template changes\r\n    }\r\n\r\n    /** CSS stylesheet string for this component */\r\n    static _css:string = css;\r\n    static get css() {\r\n      return this._css;\r\n    }\r\n    /**\r\n     * Updates the CSS stylesheet and invalidates cached stylesheet.\r\n     * Allows dynamic style modification after component class creation.\r\n     */\r\n    static set css(value:string) {\r\n      this._css = value;\r\n      registerCss(this.id, value);\r\n      this._styleSheet = null;\r\n    }\r\n    \r\n    /** Cached HTMLTemplateElement instance */\r\n    static _template: HTMLTemplateElement | null = null;\r\n    /**\r\n     * Gets the compiled HTMLTemplateElement for this component.\r\n     * Lazily loads and caches on first access.\r\n     */\r\n    static get template():HTMLTemplateElement {\r\n      if (!this._template) {\r\n        this._template = getTemplateById(this.id);\r\n      }\r\n      return this._template;\r\n    }\r\n    \r\n    /** Cached CSSStyleSheet instance */\r\n    static _styleSheet: CSSStyleSheet | null = null;\r\n    /**\r\n     * Gets the CSSStyleSheet for this component.\r\n     * Lazily loads and caches on first access.\r\n     */\r\n    static get styleSheet():CSSStyleSheet {\r\n      if (!this._styleSheet) {\r\n        this._styleSheet = getStyleSheetById(this.id);\r\n      }\r\n      return this._styleSheet;\r\n    }\r\n    \r\n    /** Cached state class definition */\r\n    static _stateClass: IStructiveState | null = null;\r\n    /**\r\n     * Gets the state class definition for this component.\r\n     * Lazily loads and caches on first access.\r\n     */\r\n    static get stateClass():IStructiveState {\r\n      if (!this._stateClass) {\r\n        this._stateClass = getStateClassById(this.id);\r\n      }\r\n      return this._stateClass;\r\n    }\r\n    \r\n    /** Input filters for data binding transformations */\r\n    static _inputFilters:FilterWithOptions = inputFilters;\r\n    static get inputFilters():FilterWithOptions {\r\n      return this._inputFilters;\r\n    }\r\n    \r\n    /** Output filters for data binding transformations */\r\n    static _outputFilters:FilterWithOptions = outputFilters;\r\n    static get outputFilters():FilterWithOptions {\r\n      return this._outputFilters;\r\n    }\r\n    \r\n    /** Cached PathManager instance for managing state paths and bindings */\r\n    static _pathManager: IPathManager | null = null;\r\n    /**\r\n     * Gets the PathManager for analyzing and managing state property paths.\r\n     * Lazily creates and caches on first access.\r\n     */\r\n    static get pathManager(): IPathManager {\r\n      if (!this._pathManager) {\r\n        this._pathManager = createPathManager(this as StructiveComponentClass);\r\n      }\r\n      return this._pathManager;\r\n    }\r\n\r\n    /** Component engine that manages lifecycle, state, and rendering */\r\n    private _engine: IComponentEngine;\r\n\r\n    /** Cached reference to parent Structive component (undefined = not yet searched) */\r\n    _parentStructiveComponent: StructiveComponent | null | undefined;\r\n\r\n    /**\r\n     * Constructs a new component instance.\r\n     * Creates the component engine and performs initial setup.\r\n     */\r\n    constructor() {\r\n      super();\r\n      // Create the component engine with configuration\r\n      this._engine = createComponentEngine(componentConfig, this as StructiveComponent);\r\n      // Initialize bindings, state, and prepare for rendering\r\n      this._engine.setup();\r\n    }\r\n\r\n    /**\r\n     * Called when the element is inserted into the DOM.\r\n     * Triggers component initialization and rendering.\r\n     */\r\n    connectedCallback() {\r\n      this._engine.connectedCallback();\r\n    }\r\n\r\n    /**\r\n     * Called when the element is removed from the DOM.\r\n     * Performs cleanup and resource disposal.\r\n     */\r\n    disconnectedCallback() {\r\n      this._engine.disconnectedCallback();\r\n    }\r\n\r\n    /**\r\n     * Gets the nearest parent Structive component in the DOM tree.\r\n     * Result is cached after first lookup for performance.\r\n     * \r\n     * @returns {StructiveComponent | null} Parent component or null if none found\r\n     */\r\n    get parentStructiveComponent(): StructiveComponent | null {\r\n      if (typeof this._parentStructiveComponent === \"undefined\") {\r\n        // Search up the DOM tree for parent Structive component\r\n        this._parentStructiveComponent = findStructiveParent(this as StructiveComponent);\r\n      }\r\n      return this._parentStructiveComponent;\r\n    }\r\n\r\n    /**\r\n     * Gets the state input interface for accessing and modifying component state.\r\n     * \r\n     * @returns {IComponentStateInput} State input interface\r\n     */\r\n    get state(): IComponentStateInput {\r\n      return this._engine.stateInput;\r\n    }\r\n\r\n    /**\r\n     * Gets the state binding interface for managing bindings between parent and child components.\r\n     * \r\n     * @returns {IComponentStateBinding} State binding interface\r\n     */\r\n    get stateBinding(): IComponentStateBinding {\r\n      return this._engine.stateBinding;\r\n    }\r\n\r\n    /**\r\n     * Checks if this is a Structive component.\r\n     * \r\n     * @returns {boolean} True if this is a Structive component\r\n     */\r\n    get isStructive(): boolean {\r\n      return this._engine.stateClass.$isStructive ?? false;\r\n    }\r\n\r\n    /**\r\n     * Gets the Promise resolvers for component ready state.\r\n     * Allows external code to wait for component initialization to complete.\r\n     * \r\n     * @returns {PromiseWithResolvers<void>} Promise resolvers for ready state\r\n     */\r\n    get readyResolvers(): PromiseWithResolvers<void> {\r\n      return this._engine.readyResolvers;\r\n    }\r\n\r\n    get updateComplete(): UpdateComplete | null {\r\n      return this._engine.updateCompleteQueue.current;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the set of bindings associated with a specific child component.\r\n     * \r\n     * @param {IComponent} component - The child component to query\r\n     * @returns {Set<IBinding> | null} Set of bindings or null if component not found\r\n     */\r\n    getBindingsFromChild(component: IComponent): Set<IBinding> | null {\r\n      return this._engine.bindingsByComponent.get(component as StructiveComponent) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Registers a child component, establishing parent-child relationship.\r\n     * Called when a child Structive component is connected.\r\n     * \r\n     * @param {StructiveComponent} component - The child component to register\r\n     * @returns {void}\r\n     */\r\n    registerChildComponent(component:StructiveComponent): void {\r\n      this._engine.registerChildComponent(component);\r\n    }\r\n    \r\n    /**\r\n     * Unregisters a child component, cleaning up the parent-child relationship.\r\n     * Called when a child Structive component is disconnected.\r\n     * \r\n     * @param {StructiveComponent} component - The child component to unregister\r\n     * @returns {void}\r\n     */\r\n    unregisterChildComponent(component:StructiveComponent): void {\r\n      this._engine.unregisterChildComponent(component);\r\n    }\r\n\r\n  } as StructiveComponentClass;\r\n}\r\n","/**\r\n * loadImportmap.ts\r\n *\r\n * Utility function to retrieve and merge importmap information from <script type=\"importmap\"> tags in HTML.\r\n *\r\n * Main responsibilities:\r\n * - Scans multiple importmap script tags and merges all imports, returning as IImportMap type\r\n *\r\n * Design points:\r\n * - Parses script tag innerHTML via JSON.parse and consolidates imports properties\r\n * - Merges multiple importmap.imports using Object.assign\r\n * - Conforms to importmap specification, enabling flexible import alias management\r\n */\r\nimport { IImportMap } from \"./types\";\r\n\r\ntype TypeImportMap = { \r\n  \"imports\": Record<string, string>, \r\n  \"scopes\"?: Record<string, Record<string, string>> \r\n};\r\n\r\n/**\r\n * Loads and merges all importmaps from the document.\r\n * \r\n * Searches for all <script type=\"importmap\"> elements in the document and combines\r\n * their imports into a single IImportMap object. If multiple importmap tags exist,\r\n * their imports are merged with later entries overwriting earlier ones.\r\n * \r\n * @returns {IImportMap} Merged importmap containing all imports from all script tags\r\n * \r\n * @example\r\n * // HTML:\r\n * // <script type=\"importmap\">\r\n * //   { \"imports\": { \"@components/button\": \"./button.sfc\" } }\r\n * // </script>\r\n * // <script type=\"importmap\">\r\n * //   { \"imports\": { \"@routes/home\": \"./home.sfc\" } }\r\n * // </script>\r\n * \r\n * const importmap = loadImportmap();\r\n * // Returns: { imports: { \"@components/button\": \"./button.sfc\", \"@routes/home\": \"./home.sfc\" } }\r\n */\r\nexport function loadImportmap():IImportMap {\r\n  // Initialize empty importmap object\r\n  const importmap: IImportMap = {};\r\n  \r\n  // Find all importmap script tags in the document\r\n  document.querySelectorAll(\"script[type='importmap']\").forEach(script => {\r\n    // Parse the JSON content of each script tag\r\n    const scriptImportmap = JSON.parse(script.innerHTML) as TypeImportMap;\r\n    \r\n    // Merge imports if they exist in this script\r\n    if (scriptImportmap.imports) {\r\n      // Merge with existing imports (later entries override earlier ones)\r\n      importmap.imports = Object.assign(importmap.imports || {}, scriptImportmap.imports);\r\n    }\r\n  });\r\n  \r\n  return importmap;\r\n}\r\n\r\n","/**\r\n * createSingleFileComponent.ts\r\n *\r\n * Utility for parsing Structive Single File Components (SFC) and extracting/generating each element (HTML, CSS, StateClass).\r\n *\r\n * Main responsibilities:\r\n * - Extracts and separates <template>, <script type=\"module\">, and <style> from text\r\n * - Dynamically imports <script type=\"module\"> via Base64 encoding and uses it as StateClass\r\n * - Temporarily converts {{...}} embedded expressions to comment nodes to prevent loss during HTML parsing, then restores them\r\n * - Returns each element (html, css, stateClass, text) as IUserComponentData\r\n *\r\n * Design points:\r\n * - Achieves safe parsing of Mustache syntax via escapeEmbed/unescapeEmbed\r\n * - Safely dynamically imports scripts via data: URL\r\n * - Design that allows flexible separation and management of template, script, and style\r\n */\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IUserComponentData } from \"./types\";\r\nimport { config } from \"./getGlobalConfig.js\";\r\n\r\ntype ScriptModule = { default?: unknown };\r\n\r\n/**\r\n * Escapes Mustache template expressions by converting them to HTML comments.\r\n * This prevents the browser's HTML parser from interpreting {{}} as invalid syntax.\r\n * \r\n * @param {string} html - HTML string containing Mustache expressions\r\n * @returns {string} HTML with {{...}} converted to <!--{{...}}-->\r\n * \r\n * @example\r\n * escapeEmbed('{{name}}') // Returns '<!--{{name}}-->'\r\n */\r\nfunction escapeEmbed(html: string): string {\r\n  return html.replaceAll(/\\{\\{([^}]+)\\}\\}/g, (match, expr) => {\r\n    return `<!--{{${expr}}}-->`;\r\n  });\r\n}\r\n\r\n/**\r\n * Restores escaped Mustache expressions from HTML comments back to original form.\r\n * This reverses the escapeEmbed operation after safe HTML parsing.\r\n * \r\n * @param {string} html - HTML string with escaped Mustache expressions\r\n * @returns {string} HTML with <!--{{...}}--> converted back to {{...}}\r\n * \r\n * @example\r\n * unescapeEmbed('<!--{{name}}-->') // Returns '{{name}}'\r\n */\r\nfunction unescapeEmbed(html:string):string {\r\n  return html.replaceAll(/<!--\\{\\{([^}]+)}}-->/g, (match, expr) => {\r\n    return `{{${expr}}}`;\r\n  });\r\n}\r\n\r\nfunction warnMissingSection(section: string, filePath: string, detail?: string): void {\r\n  if (!config.debug) {\r\n    return;\r\n  }\r\n  const suffix = detail ? ` (${detail})` : \"\";\r\n  console.warn(`[Structive][SFC] Missing <${section}> section in ${filePath}${suffix}`);\r\n}\r\n\r\n/** Counter for generating unique IDs for dynamically imported scripts */\r\nlet id = 0;\r\n\r\n/**\r\n * Parses a Single File Component (SFC) and extracts its template, script, and style sections.\r\n * \r\n * The SFC format consists of:\r\n * - <template>: HTML template with Mustache syntax\r\n * - <script type=\"module\">: JavaScript module exporting the state class\r\n * - <style>: CSS styles for the component\r\n * \r\n * @param {string} path - File path or identifier for source mapping in error messages\r\n * @param {string} text - Raw SFC text content to parse\r\n * @returns {Promise<IUserComponentData>} Parsed component data including html, css, and stateClass\r\n * \r\n * @example\r\n * const componentData = await createSingleFileComponent('MyComponent.sfc', `\r\n *   <template><div>{{message}}</div></template>\r\n *   <script type=\"module\">\r\n *     export default class { message = 'Hello'; }\r\n *   </script>\r\n *   <style>div { color: blue; }</style>\r\n * `);\r\n */\r\nexport async function createSingleFileComponent(path: string, text: string): Promise<IUserComponentData> {\r\n  // Create a temporary template element for safe HTML parsing\r\n  const template = document.createElement(\"template\");\r\n  // Escape Mustache expressions to prevent parsing issues\r\n  template.innerHTML = escapeEmbed(text);\r\n\r\n  // Extract and remove the <template> section\r\n  const html = template.content.querySelector<HTMLTemplateElement>(\"template\");\r\n  if (!html) {\r\n    warnMissingSection(\"template\", path);\r\n  }\r\n  html?.remove();\r\n\r\n  // Extract and remove the <script type=\"module\"> section\r\n  const script = template.content.querySelector<HTMLScriptElement>(\"script[type=module]\");\r\n  let scriptModule: ScriptModule = {};\r\n  if (script) {\r\n    // Add unique comment for debugging and source mapping\r\n    const uniq_comment = `\\n// uniq id: ${id++}\\n//# sourceURL=${path}\\n`;\r\n    \r\n    // Use blob URL (browser environment)\r\n    // Fallback for test environment (jsdom) where URL.createObjectURL doesn't exist\r\n    if (typeof URL.createObjectURL === 'function') {\r\n      // Create a blob URL for the script and dynamically import it\r\n      const blob = new Blob([script.text + uniq_comment], { type: \"application/javascript\" });\r\n      const url = URL.createObjectURL(blob);\r\n      try {\r\n        scriptModule = await import(url) as ScriptModule;\r\n      } finally {\r\n        // Clean up blob URL to prevent memory leak\r\n        URL.revokeObjectURL(url);\r\n      }\r\n    } else {\r\n      // Fallback: Base64 encoding method (for test environment)\r\n      // Convert script to Base64 and import via data: URL\r\n      const b64 = btoa(String.fromCodePoint(...new TextEncoder().encode(script.text + uniq_comment)));\r\n      scriptModule = await import(`data:application/javascript;base64,${b64}`) as ScriptModule;\r\n    }\r\n  } else {\r\n    warnMissingSection(\"script\", path, 'expects <script type=\"module\">');\r\n  }\r\n  script?.remove();\r\n\r\n  // Extract and remove the <style> section\r\n  const style = template.content.querySelector<HTMLStyleElement>(\"style\");\r\n  if (!style) {\r\n    warnMissingSection(\"style\", path);\r\n  }\r\n  style?.remove();\r\n\r\n  // Use default export as state class, or empty class if not provided\r\n  const stateClass = (scriptModule.default ?? class {}) as IStructiveState;\r\n  \r\n  // Return parsed component data\r\n  return {\r\n    text,\r\n    // Restore Mustache expressions and trim whitespace from template\r\n    html      : unescapeEmbed(html?.innerHTML ?? \"\").trim(),\r\n    // Extract CSS text content or use empty string\r\n    css       : style?.textContent ?? \"\",\r\n    stateClass,\r\n  }\r\n}","/**\r\n * loadSingleFileComponent.ts\r\n *\r\n * Utility function to fetch a Single File Component (SFC) from a specified path, parse it, and return as IUserComponentData.\r\n *\r\n * Main responsibilities:\r\n * - Fetches the SFC file from the specified path using fetch\r\n * - Loads as text and parses via createSingleFileComponent\r\n * - Returns the parsed result (IUserComponentData)\r\n *\r\n * Design points:\r\n * - Uses import.meta.resolve for flexible path resolution\r\n * - Supports dynamic component loading via asynchronous processing\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createSingleFileComponent } from \"./createSingleFileComponent.js\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\n/**\r\n * Loads a Single File Component from the specified path.\r\n * \r\n * Fetches the SFC file, reads its contents as text, and parses it to extract\r\n * the template, script, and style sections into a component data object.\r\n * \r\n * @param {string} path - Path or alias to the SFC file (e.g., './components/button.sfc' or '@components/button')\r\n * @returns {Promise<IUserComponentData>} Parsed component data containing html, css, stateClass, and text\r\n * @throws {Error} If fetch fails or the file cannot be read\r\n * \r\n * @example\r\n * // Load from relative path\r\n * const buttonData = await loadSingleFileComponent('./button.sfc');\r\n * \r\n * @example\r\n * // Load from importmap alias\r\n * const chartData = await loadSingleFileComponent('@components/chart');\r\n */\r\nexport async function loadSingleFileComponent(path: string): Promise<IUserComponentData> {\r\n  // Resolve path using import.meta.resolve if available\r\n  // Fallback to raw path for SSR environments (Node/Vitest) where import.meta.resolve may not exist\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\r\n  const resolved = (import.meta as any).resolve ? (import.meta as any).resolve(path) : path;\r\n  const docsUrl = \"./docs/error-codes.md#imp-202-component-load-failed\";\r\n  let text = \"\";\r\n\r\n  try {\r\n    // Fetch the SFC file from the resolved path\r\n    const response = await fetch(resolved as string);\r\n\r\n    if (!response.ok) {\r\n      raiseError({\r\n        code: \"IMP-202\",\r\n        message: `Failed to load component from ${path}`,\r\n        context: {\r\n          where: \"WebComponents.loadSingleFileComponent\",\r\n          path,\r\n          resolved,\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          url: response.url\r\n        },\r\n        hint: \"Make sure the import map entry points to a reachable SFC and the server returns a 2xx status.\",\r\n        docsUrl\r\n      });\r\n    }\r\n\r\n    // Read the response body as text\r\n    text = await response.text();\r\n  } catch(e) {\r\n    // failed single file component load\r\n    raiseError({\r\n      code: \"IMP-202\",\r\n      message: `Failed to load component from ${path}`,\r\n      context: {\r\n        where: \"WebComponents.loadSingleFileComponent\",\r\n        path,\r\n        resolved\r\n      },\r\n      hint: \"Confirm the SFC path is correct and accessible before bootstrapping.\",\r\n      docsUrl,\r\n      cause: e\r\n    });\r\n\r\n  }\r\n  \r\n  // Parse the SFC text into component data (template, script, style)\r\n  return createSingleFileComponent(path, text);\r\n}\r\n","/**\r\n * registerComponentClass.ts\r\n *\r\n * Utility function to register a Structive Web Components class as a custom element with the specified tag name.\r\n *\r\n * Main responsibilities:\r\n * - registerComponentClass: Registers the provided componentClass using the define method with the given tagName\r\n *\r\n * Design points:\r\n * - Concisely wraps Web Components custom element registration for improved reusability\r\n */\r\nimport { StructiveComponentClass } from \"./types\";\r\n\r\n/**\r\n * Registers a Structive component class as a custom element.\r\n * \r\n * This is a convenience wrapper around the component class's define method,\r\n * which internally calls customElements.define() with the appropriate configuration.\r\n * \r\n * @param {string} tagName - The custom element tag name (must contain a hyphen, e.g., 'my-button')\r\n * @param {StructiveComponentClass} componentClass - The component class to register\r\n * @returns {void}\r\n * @throws {DOMException} If the tag name is invalid or already registered\r\n * \r\n * @example\r\n * const ButtonComponent = createComponentClass({\r\n *   stateClass: { count: 0 },\r\n *   html: '<button>{{count}}</button>',\r\n *   css: 'button { color: blue; }'\r\n * });\r\n * registerComponentClass('my-button', ButtonComponent);\r\n * // Now <my-button> can be used in HTML\r\n */\r\nexport function registerComponentClass(tagName: string, componentClass: StructiveComponentClass) {\r\n  // Delegates to the component class's define method, which handles customElements.define()\r\n  componentClass.define(tagName);\r\n}","/**\r\n * loadFromImportMap.ts\r\n *\r\n * Automatically registers routes and components by scanning importmap aliases.\r\n * \r\n * Processes two types of imports:\r\n * - @routes/*: Registers routing via entryRoute (/root normalized to /)\r\n * - @components/*: Loads SFC, generates ComponentClass, and registers via registerComponentClass\r\n * - #lazy suffix: Defers loading until component is actually needed\r\n *\r\n * @module loadFromImportMap\r\n */\r\nimport { entryRoute } from \"../Router/Router\";\r\nimport { raiseError } from \"../utils\";\r\nimport { createComponentClass } from \"./createComponentClass\";\r\nimport { loadImportmap } from \"./loadImportmap\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent\";\r\nimport { registerComponentClass } from \"./registerComponentClass\";\r\n\r\n/** Prefix for route aliases in importmap */\r\nconst ROUTES_KEY = \"@routes/\";\r\n/** Prefix for component aliases in importmap */\r\nconst COMPONENTS_KEY = \"@components/\";\r\n/** Suffix indicating a lazy-loaded component */\r\nconst LAZY_LOAD_SUFFIX = \"#lazy\";\r\n/** Length of the lazy load suffix for efficient slicing */\r\nconst LAZY_LOAD_SUFFIX_LEN = LAZY_LOAD_SUFFIX.length;\r\n\r\n/** Registry of lazy-loadable component aliases indexed by tag name */\r\nconst lazyLoadComponentAliasByTagName: Record<string, string> = {};\r\n\r\n/**\r\n * Loads and registers all routes and components from the importmap.\r\n * \r\n * This function scans the importmap for @routes/* and @components/* entries:\r\n * - Route entries create routing configurations via entryRoute\r\n * - Component entries load SFC files and register them as custom elements\r\n * - Entries with #lazy suffix are deferred until explicitly loaded\r\n * \r\n * @returns {Promise<void>} Resolves when all non-lazy components are loaded and registered\r\n * \r\n * @example\r\n * // Importmap example:\r\n * // {\r\n * //   \"imports\": {\r\n * //     \"@routes/home\": \"./routes/home.sfc\",\r\n * //     \"@components/my-button\": \"./components/button.sfc\",\r\n * //     \"@components/heavy-chart#lazy\": \"./components/chart.sfc\"\r\n * //   }\r\n * // }\r\n * await loadFromImportMap();\r\n * // 'routes-home' and 'my-button' are now registered\r\n * // 'heavy-chart' will be loaded on demand\r\n */\r\nexport async function loadFromImportMap(): Promise<void> {\r\n  // Load the importmap from the document\r\n  const importmap = loadImportmap();\r\n  if (importmap.imports) {\r\n    // Collect non-lazy components to load immediately\r\n    const loadAliasByTagName: Map<string, string> = new Map();\r\n    \r\n    // Phase 1: Scan all aliases and classify them\r\n    for (const [alias, _value] of Object.entries(importmap.imports)) {\r\n      let tagName, isLazyLoad;\r\n      \r\n      // Process route aliases (@routes/*)\r\n      if (alias.startsWith(ROUTES_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // Extract path: '@routes/users/:id' -> '/users/:id'\r\n        const path = alias.slice(ROUTES_KEY.length - 1, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined); \r\n        // Remove route parameters to create tag name: '/users/:id' -> '/users/'\r\n        const pathWithoutParams = path.replace(/:[^\\s/]+/g, \"\");\r\n        // Convert path to tag name: '/users/' -> 'routes-users-'\r\n        tagName = `routes${  pathWithoutParams.replace(/\\//g, \"-\")}`;\r\n        // Register route (normalize '/root' to '/')\r\n        entryRoute(tagName, path === \"/root\" ? \"/\" : path);\r\n      } \r\n      // Process component aliases (@components/*)\r\n      if (alias.startsWith(COMPONENTS_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // Extract tag name: '@components/my-button' -> 'my-button'\r\n        tagName = alias.slice(COMPONENTS_KEY.length, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined);\r\n      }\r\n      \r\n      // Skip if not a recognized alias format\r\n      if (!tagName) {\r\n        continue;\r\n      }\r\n      \r\n      // Defer lazy-load components\r\n      if (isLazyLoad) {\r\n        // Store alias for later loading\r\n        lazyLoadComponentAliasByTagName[tagName] = alias;\r\n        continue;\r\n      }\r\n      \r\n      // Queue non-lazy component for immediate loading\r\n      loadAliasByTagName.set(tagName, alias);\r\n    }\r\n    \r\n    // Phase 2: Load and register all non-lazy components\r\n    for (const [tagName, alias] of loadAliasByTagName.entries()) {\r\n      // Load the SFC file\r\n      const componentData = await loadSingleFileComponent(alias);\r\n      // Create the component class\r\n      const componentClass = createComponentClass(componentData);\r\n      // Register as custom element\r\n      registerComponentClass(tagName, componentClass);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if there are any lazy-loadable components registered.\r\n * \r\n * @returns {boolean} True if at least one lazy-load component is registered\r\n * \r\n * @example\r\n * if (hasLazyLoadComponents()) {\r\n *   console.log('Lazy loading is available');\r\n * }\r\n */\r\nexport function hasLazyLoadComponents(): boolean {\r\n  return Object.keys(lazyLoadComponentAliasByTagName).length > 0;\r\n}\r\n\r\n/**\r\n * Checks if a specific tag name is registered as a lazy-load component.\r\n * \r\n * @param {string} tagName - The custom element tag name to check\r\n * @returns {boolean} True if the component is registered for lazy loading\r\n * \r\n * @example\r\n * if (isLazyLoadComponent('heavy-chart')) {\r\n *   loadLazyLoadComponent('heavy-chart');\r\n * }\r\n */\r\nexport function isLazyLoadComponent(tagName: string): boolean {\r\n  return tagName in lazyLoadComponentAliasByTagName;\r\n}\r\n\r\n/**\r\n * Triggers lazy loading of a component by tag name.\r\n * \r\n * Loads the component asynchronously via microtask queue and removes it from\r\n * the lazy-load registry to prevent duplicate loading.\r\n * \r\n * @param {string} tagName - The custom element tag name to load\r\n * @returns {void}\r\n * \r\n * @example\r\n * // When component is needed\r\n * loadLazyLoadComponent('heavy-chart');\r\n * // Component loads asynchronously in next microtask\r\n */\r\nexport function loadLazyLoadComponent(tagName: string): void {\r\n  const alias = lazyLoadComponentAliasByTagName[tagName];\r\n  \r\n  // Check if alias exists\r\n  if (!alias) {\r\n    // Treat as warning with structured metadata\r\n    const err = {\r\n      code: \"IMP-201\",\r\n      message: `Alias not found for tagName: ${tagName}`,\r\n      context: { where: 'loadFromImportMap.loadLazyLoadComponent', tagName },\r\n      docsUrl: \"./docs/error-codes.md#imp\",\r\n      severity: \"warn\" as const,\r\n    };\r\n    // Log warning instead of throwing to maintain existing behavior\r\n    console.warn(err.message, { code: err.code, context: err.context, docsUrl: err.docsUrl, severity: err.severity });\r\n    return;\r\n  }\r\n  \r\n  // Remove from registry to prevent duplicate loading\r\n  delete lazyLoadComponentAliasByTagName[tagName];\r\n  \r\n  // Load component asynchronously in microtask queue\r\n  queueMicrotask(() => {\r\n    // Load the SFC file\r\n    loadSingleFileComponent(alias).then((componentData) => {\r\n      // Create the component class\r\n      const componentClass = createComponentClass(componentData);\r\n      // Register as custom element\r\n      registerComponentClass(tagName, componentClass);\r\n    }).catch((error) => {\r\n      raiseError({\r\n        code: \"IMP-202\",\r\n        message: `Failed to load lazy component for tagName: ${tagName}`,\r\n        context: {\r\n          where: \"WebComponents.loadFromImportMap.loadLazyLoadComponent\",\r\n          tagName,\r\n          alias,\r\n          errorMessage: error instanceof Error ? error.message : String(error),\r\n        },\r\n        docsUrl: \"./docs/error-codes.md#imp\",\r\n        severity: \"error\",\r\n      });\r\n    });\r\n  });\r\n}\r\n","/**\r\n * Router.ts\r\n *\r\n * Implementation of Router custom element for single-page applications (SPA).\r\n *\r\n * Main responsibilities:\r\n * - Dynamically creates and displays custom elements based on URL path according to route definitions (entryRoute)\r\n * - History management and routing control using pushState/popstate events\r\n * - Route parameter extraction and passing to custom elements\r\n * - Display 404 page for undefined routes\r\n *\r\n * Design points:\r\n * - Register route path and custom element tag name pairs via entryRoute\r\n * - Automatically re-render on URL change via popstate event\r\n * - Extract route path parameters (:id etc.) using regex and pass via data-state attribute\r\n * - Global Router instance accessible via getRouter\r\n */\r\nimport { isLazyLoadComponent, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap\";\r\nimport { IRouter } from \"./types\";\r\n\r\nconst DEFAULT_ROUTE_PATH = '/'; // Default route path\r\nconst ROUTE_PATH_PREFIX = 'routes:'; // Prefix for route paths\r\n/**\r\n * example:\r\n * ```ts\r\n * entryRoute('my-view', '/my-view/:id');\r\n */\r\nconst routeEntries: Array<[string, string]> = [];\r\n\r\nlet globalRouter : Router | null = null;\r\n\r\n/**\r\n * Router custom element for SPA routing.\r\n * Manages URL-based navigation and dynamic component rendering.\r\n */\r\nexport class Router extends HTMLElement implements IRouter {\r\n  private _originalFileName = window.location.pathname.split('/').pop() || ''; // Store the original file name\r\n  private _basePath = document.querySelector('base')?.href.replace(window.location.origin, \"\") || DEFAULT_ROUTE_PATH;\r\n  private _popstateHandler: (event: PopStateEvent) => void;\r\n\r\n  /**\r\n   * Creates a new Router instance and binds popstate handler.\r\n   */\r\n  constructor() {\r\n    super();\r\n    this._popstateHandler = this.popstateHandler.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Web Component lifecycle callback invoked when element is connected to DOM.\r\n   * Sets up routing and triggers initial render.\r\n   */\r\n  connectedCallback() {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    globalRouter = this;\r\n    this.innerHTML = '<slot name=\"content\"></slot>';\r\n    window.addEventListener('popstate', this._popstateHandler);\r\n    window.dispatchEvent(new Event(\"popstate\")); // Dispatch popstate event to trigger the initial render\r\n  }\r\n\r\n  /**\r\n   * Web Component lifecycle callback invoked when element is disconnected from DOM.\r\n   * Cleans up event listeners.\r\n   */\r\n  disconnectedCallback() {\r\n    window.removeEventListener('popstate', this._popstateHandler);\r\n    globalRouter = null;\r\n  }\r\n\r\n  /**\r\n   * Handles popstate events for browser navigation.\r\n   * @param event - PopStateEvent from browser history navigation\r\n   */\r\n  popstateHandler(event: PopStateEvent) {\r\n    event.preventDefault();\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Navigates to a new route.\r\n   * @param to - Target path to navigate to\r\n   */\r\n  navigate(to: string) {\r\n    const toPath = to[0] === '/' ? (this._basePath + to.slice(1)) : to; // Ensure the path starts with '/'\r\n    history.pushState({}, '', toPath);\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Renders the current route by creating and displaying the matching custom element.\r\n   * Displays 404 if no route matches the current path.\r\n   */\r\n  render() {\r\n    // Clear slot content\r\n    const slotChildren = Array.from(this.childNodes).filter(\r\n      n => (n as HTMLElement).getAttribute?.('slot') === 'content'\r\n    );\r\n    slotChildren.forEach(n => this.removeChild(n));\r\n\r\n    const paths = window.location.pathname.split('/');\r\n    if (paths.at(-1) === this._originalFileName) {\r\n      paths[paths.length - 1] = ''; // Ensure the last path is empty for root\r\n    }\r\n    const pathName = paths.join('/');\r\n    const replacedPath = pathName.replace(this._basePath, ''); // Remove base path and ensure default route\r\n    const currentPath = replacedPath[0] !== '/' ? `/${  replacedPath}` : replacedPath; // Ensure the path starts with '/'\r\n    let tagName: string | undefined = undefined;\r\n    const params: Record<string, string> = {};\r\n    // Check if the routePath matches any of the defined routes\r\n    for (const [path, tag] of routeEntries) {\r\n      const regex = new RegExp(`^${  path.replace(/:[^\\s/]+/g, '([^/]+)')  }$`);\r\n      if (regex.test(currentPath)) {\r\n        tagName = tag;\r\n        // Extract the parameters from the routePath\r\n        const matches = currentPath.match(regex);\r\n        if (matches) {\r\n          const keys = path.match(/:[^\\s/]+/g) || [];\r\n          keys.forEach((key, index) => {\r\n            params[key.substring(1)] = matches[index + 1]; // +1 to skip the full match\r\n          });\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (tagName) {\r\n      // If a route matches, create the custom element and set its state\r\n      // Create the custom element with the tag name\r\n      // project the custom element into the router slot\r\n      const customElement = document.createElement(tagName);\r\n      customElement.setAttribute('data-state', JSON.stringify(params));\r\n      customElement.setAttribute('slot', 'content');\r\n      this.appendChild(customElement);\r\n      if (isLazyLoadComponent(tagName)) {\r\n        loadLazyLoadComponent(tagName); // Load lazy load component if necessary\r\n      }\r\n    } else {\r\n      // If no route matches, show 404 content\r\n      const messageElement = document.createElement('h1') as HTMLElement;\r\n      messageElement.setAttribute('slot', 'content');\r\n      messageElement.textContent = '404 Not Found';\r\n      this.appendChild(messageElement);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Registers a route entry mapping a custom element tag to a URL path.\r\n * @param tagName - Custom element tag name to render for this route\r\n * @param routePath - URL path pattern (supports parameters like :id)\r\n */\r\nexport function entryRoute(tagName: string, routePath: string): void {\r\n  let routePathNormalized;\r\n  if (routePath.startsWith(ROUTE_PATH_PREFIX)) {\r\n    routePathNormalized = routePath.substring(ROUTE_PATH_PREFIX.length); // Remove 'routes:' prefix\r\n  } else {\r\n    routePathNormalized = routePath;\r\n  }\r\n  routeEntries.push([routePathNormalized, tagName]);\r\n}\r\n\r\n/**\r\n * Gets the global Router instance.\r\n * @returns Current Router instance or null if not connected\r\n */\r\nexport function getRouter(): Router | null {\r\n  return globalRouter;\r\n}\r\n\r\n","/**\r\n * registerSingleFileComponents.ts\r\n *\r\n * Utility function to register multiple Single File Components (SFC) in bulk as Structive Web Components.\r\n *\r\n * Main responsibilities:\r\n * - Iterates through singleFileComponents (map of tagName to path) and asynchronously fetches and parses each SFC\r\n * - Registers routing information via entryRoute if enableRouter is active\r\n * - Generates Web Components classes via createComponentClass and registers them as custom elements via registerComponentClass\r\n *\r\n * Design points:\r\n * - Automates everything from SFC loading to Web Components registration and routing registration in bulk\r\n * - Supports dynamic registration of multiple components via asynchronous processing\r\n * - Flexible path processing including normalization of root path \"/root\" and removal of @routes prefix\r\n */\r\nimport { entryRoute } from \"../Router/Router.js\";\r\nimport { createComponentClass } from \"./createComponentClass.js\";\r\nimport { config } from \"./getGlobalConfig.js\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent.js\";\r\nimport { registerComponentClass } from \"./registerComponentClass.js\";\r\nimport { IUserComponentData, SingleFileComponents } from \"./types\";\r\n\r\n/**\r\n * Registers multiple SFC files as custom elements and optionally as routes.\r\n * \r\n * This function processes each SFC sequentially, loading the file, creating\r\n * a component class, and registering it. If routing is enabled and the path\r\n * starts with '@routes', it also registers the component as a route.\r\n * \r\n * @param {SingleFileComponents} singleFileComponents - Object mapping tag names to SFC file paths\r\n * @returns {Promise<void>} Resolves when all components are registered\r\n * @throws {Error} If any file cannot be fetched, parsed, or registered\r\n * @throws {DOMException} If any tag name is invalid or already registered\r\n * \r\n * @example\r\n * await registerSingleFileComponents({\r\n *   'my-button': './components/button.sfc',\r\n *   'user-card': '@components/user-card',\r\n *   'home-page': '@routes/home'  // Also registers as route if enableRouter is true\r\n * });\r\n */\r\nexport async function registerSingleFileComponents(singleFileComponents:SingleFileComponents):Promise<void> {\r\n  // Process each component sequentially to maintain order\r\n  for(const [ tagName, path ] of Object.entries(singleFileComponents)) {\r\n    let componentData : IUserComponentData | null = null;\r\n    \r\n    // If router is enabled and path looks like a route, register routing info\r\n    if (config.enableRouter) {\r\n      // Remove '@routes' prefix if present (e.g., '@routes/home' -> '/home')\r\n      const routePath = path.startsWith(\"@routes\") ? path.slice(7) : path;\r\n      // Normalize '/root' to '/' for the root route\r\n      entryRoute(tagName, routePath === \"/root\" ? \"/\" : routePath);\r\n    }\r\n    \r\n    // Load and parse the SFC file\r\n    componentData = await loadSingleFileComponent(path);\r\n    \r\n    // Generate a Web Components class from the parsed data\r\n    const componentClass = createComponentClass(componentData);\r\n    \r\n    // Register the class as a custom element\r\n    registerComponentClass(tagName, componentClass);\r\n  }\r\n}","/**\r\n * MainWrapper.ts\r\n *\r\n * Implementation of MainWrapper custom element that manages application-wide layout and routing.\r\n *\r\n * Main responsibilities:\r\n * - Enables Shadow DOM and dynamically loads layout templates\r\n * - Applies layout templates and styles\r\n * - Dynamically adds router element (routerTagName)\r\n *\r\n * Design points:\r\n * - Toggles Shadow DOM enable/disable via config.shadowDomMode\r\n * - If config.layoutPath is specified, fetches layout HTML and applies template and styles\r\n * - Applies styles to ShadowRoot or document using adoptedStyleSheets\r\n * - Inserts default slot if no layout is specified\r\n * - Adds router element to slot if config.enableRouter is enabled\r\n */\r\nimport { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\n\r\nconst SLOT_KEY = \"router\";\r\nconst DEFAULT_LAYOUT = `<slot name=\"${SLOT_KEY}\"></slot>`;\r\n\r\n/**\r\n * MainWrapper custom element for managing application layout and routing.\r\n * Extends HTMLElement to provide layout template loading and router integration.\r\n */\r\nexport class MainWrapper extends HTMLElement {\r\n  /**\r\n   * Creates a new MainWrapper instance and initializes Shadow DOM if configured.\r\n   */\r\n  constructor() {\r\n    super();\r\n    if (config.shadowDomMode !== \"none\") {\r\n      this.attachShadow({ mode: 'open' });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Web Component lifecycle callback invoked when element is connected to DOM.\r\n   * Loads layout and renders the component.\r\n   */\r\n  async connectedCallback() {\r\n    await this.loadLayout();\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Gets the root element for content insertion (ShadowRoot or this element).\r\n   * @returns ShadowRoot if Shadow DOM is enabled, otherwise the element itself\r\n   */\r\n  get root(): ShadowRoot | HTMLElement {\r\n    return this.shadowRoot ?? this;\r\n  }\r\n\r\n  /**\r\n   * Loads layout template from configured path or uses default layout.\r\n   * Fetches HTML, extracts template and styles, and applies them to root.\r\n   * @throws TMP-101 If layout fetch fails\r\n   */\r\n  async loadLayout() {\r\n    if (config.layoutPath) {\r\n      const response = await fetch(config.layoutPath);\r\n      if (response.ok) {\r\n        const layoutText = await response.text();\r\n        const workTemplate = document.createElement(\"template\");\r\n        workTemplate.innerHTML = layoutText;\r\n      \r\n        const template = workTemplate.content.querySelector(\"template\");\r\n        const style = workTemplate.content.querySelector(\"style\") as CSSStyleSheet | null;\r\n      \r\n        this.root.appendChild(template?.content ?? document.createDocumentFragment());\r\n        if (style) {\r\n          const shadowRootOrDocument = this.shadowRoot ?? document;\r\n          const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n          if (!styleSheets.includes(style)) {\r\n            shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, style];\r\n          }\r\n        }\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-101',\r\n          message: `Failed to load layout from ${config.layoutPath}`,\r\n          context: { where: 'MainWrapper.loadLayout', layoutPath: config.layoutPath },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n    } else {\r\n      this.root.innerHTML = DEFAULT_LAYOUT;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Renders the component by adding router element if enabled.\r\n   */\r\n  render() {\r\n    if (config.enableRouter) {\r\n      const router = document.createElement(config.routerTagName);\r\n      router.setAttribute('slot', SLOT_KEY);\r\n      this.root.appendChild(router);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * bootstrap.ts\r\n *\r\n * Entry point for initializing a Structive application.\r\n *\r\n * Main responsibilities:\r\n * - Registers and initializes necessary components, router, and main wrapper according to global configuration (config)\r\n * - Dynamically loads routes and components from importmap if autoLoadFromImportMap is enabled\r\n * - Registers Router component as a custom element if enableRouter is enabled\r\n * - Registers MainWrapper as a custom element if enableMainWrapper is enabled, and automatically inserts it into body if autoInsertMainWrapper is enabled\r\n *\r\n * Design points:\r\n * - Flexibly controls initialization processing according to configuration values\r\n * - Centralizes all processing necessary for Structive startup, including importmap, custom element registration, and automatic DOM insertion\r\n */\r\nimport { MainWrapper } from \"./MainWrapper/MainWrapper.js\";\r\nimport { Router } from \"./Router/Router.js\";\r\nimport { config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { loadFromImportMap } from \"./WebComponents/loadFromImportMap.js\";\r\n\r\n/**\r\n * Bootstraps the Structive application with configured features.\r\n * \r\n * This function initializes the application by:\r\n * 1. Loading components from importmap (if enabled)\r\n * 2. Registering the router component (if enabled)\r\n * 3. Registering the main wrapper and optionally inserting it into DOM (if enabled)\r\n * \r\n * Call this function once during application startup, typically after DOM is ready.\r\n * \r\n * @returns {Promise<void>} Resolves when bootstrap is complete\r\n * @throws {Error} If importmap loading fails or component registration encounters errors\r\n * @throws {DOMException} If custom element names are invalid or already registered\r\n * \r\n * @example\r\n * // Basic usage\r\n * await bootstrap();\r\n * \r\n * @example\r\n * // With configuration\r\n * import { config } from './WebComponents/getGlobalConfig';\r\n * config.enableRouter = true;\r\n * config.autoLoadFromImportMap = true;\r\n * await bootstrap();\r\n */\r\nexport async function bootstrap(): Promise<void> {\r\n  // Phase 1: Load components and routes from importmap if configured\r\n  if (config.autoLoadFromImportMap) {\r\n    // Scans <script type=\"importmap\"> tags and registers @routes/* and @components/*\r\n    await loadFromImportMap();\r\n  }\r\n\r\n  // Phase 2: Register router component if routing is enabled\r\n  if (config.enableRouter) {\r\n    // Registers the Router component with the configured tag name (default: 'view-router')\r\n    customElements.define(config.routerTagName, Router);\r\n  }\r\n\r\n  // Phase 3: Register and optionally insert main wrapper\r\n  if (config.enableMainWrapper) {\r\n    // Register MainWrapper component with the configured tag name (default: 'app-main')\r\n    customElements.define(config.mainTagName, MainWrapper);\r\n    \r\n    // Automatically insert main wrapper into document body if configured\r\n    if (config.autoInsertMainWrapper) {\r\n      const mainWrapper = document.createElement(config.mainTagName);\r\n      document.body.appendChild(mainWrapper);\r\n    }\r\n  }\r\n}","/**\r\n * exports.ts\r\n *\r\n * Module for publicly exposing Structive's primary entry points and APIs.\r\n *\r\n * Main responsibilities:\r\n * - Exports main APIs such as registerSingleFileComponents, bootstrap, and config\r\n * - defineComponents: Registers a group of SFCs and automatically initializes if autoInit is enabled\r\n * - bootstrapStructive: Executes initialization processing only once\r\n *\r\n * Design points:\r\n * - Makes global configuration (config) accessible and modifiable from external code\r\n * - Prevents multiple executions of initialization processing, ensuring safe startup\r\n */\r\nimport { registerSingleFileComponents } from \"./WebComponents/registerSingleFIleComponents.js\";\r\nimport { bootstrap } from \"./bootstrap.js\";\r\nimport { config as _config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { IConfig, ShadowDomMode } from \"./WebComponents/types\";\r\n\r\nexport const config: IConfig = _config;\r\nexport type { ShadowDomMode };\r\n\r\n/** Flag to prevent multiple initialization */\r\nlet initialized = false;\r\n\r\n/**\r\n * Defines and registers multiple Single File Components.\r\n * \r\n * This is the primary API for declaring components in a Structive application.\r\n * If config.autoInit is true, this function also automatically calls bootstrapStructive()\r\n * to initialize the application framework (router, main wrapper, etc.).\r\n * \r\n * @param {Record<string, string>} singleFileComponents - Object mapping tag names to SFC file paths\r\n * @returns {Promise<void>} Resolves when all components are registered (and bootstrap is complete if autoInit is true)\r\n * @throws {Error} If component loading, registration, or bootstrap fails\r\n * \r\n * @example\r\n * // Define components with auto-initialization\r\n * await defineComponents({\r\n *   'my-button': './components/button.sfc',\r\n *   'user-card': '@components/user-card',\r\n *   'home-page': '@routes/home'\r\n * });\r\n * \r\n * @example\r\n * // Define components without auto-initialization\r\n * config.autoInit = false;\r\n * await defineComponents({\r\n *   'my-component': './component.sfc'\r\n * });\r\n * await bootstrapStructive(); // Manually bootstrap later\r\n */\r\nexport async function defineComponents(singleFileComponents: Record<string, string>):Promise<void> {\r\n  // Register all provided SFC components\r\n  await registerSingleFileComponents(singleFileComponents);\r\n  \r\n  // Automatically bootstrap if configured\r\n  if (config.autoInit) {\r\n    await bootstrapStructive();\r\n  }\r\n}\r\n\r\n/**\r\n * Bootstraps the Structive application framework.\r\n * \r\n * This function initializes core features like the router and main wrapper based\r\n * on the global configuration. It ensures bootstrap only runs once, even if called\r\n * multiple times, making it safe to call from multiple places.\r\n * \r\n * Typically called automatically by defineComponents() if config.autoInit is true,\r\n * but can be manually invoked for more control over initialization timing.\r\n * \r\n * @returns {Promise<void>} Resolves when bootstrap is complete\r\n * @throws {Error} If bootstrap initialization fails\r\n * \r\n * @example\r\n * // Manual bootstrap\r\n * config.autoInit = false;\r\n * await defineComponents({ 'my-app': './app.sfc' });\r\n * await bootstrapStructive(); // Explicitly initialize framework\r\n * \r\n * @example\r\n * // Safe to call multiple times (only runs once)\r\n * await bootstrapStructive();\r\n * await bootstrapStructive(); // No-op, already initialized\r\n */\r\nexport async function bootstrapStructive():Promise<void> {\r\n  // Guard against multiple initialization\r\n  if (!initialized) {\r\n    // Execute core bootstrap process\r\n    await bootstrap();\r\n    // Mark as initialized to prevent re-execution\r\n    initialized = true;\r\n  }\r\n}\r\n\r\n"],"names":["config","trim","id","cache","subNameByName","_cache","symbolName","STACK_DEPTH","trapGet","StateHandler","trapSet","COMMENT_TEMPLATE_MARK_LEN","workFragment","_config"],"mappings":"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"}