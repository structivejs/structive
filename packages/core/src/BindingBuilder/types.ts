import { CreateBindingNodeByNodeFn } from "../DataBinding/BindingNode/types";
import { CreateBindingStateByStateFn } from "../DataBinding/BindingState/types";

/**
 * Type definition file for BindingBuilder module.
 *
 * This file provides interfaces and type definitions for handling
 * binding information within templates in a structured manner.
 * 
 * Main type definitions:
 * - NodeType: Enumeration of supported node types
 * - NodePath: Hierarchical index array representing node position
 * - IBindText: Structured data of parsed binding expression
 * - IFilterText: Filter definition (name and options)
 * - IDataBindAttributes: Complete binding information for one node
 * - IBindingCreator: Set of binding instance creation functions
 */

/**
 * Type definition for supported node types.
 * 
 * Description of each node type:
 * - HTMLElement: Regular HTML elements (div, span, input, etc.)
 *   Can have data-bind attribute
 * 
 * - SVGElement: SVG elements (svg, path, circle, etc.)
 *   Can have data-bind attribute
 * 
 * - Text: Text content binding
 *   Actually represented as comment node (<!-- @@:textContent:value -->),
 *   replaced with actual text node at runtime
 * 
 * - Template: Template (loops or conditional branches)
 *   Actually represented as comment node (<!-- @@:for:items --> etc.),
 *   expanded into dynamic content at runtime
 */
export type NodeType = "HTMLElement" | "SVGElement" | "Text" | "Template";

/**
 * Type definition for absolute path of a node.
 * 
 * Each element represents childNodes index at each level from root.
 * 
 * Structure:
 * - Each array element is childNodes index for each level
 * - Empty array [] represents root node itself
 * - [1, 2] represents root.childNodes[1].childNodes[2]
 * 
 * Usage examples:
 * ```typescript
 * // Root node itself
 * const rootPath: NodePath = [];
 * 
 * // First child of root
 * const firstChild: NodePath = [0];
 * 
 * // Third child of second child of root
 * const deepNode: NodePath = [1, 2];
 * ```
 */
export type NodePath = number[];

/**
 * Interface representing complete binding attribute information for one node.
 * 
 * Generated by registerDataBindAttributes,
 * holds information for each binding node within template.
 * 
 * Property descriptions:
 * - nodeType: Node type ("HTMLElement" | "SVGElement" | "Text" | "Template")
 * 
 * - nodePath: Absolute path from root (index array)
 *   Example: [1, 2] is root.childNodes[1].childNodes[2]
 * 
 * - bindTexts: Array of all binding expressions defined on this node
 *   Multiple bindings can be defined on one node
 *   Example: "value:name;class:active" → 2 IBindText objects
 * 
 * - creatorByText: Map of binding creation functions corresponding to each IBindText
 *   Used to create binding instances at runtime
 * 
 * Usage example:
 * ```typescript
 * // HTML: <input data-bind="value:email;class:active" />
 * const attrs: IDataBindAttributes = {
 *   nodeType: "HTMLElement",
 *   nodePath: [0, 1],
 *   bindTexts: [
 *     { nodeProperty: "value", stateProperty: "email", ... },
 *     { nodeProperty: "class", stateProperty: "active", ... }
 *   ],
 *   creatorByText: new Map([
 *     [bindText1, { createBindingNode: ..., createBindingState: ... }],
 *     [bindText2, { createBindingNode: ..., createBindingState: ... }]
 *   ])
 * };
 * ```
 */
export interface IDataBindAttributes {
  readonly nodeType: NodeType;
  readonly nodePath: NodePath;
  readonly bindTexts: IBindText[];
  readonly creatorByText: Map<IBindText, IBindingCreator>;
}

/**
 * Interface representing filter information.
 * 
 * Filters are used to transform state values or node values.
 * 
 * Property descriptions:
 * - name: Filter name (e.g., "eq", "default", "currency")
 *   Name of built-in or custom filter
 * 
 * - options: Array of options passed to filter
 *   Parameters to customize filter behavior
 *   Example: ["USD", "2"] for currency filter means currency and decimal places
 * 
 * Usage examples:
 * ```typescript
 * // "eq,100" → Check if value equals 100
 * const eqFilter: IFilterText = {
 *   name: "eq",
 *   options: ["100"]
 * };
 * 
 * // "default,N/A" → Use "N/A" if value is empty
 * const defaultFilter: IFilterText = {
 *   name: "default",
 *   options: ["N/A"]
 * };
 * 
 * // "currency,USD,2" → Display amount in USD format with 2 decimal places
 * const currencyFilter: IFilterText = {
 *   name: "currency",
 *   options: ["USD", "2"]
 * };
 * 
 * // "trim" → Filter without options
 * const trimFilter: IFilterText = {
 *   name: "trim",
 *   options: []
 * };
 * ```
 */
export interface IFilterText {
  readonly name: string;
  readonly options: string[];
}

/**
 * Interface representing structured information of parsed binding expression.
 * 
 * Generated by parseBindText, holds all information of binding expression.
 * 
 * Property descriptions:
 * - nodeProperty: Node property name to bind
 *   Example: "textContent", "value", "class", "style", "for"
 * 
 * - stateProperty: State property name to bind from
 *   Can specify nested properties with dot notation
 *   Example: "user.name", "items", "config.theme.color"
 * 
 * - inputFilterTexts: Filter array for state→node direction
 *   Filters applied when state value is displayed on node
 *   Example: "currency,USD" in "value|currency,USD:amount"
 * 
 * - outputFilterTexts: Filter array for node→state direction
 *   Filters applied when node value is reflected to state
 *   Example: "lowercase" in "value:email|lowercase"
 * 
 * - decorates: Array of decorators (additional features)
 *   Modifiers to add additional features to binding
 *   Example: "required", "debounce", "throttle"
 * 
 * Usage examples:
 * ```typescript
 * // Basic binding: "textContent:user.name"
 * const basicBind: IBindText = {
 *   nodeProperty: "textContent",
 *   stateProperty: "user.name",
 *   inputFilterTexts: [],
 *   outputFilterTexts: [],
 *   decorates: []
 * };
 * 
 * // With filter: "value|currency,USD:amount"
 * const filteredBind: IBindText = {
 *   nodeProperty: "value",
 *   stateProperty: "amount",
 *   inputFilterTexts: [{ name: "currency", options: ["USD"] }],
 *   outputFilterTexts: [],
 *   decorates: []
 * };
 * 
 * // With decorator: "value:email@required,trim"
 * const decoratedBind: IBindText = {
 *   nodeProperty: "value",
 *   stateProperty: "email",
 *   inputFilterTexts: [],
 *   outputFilterTexts: [],
 *   decorates: ["required", "trim"]
 * };
 * 
 * // Bidirectional filters: "value|trim:data.text|uppercase"
 * const bidirectionalBind: IBindText = {
 *   nodeProperty: "value",
 *   stateProperty: "data.text",
 *   inputFilterTexts: [{ name: "trim", options: [] }],
 *   outputFilterTexts: [{ name: "uppercase", options: [] }],
 *   decorates: []
 * };
 * ```
 */
export interface IBindText {
  readonly nodeProperty: string;
  readonly stateProperty: string;
  readonly inputFilterTexts: IFilterText[];
  readonly outputFilterTexts: IFilterText[];
  readonly decorates: string[];
}

/**
 * Interface representing set of binding instance creation functions.
 * 
 * Holds functions to create binding instances for node side and state side
 * for each binding.
 * 
 * Property descriptions:
 * - createBindingNode: Binding instance creation function for node side
 *   Creates instance to monitor and control DOM node changes
 * 
 * - createBindingState: Binding instance creation function for state side
 *   Creates instance to monitor and propagate state changes
 * 
 * Usage example:
 * ```typescript
 * const creator: IBindingCreator = {
 *   createBindingNode: (node, bindText) => {
 *     // Create node side binding
 *     return new BindingNode(node, bindText);
 *   },
 *   createBindingState: (state, bindText) => {
 *     // Create state side binding
 *     return new BindingState(state, bindText);
 *   }
 * };
 * ```
 */
export interface IBindingCreator {
  readonly createBindingNode: CreateBindingNodeByNodeFn;
  readonly createBindingState: CreateBindingStateByStateFn;
}